{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simplicial HoTT and synthetic \u221e-categories","text":"<p>Info</p> <p>This project originated as a fork of  emilyriehl/yoneda.</p> <p>This is a formalization library for simplicial Homotopy Type Theory (sHoTT) with the aim of proving resulting in synthetic \u221e-category theory, starting with the results from the following papers:</p> <ul> <li>\"A type theory for synthetic \u221e-categories\"   <sup>1</sup></li> <li>\"Synthetic fibered (\u221e,1)-category theory\"   <sup>2</sup></li> <li>\"Limits and colimits of synthetic \u221e-categories\"   <sup>3</sup></li> </ul> <p>This formalization project follows the philosophy laid out in the article \"Could \u221e-category theory be taught to undergraduates?\" <sup>4</sup>.</p> <p>The formalizations are implemented using <code>rzk</code>, an experimental proof assistant for a variant of type theory with shapes.</p> <p>See the list of contributors to this formalisation project at <code>CONTRIBUTORS.md</code>.</p>"},{"location":"#checking-the-formalisations-locally","title":"Checking the formalisations locally","text":"<p>It is recommended to use VS Code extension for Rzk (available in Visual Studio Marketplace, as well as in Open VSX). The extension should then manage an <code>rzk</code> executable and provide some feedback directly in VS Code, without users having to use the command line.</p> <p>Otherwise, install the <code>rzk</code> proof assistant from sources. Then run the following command from the root of this repository:</p> <pre><code>rzk typecheck src/hott/* src/simplicial-hott/*\n</code></pre> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>Ulrik Buchholtz and Jonathan Weinberger. Synthetic fibered (\u221e, 1)-category theory. Higher Structures 7 (2023), 74\u2013165. Issue 1. https://doi.org/10.21136/HS.2023.04 \u21a9</p> </li> <li> <p>C\u00e9sar Bardomiano Mart\u00ednez. Limits and colimits of synthetic \u221e-categories. 1-33, 2022. https://arxiv.org/abs/2202.12386 \u21a9</p> </li> <li> <p>Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html \u21a9</p> </li> </ol>"},{"location":"CONTRIBUTORS/","title":"A list of contributors","text":"<p>Formalizations were contributed by the following people (listed alphabetically):</p> <ul> <li>Abdelrahman Aly Abounegm,</li> <li>Fredrik Bakke,</li> <li>C\u00e9sar Bardomiano Mart\u00ednez,</li> <li>Jonathan Campbell,</li> <li>Aras Ergus,</li> <li>Matthias Hutzler,</li> <li>Nikolai Kudasov,</li> <li>Kenji Maillard,</li> <li>David Mart\u00ednez Carpena,</li> <li>Sti\u00e9phen Pradal,</li> <li>Nima Rasekh,</li> <li>Emily Riehl,</li> <li>Florrie Verity,</li> <li>Tashi Walde, and</li> <li>Jonathan Weinberger.</li> </ul> <p>You may see actual contributed commits in the Contributors page on GitHub.</p>"},{"location":"STYLEGUIDE/","title":"Style guide and design principles","text":"<p>The <code>sHoTT</code> project is an evolving community effort, and your participation is most welcomed! However, to make the library as useful as possible for everyone, we ask that everyone comply to a common set of style guidelines.</p> <p>Good style conventions don't just serve to homogenize code and make things look pretty, but they serve to</p> <ul> <li>Elucidate the structure of proofs and definitions through proper formatting.</li> <li>Effectively summarize definitions and arguments through good naming   conventions.</li> <li>Make the formalization base easier to navigate.</li> <li>Help us maintain the repository.</li> <li>Provide techniques and habits that help you in the formalization process.</li> </ul> <p>Please note that these conventions will and should change as the project and language develops. We acknowledge that our code is not always consistent with our conventions, and appreciate your help keeping the library compliant and clean.</p>"},{"location":"STYLEGUIDE/#the-structure-of-code","title":"The structure of code","text":"<p>We enforce strict formatting rules. These rules facilitate better readability of the code and aids in understanding the structure of every. The general format of a definition is as follows:</p> <pre><code>#def concat\n( p : x = y)\n( q : y = z)\n  : (x = z)\n  := ind-path A y (\\ z' q' \u2192 (x = z')) p z q\n</code></pre> <ul> <li> <p>We start with the name, and place every assumption on a new line.</p> </li> <li> <p>The conclusion of the definition is placed on its own line, which starts with   a colon (<code>:</code>).</p> </li> <li> <p>On the next line, the walrus separator (<code>:=</code>) is placed, and after it follows   the actual construction of the definition. If the construction does not fit on   a single line, by which we mean fit within our stipulated 80-character limit,   we immediately insert a new line after the walrus separator. Note, in   particular, to avoid excessive indentation we do not indent the code an extra   level in this particular case.</p> </li> </ul>"},{"location":"STYLEGUIDE/#the-tree-structure-of-constructions","title":"The tree structure of constructions","text":"<p>In the Rzk language, every construction is structured like a tree, where each operation can be seen as a branching point. We use indentation and parenthization conventions to highlight this structure, which makes the code more organized and readable. For example, when part of a definition extends beyond a single line, we introduce line breaks at the earliest sensible branching point, clearly displaying the tree structure of the definition. This allows the reader to follow the branches of the tree, and to visually grasp the scope of each operation and argument. Consider the following example about Segal types:</p> <pre><code>#def is-segal-is-local-horn-inclusion\n( A : U)\n( is-local-horn-inclusion-A : is-local-horn-inclusion A)\n  : is-segal A\n  :=\n\\ x y z f g \u2192\n  contractible-fibers-is-equiv-projection\n  ( \u039b \u2192 A)\n( \\ k \u2192\n    \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n    , ( hom2 A\n        ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n        ( \\ t \u2192 k (t , 0\u2082))\n        ( \\ t \u2192 k (1\u2082 , t))\n        ( h)))\n( second\n    ( equiv-comp\n      ( \u03a3 ( k : \u039b \u2192 A)\n        , \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n          , ( hom2 A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082))\n              ( \\ t \u2192 k (1\u2082 , t))\n              ( h)))\n      ( \u0394\u00b2 \u2192 A)\n      ( \u039b  \u2192 A)\n      ( inv-equiv\n        ( \u0394\u00b2 \u2192 A)\n( \u03a3 ( k : \u039b \u2192 A)\n          , \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n            , ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082))\n                ( \\ t \u2192 k (1\u2082 , t))\n                ( h)))\n        ( equiv-horn-restriction A))\n      ( horn-restriction A , is-local-horn-inclusion-A)))\n  ( horn A x y z f g)\n</code></pre> <p>The root in this instance is the function <code>projection-equiv-contractible-fibers</code>. It takes four arguments, each starting on a fresh line and is parenthesized. Note that its parentheses are indented at the same level as its parent node. The first argument fits neatly on one line, but the second one is too large. In this case, we add a line break right after the <code>\u2192</code>-symbol following the lambda-abstraction, which we consider the earliest branching point in this case. The next node is again <code>\u03a3</code>, with two arguments. The first one fits on a line, but the second does not, so we add a line break between them since <code>\u03a3</code> is only one character. This process is continued until the definition is complete.</p> <p>Observe also that we use indentation to highlight the branches. The extra space after the opening parentheses marking a branch is there to visually emphasize the tree structure of the definition, and synergizes with our convention to have two-space indentation level increases.</p> <p>What is generally considered the \"earliest sensible branching point\" will depend on context, and we ask that contributors practice common sense when determining this. For instance, it may be sensible to group some arguments together on a line. Already in our example above we wrote</p> <pre><code>  hom2 A\n  ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n  ( \\ t \u2192 k (t , 0\u2082))\n  ( \\ t \u2192 k (1\u2082 , t))\n  ( h)\n</code></pre> <p>visually grouping together <code>hom2</code> and <code>A</code>, and again the next three arguments, emphasizing their connection to eachother. When in doubt, it is generally better to break lines sooner rather than later.</p>"},{"location":"STYLEGUIDE/#other-code-conventions","title":"Other code conventions","text":"<ul> <li>We employ an 80-character line length limit. This means that lines of code   generally should not be longer than 80 characters. If they exceed this limit,   they should be reformatted to fit within the limit by inserting appropriate   line breaks.</li> </ul> <p>!!! info</p> <pre><code>  Names can be longer than the line character limit.\n</code></pre> <ul> <li>We place binary operators/separators at the beginning of a line rather than   the end. When they are a single character wide, this aligns very well with our   parenthization and indentation rules. Consider for instance the following   sample code:</li> </ul> <pre><code>( moderately-long-name-of-a-function-A\n  ( a-very-complicated-term-with-a-very-long-name-or-description-B\n  , another-long-and-complicated-expression-for-another-term-C))\n</code></pre> <p>Our indentation convention has the beautiful feature that we can determine the   structure of the code simply by scanning the left edge of the code block. The   placement of the comma separator in the example above complements this neatly,   since we can immediately see that <code>function-A</code> is applied to the pair   <code>(term-B , term-C)</code> by scanning the left edge of the code.</p> <p>Similarly, consider also</p> <pre><code>( ( a-long-and-complicated-arithmetic-expression-involving-many-operations)\n* ( another-complicated-and-long-expression-with-symbols-and-numbers))\n</code></pre> <p>By having the multiplication symbol on the start of the line we can   immediately see that we are multiplying the two long expressions together, as   opposed to performing some other operation.</p> <p>Similarly, we also place function type formation arrows at the start of the   next line. E.g.</p> <pre><code>#def function\n( parameter-1 : type-1)\n( parameter-2 : type-2)\n  : type-with-a-name-3\n  \u2192 type-with-a-longer-name-4\n  \u2192 short-type-5\n  := undefined\n</code></pre> <p>!!! warning</p> <pre><code>  This should not be confused with the convention for placement of arrows\n  for lambda abstractions, which should be placed at the end of the line\n  instead.\n</code></pre> <p>When the binary operator/separator is more than a single character wide, e.g.   for the walrus separator (<code>:=</code>) and identity type formation with explicitly   passed underlying type (<code>=_{...}</code>), we insert a new line directly after the   operator as well. I.e.</p> <pre><code>( ( a-term-of-a-type)\n=_{ the-name-of-the-type}\n  ( another-term-of-that-type))\n</code></pre> <ul> <li>The <code>uses</code>-keyword and the accompanying list of variables is placed on their   own lines.</li> </ul> <p>In the base case, write</p> <pre><code>#define my-name\n  uses (my-variable-1 my-variable-2 ...)\n( A : U)\n  ...\n</code></pre> <p>If the variable list (<code>(my-variable-1 my-variable-2 ...)</code>) does not fit on the   first line together with <code>uses</code>, insert a line break directly after <code>uses</code> and   write:</p> <pre><code>#define my-name\n  uses\n    ( my-variable-1 my-variable-2 ...)\n( A : U)\n  ...\n</code></pre> <p>If the list still does not fit on a single line, start insert line breaks   between variables. Here, there is some room for common sense in where the line   breaks should be inserted, allowing for certain variable names to be grouped   together:</p> <pre><code>#define my-name\n  uses\n    ( my-variable-1\n      my-variable-2\n      ...)\n( A : U)\n  ...\n</code></pre> <ul> <li>If you find that the separation between the type signature of a definition and   its construction is not visually clear, we permit the insertion of an   additional line break after the walrus separator (<code>:=</code>).</li> </ul>"},{"location":"STYLEGUIDE/#naming-conventions","title":"Naming conventions","text":"<p>Adhering to a good naming convention is essential for keeping the library navigable and maintainable, and helps you make progress with your formalization goals. Good names provide concise descriptions of an entry's purpose, and help making the code in the library readable. The intent of our conventions can be summarized as follows:</p> <ul> <li>Entry names aim to concisely describe their mathematical concept, using   well-known mathematical vocabulary.</li> <li>While an entry's name reflects its concept, it avoids relying on the details   of its formalization. This way, a user is not required to know how something   is formalized in order to reference an entry.</li> <li>Even with only minimal knowledge of the conventions, readers should be able to   intuitively grasp an entry's purpose from its name.</li> <li>The naming conventions should apply regardless of topic or subfield.</li> <li>For many common kinds of entries, our naming conventions should offer a   predictable suggestion of what its name should be.</li> <li>In this way, our conventions should help generate names for definitions.</li> <li>Ultimately, our goal is for these conventions to support clear and   maintainable code.</li> </ul>"},{"location":"STYLEGUIDE/#a-general-naming-scheme","title":"A general naming scheme","text":"<p>With the basic purpose in mind, we present an adapted possible general naming scheme originally due to Egbert Rijke.</p> <p>The general pattern looks as follows:</p> <pre><code>  [descriptor]-[output-type]-[input-types]-[Namespace]\n</code></pre> <p>Every part of the pattern is optional. However, their order is fixed. The general naming pattern is broken into the following parts:</p> <ul> <li>: A custom descriptive name part for the entry.</li> <li>: Refers to the concluding type of the entry.</li> <li>: Consists of references to noteworthy input types.</li> <li>: Refers to an overarching concept, a subuniverse which the   construction takes place in, or a general category the entry is about.</li> </ul> <p>In particular, since Rzk does not currently have a suitable namespace mechanism, the <code>[Namespace]</code> field serves as a reasonable substitute.</p> <p>Now, let us consider some examples:</p> <ul> <li><code>rzk   #def function-type-Segal     ( A B : Segal)     : Segal</code></li> </ul> <p>This definition uses the pattern <code>[output-type]-[Namespace]</code>.</p> <ul> <li><code>is-segal-is-local-horn-inclusion</code> uses the pattern   <code>[output-type]-[input-types]</code>.</li> <li><code>is-equiv-identity</code> uses the pattern <code>[output-type]</code>.</li> </ul> <p>The descriptor pattern is by far the most versatile one. Its purpose is to give special meaningful descriptions that accurately represent some aspect, or precisely the concept in question. For instance, if a concept is known best by a special name, that name should probably be used.</p> <ul> <li>As an example, the canonical function with type signature</li> </ul> <pre><code>(A \u2192 B \u2192 C) \u2192 (A \u00d7 B \u2192 C)\n</code></pre> <p>should be called <code>uncurry</code>, using the <code>descriptor</code>-pattern. It should not, for   instance, be called <code>map-from-product-map-of-maps</code>.</p> <ul> <li>Another example is <code>compute-hom-eq-extension-type-is-discrete</code>. This uses the   pattern <code>[descriptor]-[output-type]-[input-types]</code>   (<code>(compute)-(hom)-(eq-extension-type-is-discrete)</code>).</li> </ul>"},{"location":"STYLEGUIDE/#conclusions-first","title":"Conclusions first!","text":"<p>The most noteworthy aspect of our general naming scheme is that conclusions always end up at the start of the name. This has the benefit that the most important aspect of a definition is what is mentioned first in its name. Although it can take a little while to get used to this scheme as everything is written in the opposite order you may be used to, it offers the following central benefit: the name summarizes the entry's meaning efficiently, even if only part of it is read. This means that when a reader is scanning the application of a definition in a larger proof, they can get an overview by only scanning the first few words at each branching point/line.</p> <p>Hence, if you are at a loss for naming a definition, we offer you the following simplified naming scheme: start with the first important assumption in your definition statement, and to it, prepend every subsequent important assumption that is made. Finally, prepend the concluding type.</p> <ul> <li>For example, consider an entry with the following signature</li> </ul> <pre><code>#def ?????\n( A B : U)\n( is-prop-A : is-prop A)\n( is-prop-B : is-prop B)\n  ( (f , g) : iff A B)\n  : is-equiv A B f\n  := ...\n</code></pre> <p>applying the scheme we get</p> <ol> <li><code>is-prop</code>, noting the assumption that <code>A</code> is a proposition. We do not      include variable names in the entry's name.</li> <li><code>is-prop-is-prop</code>, noting the assumption that <code>B</code> is a proposition.</li> <li><code>iff-is-prop-is-prop</code>, noting the assumption that we have a logical      equivalence between <code>A</code> and <code>B</code>.</li> <li><code>is-equiv-iff-is-prop-is-prop</code>, finally prepending the concluding type.</li> </ol> <p>Hence our final definition will be</p> <pre><code>#def is-equiv-iff-is-prop-is-prop\n( A B : U)\n( is-prop-A : is-prop A)\n( is-prop-B : is-prop B)\n  ( (f , g) : iff A B)\n  : is-equiv A B f\n  := ...\n</code></pre> <p>Observe how it is immediately clear what the elements that go into the entry   are, in which order they go, and what you get out if applying it!</p>"},{"location":"STYLEGUIDE/#table-of-common-descriptors","title":"Table of common descriptors","text":"<p>To give a sense of the kind of general descriptors we use, we list some common descriptors with examples in the table below.</p> Descriptor Purpose Example <code>coherence</code> Used for proofs of coherence. <code>coherence-is-half-adjoint-equiv</code> <code>compute</code> Used for proofs of computation, which may be an identification or an element of any other identity system. <code>compute-postwhisker-homotopy-is-segal</code> <code>Eq</code> Used for identity systems on types where <code>htpy</code> or <code>equiv</code> is not an appropriate descriptor of the identity system. <code>Eq-\u03a3</code> <code>eq</code> Used as a descriptor for the identity type. <code>eq-htpy</code> <code>equiv</code> Used for equivalences, and also for names of identity systems of universe-like types. <code>equiv-ap-is-equiv</code> <code>extensionality</code> Used for computations of identity types. <code>extensionality-\u03a3</code> <code>homotopy</code> or <code>htpy</code> Used for constructions of homotopies, and also for names of identity systems of function-like types. <code>homotopy-section-retraction-is-equiv</code> <code>is-property</code> Used when <code>is-prop</code> is unavailable. <code>is-property-is-contr</code> <code>map</code> Used in two ways: as the functorial action of a type constructor, but also as the underlying map of a morphism. <code>map-inverse-has-inverse</code> <code>type</code> Used for the underlying type of an object. <code>type-Segal</code> <code>statement</code> Used for definitions which are statements of things. <code>statement-homotopy-interchange-law</code>"},{"location":"STYLEGUIDE/#exceptions-and-naming-practices-to-avoid","title":"Exceptions and naming practices to avoid","text":"<ul> <li> <p>We use Unicode symbols in names very sparingly and only when they align with   established mathematical practice. See the next section for more elaboration.</p> </li> <li> <p>We never refer to variables in definition names. The only instance we allow   this is when that variable is available at every possible invoking site. For   instance, we can name the argument of <code>is-segal-is-local-horn-inclusion</code> of   type <code>is-local-horn-inclusion A</code> as <code>is-local-horn-inclusion-A</code>, since   anywhere it can be invoked, the name <code>A</code> is also in scope. However, we would   never name <code>is-segal-is-local-horn-inclusion</code> as   <code>is-segal-A-is-local-horn-inclusion</code>.</p> </li> <li> <p>For technical lemmas or definitions, where the chance they will be reused is   very low, the specific names do not matter as much. In these cases, you may   resort to a simplified naming scheme, like enumeration. Please keep in mind,   however, that if you find yourself appealing to this convention frequently,   that is a sign that your code should be refactored.</p> </li> </ul> <p>In closing, we note that the naming conventions are aimed at improving the readability of the code, not to ensure the shortest possible names, nor to minimize the amount of typing by the implementers of the library.</p>"},{"location":"STYLEGUIDE/#use-of-unicode-characters","title":"Use of Unicode characters","text":"<p>Although using Unicode characters in definition names is entirely permissible, we recommend practicing restraint to maintain readability. For instance, although products of shapes can be formed with the <code>\u00d7</code> binary operator, we prefer to refer to it as <code>product</code> in names.</p> <p>When it comes to using builtin syntactic features of <code>rzk</code>, however, we use the following symbols:</p> <ul> <li><code>\u2192</code> should be used over <code>-&gt;</code> (<code>\\to</code>)</li> <li><code>\u21a6</code> should be used over <code>|-&gt;</code> (<code>\\mapsto</code>)</li> <li><code>\u2261</code> should be used over <code>===</code> (<code>\\equiv</code>)</li> <li><code>\u2264</code> should be used over <code>&lt;=</code> (<code>\\&lt;=</code>)</li> <li><code>\u2227</code> should be used over <code>/\\</code> (<code>\\and</code>)</li> <li><code>\u2228</code> should be used over <code>\\/</code> (<code>\\or</code>)</li> <li><code>0\u2082</code> should be used over <code>0_2</code> (<code>0\\2</code>)</li> <li><code>1\u2082</code> should be used over <code>1_2</code> (<code>1\\2</code>)</li> <li><code>I \u00d7 J</code> should be used over <code>I * J</code> (<code>\\x</code> or <code>\\times</code>)</li> </ul> <p>Info</p> <p>For <code>first</code>, <code>second</code>, <code>TOP</code> and <code>BOT</code>, we prefer the ASCII versions as opposed to <code>\u03c0\u2081</code>, <code>\u03c0\u2082</code>, <code>\u22a4</code> and <code>\u22a5</code>, as we find the latter don't read too well in the code. Please also note that we usually prefer the use of named projections for special <code>\u03a3</code>-types when these are defined.</p>"},{"location":"STYLEGUIDE/#use-of-comments","title":"Use of comments","text":"<p>Since we are using literate file formats, the need for comments in the code should be heavily limited. If you feel the need to comment your code, then please consider the following:</p> <ul> <li>Descriptive names for definitions should make their use self-documenting. If   you are finding that you want to explain an application of a definition,   consider giving it a better name, or creating an intermediate definition with   a name that better describes your current aplication.</li> </ul> <p>In particular, if some family of <code>\u03a3</code>-types is given a name, we prefer to also   define and use named projections for it instead of <code>first</code> and <code>second</code>. In   many cases, their meaning is not immediately obvious, and so one could be   tempted to annotate the code using comments to explain them.</p> <p>For example, instead of writing <code>first (second is-invertible-f)</code>, we define a   named projection <code>is-section-is-invertible</code>. This may then be used as   <code>is-section-is-invertible A B f is-invertible-f</code> elsewhere. This way, the code   becomes self-documenting.</p> <p>However, we recognize that in Rzk, since we do not have the luxury of implicit   arguments, this may sometimes cause overly verbose code. In such cases, you   may revert to using <code>first</code> and <code>second</code>.</p> <ul> <li> <p>Can your code be structured in a way that makes it more readable? Are you   structuring it according to our conventions, or can our conventions be   improved to make it more readable?</p> </li> <li> <p>Can the comments naturally be converted to prose that can be placed outside of   the coding environment in the literate file?</p> </li> </ul>"},{"location":"STYLEGUIDE/#literary-conventions","title":"Literary conventions","text":"<ul> <li> <p>For consistency, we prefer to write in US English.</p> </li> <li> <p>Headers are written using sentence casing, as opposed to title casing.</p> </li> <li> <p>If the contents of a code block in some sense captures a section of an   external source, the <code>title</code>-field may be used to reference that section.</p> </li> </ul> <p>For example:</p> <pre><code>```rzk title=\"RS17, Definition 10.6\"\n#def is-rezk\n( A : U)\n  : U\n  :=\n\u03a3 ( is-segal-A : is-segal A)\n  , ( (x : A)\n    \u2192 (y : A)\n    \u2192 is-equiv (x = y) (Iso A is-segal-A x y) (iso-eq A is-segal-A x y))\n```\n</code></pre> <p>The <code>title</code>-field may also be used to give descriptive headers to sections of   your code.</p> <ul> <li>We use the autoformatting tool Prettier to format   markdown code, and we recommend that you install it or an alternative for use   with your editor. Be aware that the formatting rules automated by Prettier are   enforced by our CI workflow, so pull requests cannot be merged without the   proper markdown formatting.</li> </ul>"},{"location":"STYLEGUIDE/#adapting-and-evolving-the-style-guide","title":"Adapting and evolving the style guide","text":"<p>As mentioned in the introduction, we reiterate that this style guide will necessarily evolve as we learn to use Rzk in new and better ways, and as the language itself develops. Remember, the goal is at all times is to have code that is easy to read, navigate and maintain, even for those who are not the original authors.</p>"},{"location":"STYLEGUIDE/#references","title":"References","text":"<p>Our style guide and design principles borrow heavily from <code>agda-unimath</code>. If you are looking for more inspiration, have a look at:</p> <ul> <li>The design philosophy of <code>agda-unimath</code></li> <li>The <code>agda-unimath</code> library style guide</li> <li>Naming conventions for <code>agda-unimath</code></li> </ul>"},{"location":"hott/00-common.rzk/","title":"0. Common","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/00-common.rzk/#products-of-types","title":"products of types","text":"<pre><code>#def product\n( A B : U)\n  : U\n  := \u03a3 (x : A) , B\n</code></pre> <p>The following demonstrates the syntax for constructing terms in Sigma types:</p> <pre><code>#def diagonal\n( A : U)\n( a : A)\n  : product A A\n  := (a , a)\n</code></pre>"},{"location":"hott/00-common.rzk/#the-type-of-logical-equivalences-between-types","title":"The type of logical equivalences between types","text":"<pre><code>#def iff\n( A B : U)\n  : U\n  := product (A \u2192 B) (B \u2192 A)\n</code></pre>"},{"location":"hott/00-common.rzk/#basic-function-definitions","title":"Basic function definitions","text":"<pre><code>#section basic-functions\n#variables A B C D E : U\n#def comp\n( g : B \u2192 C)\n( f : A \u2192 B)\n  : A \u2192 C\n  := \\ z \u2192 g (f z)\n#def triple-comp\n( h : C \u2192 D)\n( g : B \u2192 C)\n( f : A \u2192 B)\n  : A \u2192 D\n  := \\ z \u2192 h (g (f z))\n#def quadruple-comp\n( k : D \u2192 E)\n( h : C \u2192 D)\n( g : B \u2192 C)\n( f : A \u2192 B)\n  : A \u2192 E\n  := \\ z \u2192 k (h (g (f z)))\n#def identity\n  : A \u2192 A\n  := \\ a \u2192 a\n#def constant\n( b : B)\n  : A \u2192 B\n  := \\ a \u2192 b\n#end basic-functions\n</code></pre>"},{"location":"hott/00-common.rzk/#substitution","title":"Substitution","text":"Reindexing a type family along a function into the base type<pre><code>#def reindex\n( A B : U)\n( f : B \u2192 A)\n( C : A \u2192 U)\n  : B \u2192 U\n  := \\ b \u2192 C (f b)\n</code></pre>"},{"location":"hott/00-common.rzk/#maps","title":"Maps","text":"<pre><code>#def Map\n  : U\n  := \u03a3 ((A',A) : product U U) , (A' \u2192 A)\n#def the-map-Map\n  ( ((A',A),\u03b1) : Map)\n  : A' \u2192 A\n  := \u03b1\n#def the-domain-Map\n  ( ((A',_),_) : Map)\n  : U\n  := A'\n#def the-codomain-Map\n  ( ((_,A),_) : Map)\n  : U\n  := A\n</code></pre>"},{"location":"hott/01-paths.rzk/","title":"1. Paths","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-induction","title":"Path induction","text":"<p>We define path induction in terms of the built-in J rule, so that we can apply it like any other function.</p> <pre><code>#define ind-path\n( A : U)\n( a : A)\n( C : (x : A) -&gt; (a = x) -&gt; U)\n( d : C a refl)\n( x : A)\n( p : a = x)\n  : C x p\n  := idJ (A , a , C , d , x , p)\n</code></pre> <p>To emphasize the fact that this version of path induction is biased towards paths with fixed starting point, we introduce the synonym <code>ind-path-start</code>. Later we will construct the analogous path induction <code>ind-path-end</code>, for paths with fixed end point.</p> <pre><code>#define ind-path-start\n( A : U)\n( a : A)\n( C : (x : A) -&gt; (a = x) -&gt; U)\n( d : C a refl)\n( x : A)\n( p : a = x)\n  : C x p\n  :=\n    ind-path A a C d x p\n</code></pre>"},{"location":"hott/01-paths.rzk/#some-basic-path-algebra","title":"Some basic path algebra","text":"<pre><code>#section path-algebra\n#variable A : U\n#variables x y z : A\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-reversal","title":"Path reversal","text":"<pre><code>#def rev\n( p : x = y)\n  : y = x\n  := ind-path (A) (x) (\\ y' p' \u2192 y' = x) (refl) (y) (p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-concatenation","title":"Path concatenation","text":"<p>We take path concatenation defined by induction on the second path variable as our main definition.</p> <pre><code>#def concat\n( p : x = y)\n( q : y = z)\n  : (x = z)\n  := ind-path (A) (y) (\\ z' q' \u2192 (x = z')) (p) (z) (q)\n</code></pre> <p>We also introduce a version defined by induction on the first path variable, for situations where it is easier to induct on the first path.</p> <pre><code>#def concat'\n( p : x = y)\n  : (y = z) \u2192 (x = z)\n  := ind-path (A) (x) (\\ y' p' \u2192 (y' = z) \u2192 (x = z)) (\\ q' \u2192 q') (y) (p)\n#end path-algebra\n</code></pre>"},{"location":"hott/01-paths.rzk/#some-basic-coherences-in-path-algebra","title":"Some basic coherences in path algebra","text":"<pre><code>#section basic-path-coherence\n#variable A : U\n#variables w x y z : A\n#def rev-rev\n( p : x = y)\n  : (rev A y x (rev A x y p)) = p\n  :=\n    ind-path\n    ( A) (x) (\\ y' p' \u2192 (rev A y' x (rev A x y' p')) = p') (refl) (y) (p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#left-unit-law-for-path-concatenation","title":"Left unit law for path concatenation","text":"<p>The left unit law for path concatenation does not hold definitionally due to our choice of definition.</p> <pre><code>#def left-unit-concat\n( p : x = y)\n  : (concat A x x y refl p) = p\n  := ind-path (A) (x) (\\ y' p' \u2192 (concat A x x y' refl p') = p') (refl) (y) (p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#associativity-of-path-concatenation","title":"Associativity of path concatenation","text":"<pre><code>#def associative-concat\n( p : w = x)\n( q : x = y)\n( r : y = z)\n  : ( concat A w y z (concat A w x y p q) r) =\n    ( concat A w x z p (concat A x y z q r))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' r' \u2192\n        concat A w y z' (concat A w x y p q) r' =\n        concat A w x z' p (concat A x y z' q r'))\n      ( refl)\n      ( z)\n      ( r)\n#def rev-associative-concat\n( p : w = x)\n( q : x = y)\n( r : y = z)\n  : ( concat A w x z p (concat A x y z q r)) =\n    ( concat A w y z (concat A w x y p q) r)\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' r' \u2192\n          concat A w x z' p (concat A x y z' q r') =\n          concat A w y z' (concat A w x y p q) r')\n      ( refl)\n      ( z)\n      ( r)\n#def right-inverse-concat\n( p : x = y)\n  : (concat A x y x p (rev A x y p)) = refl\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 concat A x y' x p' (rev A x y' p') = refl)\n      ( refl)\n      ( y)\n      ( p)\n#def left-inverse-concat\n( p : x = y)\n  : (concat A y x y (rev A x y p) p) = refl\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 concat A y' x y' (rev A x y' p') p' = refl)\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#concatenation-of-two-paths-with-common-codomain","title":"Concatenation of two paths with common codomain","text":"<p>Concatenation of two paths with common codomain; defined using <code>concat</code> and <code>rev</code>.</p> <pre><code>#def zig-zag-concat\n( p : x = y)\n( q : z = y)\n  : (x = z)\n  := concat A x y z p (rev A z y q)\n</code></pre>"},{"location":"hott/01-paths.rzk/#concatenation-of-two-paths-with-common-domain","title":"Concatenation of two paths with common domain","text":"<p>Concatenation of two paths with common domain; defined using <code>concat</code> and <code>rev</code>.</p> <pre><code>#def zag-zig-concat\n(p : y = x)\n(q : y = z)\n  : (x = z)\n  := concat A x y z (rev A y x p) q\n#def right-cancel-concat\n( p q : x = y)\n( r : y = z)\n  : ((concat A x y z p r) = (concat A x y z q r)) \u2192 (p = q)\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' r' \u2192 ((concat A x y z' p r') = (concat A x y z' q r')) \u2192 (p = q))\n      ( \\ H \u2192 H)\n      ( z)\n      ( r)\n#end basic-path-coherence\n</code></pre>"},{"location":"hott/01-paths.rzk/#some-derived-coherences-in-path-algebra","title":"Some derived coherences in path algebra","text":"<p>The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above.</p> <pre><code>#section derived-path-coherence\n#variable A : U\n#variables x y z : A\n#def rev-concat\n( p : x = y)\n( q : y = z)\n  : ( rev A x z (concat A x y z p q)) =\n    ( concat A z y x (rev A y z q) (rev A x y p))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' q' \u2192\n          (rev A x z' (concat A x y z' p q')) =\n          (concat A z' y x (rev A y z' q') (rev A x y p)))\n      ( rev\n          ( y = x)\n          ( concat A y y x refl (rev A x y p))\n          ( rev A x y p)\n          ( left-unit-concat A y x (rev A x y p)))\n      ( z)\n      ( q)\n</code></pre>"},{"location":"hott/01-paths.rzk/#postwhiskering-paths-of-paths","title":"Postwhiskering paths of paths","text":"<pre><code>#def concat-eq-left\n( p q : x = y)\n( H : p = q)\n( r : y = z)\n  : (concat A x y z p r) = (concat A x y z q r)\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' r' \u2192 (concat A x y z' p r') = (concat A x y z' q r'))\n      ( H)\n      ( z)\n      ( r)\n</code></pre>"},{"location":"hott/01-paths.rzk/#prewhiskering-paths-of-paths","title":"Prewhiskering paths of paths","text":"<p>Prewhiskering paths of paths is much harder.</p> <pre><code>#def concat-eq-right\n( p : x = y)\n  : ( q : y = z) \u2192\n( r : y = z) \u2192\n( H : q = r) \u2192\n    ( concat A x y z p q) = (concat A x y z p r)\n  :=\n    ind-path\n      ( A)\n      ( x)\n( \\ y' p' \u2192\n        ( q : y' = z) \u2192\n( r : y' = z) \u2192\n( H : q = r) \u2192\n        ( concat A x y' z p' q) = (concat A x y' z p' r))\n      ( \\ q r H \u2192\n        concat\n          ( x = z)\n          ( concat A x x z refl q)\n          ( r)\n          ( concat A x x z refl r)\n          ( concat (x = z) (concat A x x z refl q) q r (left-unit-concat A x z q) H)\n          ( rev (x = z) (concat A x x z refl r) r (left-unit-concat A x z r)))\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#identifying-the-two-definitions-of-path-concatenation","title":"Identifying the two definitions of path concatenation","text":"<pre><code>#def concat-concat'\n( p : x = y)\n  : ( q : y = z) \u2192\n    ( concat A x y z p q) = (concat' A x y z p q)\n  :=\n    ind-path\n      ( A)\n      ( x)\n( \\ y' p' \u2192\n          (q' : y' =_{A} z) \u2192\n          (concat A x y' z p' q') =_{x =_{A} z} concat' A x y' z p' q')\n      ( \\ q' \u2192 left-unit-concat A x z q')\n      ( y)\n      ( p)\n#def concat'-concat\n( p : x = y)\n( q : y = z)\n  : concat' A x y z p q = concat A x y z p q\n  :=\n    rev\n      ( x = z)\n      ( concat A x y z p q)\n      ( concat' A x y z p q)\n      ( concat-concat' p q)\n</code></pre> <p>This is easier to prove for <code>concat'</code> than for <code>concat</code>.</p> <pre><code>#def alt-triangle-rotation\n( p : x = z)\n( q : x = y)\n  : ( r : y = z) \u2192\n( H : p = concat' A x y z q r) \u2192\n    ( concat' A y x z (rev A x y q) p) = r\n  :=\n    ind-path\n      ( A)\n      ( x)\n( \\ y' q' \u2192\n        ( r' : y' =_{A} z) \u2192\n( H' : p = concat' A x y' z q' r') \u2192\n        ( concat' A y' x z (rev A x y' q') p) = r')\n      ( \\ r' H' \u2192 H')\n      ( y)\n      ( q)\n</code></pre> <p>The following needs to be outside the previous section because of the usage of <code>concat-concat' A y x</code>.</p> <pre><code>#end derived-path-coherence\n#def triangle-rotation\n( A : U)\n( x y z : A)\n( p : x = z)\n( q : x = y)\n( r : y = z)\n( H : p = concat A x y z q r)\n  : (concat A y x z (rev A x y q) p) = r\n  :=\n    concat\n      ( y = z)\n      ( concat A y x z (rev A x y q) p)\n      ( concat' A y x z (rev A x y q) p)\n      ( r)\n      ( concat-concat' A y x z (rev A x y q) p)\n      ( alt-triangle-rotation\n        ( A) (x) (y) (z) (p) (q) (r)\n        ( concat\n          ( x = z)\n          ( p)\n          ( concat A x y z q r)\n          ( concat' A x y z q r)\n          ( H)\n          ( concat-concat' A x y z q r)))\n</code></pre> <p>A special case of this is sometimes useful</p> <pre><code>#def cancel-left-path\n(A : U)\n(x y : A)\n(p q : x = y)\n  : (p = q) \u2192 ( concat A y x y (rev A x y q) p) = refl\n  := triangle-rotation A x y y p q refl\n</code></pre>"},{"location":"hott/01-paths.rzk/#concatenation-with-a-path-and-its-reversal","title":"Concatenation with a path and its reversal","text":"<pre><code>#def retraction-preconcat\n( A : U)\n( x y z : A)\n( p : x = y)\n( q : y = z)\n  : concat A y x z (rev A x y p) (concat A x y z p q) = q\n  :=\n    ind-path (A) (y)\n    ( \\ z' q' \u2192 concat A y x z' (rev A x y p) (concat A x y z' p q') = q') (left-inverse-concat A x y p) (z) (q)\n#def section-preconcat\n( A : U)\n( x y z : A)\n( p : x = y)\n( r : x = z)\n  : concat A x y z p (concat A y x z (rev A x y p) r) = r\n  :=\n    ind-path (A) (x)\n    ( \\ z' r' \u2192 concat A x y z' p (concat A y x z' (rev A x y p) r') = r') (right-inverse-concat A x y p) (z) (r)\n#def retraction-postconcat\n( A : U)\n( x y z : A)\n( q : y = z)\n( p : x = y)\n  : concat A x z y (concat A x y z p q) (rev A y z q) = p\n  :=\n    ind-path (A) (y)\n    ( \\ z' q' \u2192 concat A x z' y (concat A x y z' p q') (rev A y z' q') = p)\n    ( refl) (z) (q)\n#def section-postconcat\n( A : U)\n( x y z : A)\n( q : y = z)\n( r : x = z)\n  : concat A x y z (concat A x z y r (rev A y z q)) q = r\n  :=\n    concat\n      ( x = z)\n      ( concat A x y z (concat A x z y r (rev A y z q)) q)\n      ( concat A x z z r (concat A z y z (rev A y z q) q))\n      ( r)\n      ( associative-concat A x z y z r (rev A y z q) q)\n      ( concat-eq-right A x z z r\n        ( concat A z y z (rev A y z q) q)\n        ( refl)\n        ( left-inverse-concat A y z q))\n</code></pre>"},{"location":"hott/01-paths.rzk/#application-of-functions-to-paths","title":"Application of functions to paths","text":"<pre><code>#def ap\n( A B : U)\n( x y : A)\n( f : A \u2192 B)\n( p : x = y)\n  : (f x = f y)\n  := ind-path (A) (x) (\\ y' p' \u2192 (f x = f y')) (refl) (y) (p)\n#def ap-rev\n( A B : U)\n( x y : A)\n( f : A \u2192 B)\n( p : x = y)\n  : (ap A B y x f (rev A x y p)) = (rev B (f x) (f y) (ap A B x y f p))\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ap A B y' x f (rev A x y' p') = rev B (f x) (f y') (ap A B x y' f p'))\n      ( refl)\n      ( y)\n      ( p)\n#def ap-concat\n( A B : U)\n( x y z : A)\n( f : A \u2192 B)\n( p : x = y)\n( q : y = z)\n  : ( ap A B x z f (concat A x y z p q)) =\n    ( concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' q' \u2192\n        ( ap A B x z' f (concat A x y z' p q')) =\n        ( concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q')))\n      ( refl)\n      ( z)\n      ( q)\n#def rev-ap-rev\n( A B : U)\n( x y : A)\n( f : A \u2192 B)\n( p : x = y)\n  : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) =\n        (ap A B x y' f p'))\n      ( refl)\n      ( y)\n      ( p)\n</code></pre> <p>The following is for a specific use.</p> <pre><code>#def concat-ap-rev-ap-id\n( A B : U)\n( x y : A)\n( f : A \u2192 B)\n( p : x = y)\n  : ( concat\n      ( B) (f y) (f x) (f y)\n      ( ap A B y x f (rev A x y p))\n      ( ap A B x y f p)) =\n    ( refl)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( concat\n          ( B) (f y') (f x) (f y')\n          ( ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) =\n        ( refl))\n      ( refl)\n      ( y)\n      ( p)\n#def ap-id\n( A : U)\n( x y : A)\n( p : x = y)\n  : (ap A A x y (identity A) p) = p\n  := ind-path (A) (x) (\\ y' p' \u2192 (ap A A x y' (\\ z \u2192 z) p') = p') (refl) (y) (p)\n</code></pre> <p>Application of a function to homotopic paths yields homotopic paths.</p> <pre><code>#def ap-eq\n( A B : U)\n( x y : A)\n( f : A \u2192 B)\n( p q : x = y)\n( H : p = q)\n  : (ap A B x y f p) = (ap A B x y f q)\n  :=\n    ind-path\n      ( x = y)\n      ( p)\n      ( \\ q' H' \u2192 (ap A B x y f p) = (ap A B x y f q'))\n      ( refl)\n      ( q)\n      ( H)\n#def ap-comp\n( A B C : U)\n( x y : A)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( p : x = y)\n  : ( ap A C x y (comp A B C g f) p) =\n    ( ap B C (f x) (f y) g (ap A B x y f p))\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( ap A C x y' (\\ z \u2192 g (f z)) p') =\n        ( ap B C (f x) (f y') g (ap A B x y' f p')))\n      ( refl)\n      ( y)\n      ( p)\n#def rev-ap-comp\n( A B C : U)\n( x y : A)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( p : x = y)\n  : ( ap B C (f x) (f y) g (ap A B x y f p)) =\n    ( ap A C x y (comp A B C g f) p)\n  :=\n    rev\n      ( g (f x) = g (f y))\n      ( ap A C x y (\\ z \u2192 g (f z)) p)\n      ( ap B C (f x) (f y) g (ap A B x y f p))\n      ( ap-comp A B C x y f g p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport","title":"Transport","text":"<pre><code>#section transport\n#variable A : U\n#variable B : A \u2192 U\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-in-a-type-family-along-a-path-in-the-base","title":"Transport in a type family along a path in the base","text":"<pre><code>#def transport\n( x y : A)\n( p : x = y)\n( u : B x)\n  : B y\n  := ind-path (A) (x) (\\ y' p' \u2192 B y') (u) (y) (p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#the-lift-of-a-base-path-to-a-path-from-a-term-in-the-total-space-to-its-transport","title":"The lift of a base path to a path from a term in the total space to its transport","text":"<pre><code>#def transport-lift\n( x y : A)\n( p : x = y)\n( u : B x)\n  : (x , u) =_{\u03a3 (z : A) , B z} (y , transport x y p u)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 (x , u) =_{\u03a3 (z : A) , B z} (y' , transport x y' p' u))\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-along-concatenated-paths","title":"Transport along concatenated paths","text":"<pre><code>#def transport-concat\n( x y z : A)\n( p : x = y)\n( q : y = z)\n( u : B x)\n  : ( transport x z (concat A x y z p q) u) =\n    ( transport y z q (transport x y p u))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' q' \u2192\n        ( transport x z' (concat A x y z' p q') u) =\n        ( transport y z' q' (transport x y p u)))\n      ( refl)\n      ( z)\n      ( q)\n#def transport-concat-rev\n( x y z : A)\n( p : x = y)\n( q : y = z)\n( u : B x)\n  : ( transport y z q (transport x y p u)) =\n    ( transport x z (concat A x y z p q) u)\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' q' \u2192\n        ( transport y z' q' (transport x y p u)) =\n        ( transport x z' (concat A x y z' p q') u))\n      ( refl)\n      ( z)\n      ( q)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-along-homotopic-paths","title":"Transport along homotopic paths","text":"<pre><code>#def transport2\n( x y : A)\n( p q : x = y)\n( H : p = q)\n( u : B x)\n  : (transport x y p u) = (transport x y q u)\n  :=\n    ind-path\n      ( x = y)\n      ( p)\n      ( \\ q' H' \u2192 (transport x y p u) = (transport x y q' u))\n      ( refl)\n      ( q)\n      ( H)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-along-a-loop","title":"Transport along a loop","text":"<pre><code>#def transport-loop\n( a : A)\n( b : B a)\n  : (a = a) \u2192 B a\n  := \\ p \u2192 (transport a a p b)\n</code></pre> <pre><code>#end transport\n</code></pre>"},{"location":"hott/01-paths.rzk/#substitution-law-for-transport","title":"Substitution law for transport","text":"<pre><code>#def transport-substitution\n( A' A : U)\n( B : A \u2192 U)\n( f : A' \u2192 A)\n( x y : A')\n( p : x = y)\n( u : B (f x))\n  : transport A' (\\ x \u2192 B (f x)) x y p u =\n    transport A B (f x) (f y) (ap A' A x y f p) u\n  :=\n    ind-path\n      ( A')\n      ( x)\n      ( \\ y' p' \u2192\n        transport A' (\\ x \u2192 B (f x)) x y' p' u =\n        transport A B (f x) (f y') (ap A' A x y' f p') u)\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-induction_1","title":"Path induction","text":"<p>Using <code>rev</code> we can deduce a path induction principle with fixed end point.</p> <pre><code>#def ind-path-end\n( A : U)\n( a : A)\n( C : (x : A) \u2192 (x = a) -&gt; U)\n( d : C a refl)\n( x : A)\n( p : x = a)\n  : C x p\n  :=\n    transport (x = a) (\\ q \u2192 C x q) (rev A a x (rev A x a p)) p\n      (rev-rev A x a p)\n      (ind-path A a (\\ y q \u2192 C y (rev A a y q)) d x (rev A x a p))\n</code></pre>"},{"location":"hott/01-paths.rzk/#dependent-application","title":"Dependent application","text":"<pre><code>#def apd\n( A : U)\n( B : A \u2192 U)\n( x y : A)\n( f : (z : A) \u2192 B z)\n( p : x = y)\n  : (transport A B x y p (f x)) = f y\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( (\\ y' p' \u2192 (transport A B x y' p' (f x)) = f y'))\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#higher-order-concatenation","title":"Higher-order concatenation","text":"<p>For convenience, we record lemmas for higher-order concatenation here.</p> <pre><code>#section higher-concatenation\n#variable A : U\n#def triple-concat\n( a0 a1 a2 a3 : A)\n( p1 : a0 = a1)\n( p2 : a1 = a2)\n( p3 : a2 = a3)\n  : a0 = a3\n  := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3)\n#def quadruple-concat\n( a0 a1 a2 a3 a4 : A)\n( p1 : a0 = a1)\n( p2 : a1 = a2)\n( p3 : a2 = a3)\n( p4 : a3 = a4)\n  : a0 = a4\n  := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4)\n#def quintuple-concat\n( a0 a1 a2 a3 a4 a5 : A)\n( p1 : a0 = a1)\n( p2 : a1 = a2)\n( p3 : a2 = a3)\n( p4 : a3 = a4)\n( p5 : a4 = a5)\n  : a0 = a5\n  := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5)\n#def alternating-quintuple-concat\n( a0 : A)\n( a1 : A) (p1 : a0 = a1)\n( a2 : A) (p2 : a1 = a2)\n( a3 : A) (p3 : a2 = a3)\n( a4 : A) (p4 : a3 = a4)\n( a5 : A) (p5 : a4 = a5)\n  : a0 = a5\n  := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5)\n#def 12ary-concat\n( a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A)\n( p1 : a0 = a1)\n( p2 : a1 = a2)\n( p3 : a2 = a3)\n( p4 : a3 = a4)\n( p5 : a4 = a5)\n( p6 : a5 = a6)\n( p7 : a6 = a7)\n( p8 : a7 = a8)\n( p9 : a8 = a9)\n( p10 : a9 = a10)\n( p11 : a10 = a11)\n( p12 : a11 = a12)\n  : a0 = a12\n  :=\n    quintuple-concat\n      a0 a1 a2 a3 a4 a12\n      p1 p2 p3 p4\n      ( quintuple-concat\n        a4 a5 a6 a7 a8 a12\n        p5 p6 p7 p8\n        ( quadruple-concat\n          a8 a9 a10 a11 a12\n          p9 p10 p11 p12))\n</code></pre> <p>The following is the same as above but with alternating arguments.</p> <pre><code>#def alternating-12ary-concat\n( a0 : A)\n( a1 : A) (p1 : a0 = a1)\n( a2 : A) (p2 : a1 = a2)\n( a3 : A) (p3 : a2 = a3)\n( a4 : A) (p4 : a3 = a4)\n( a5 : A) (p5 : a4 = a5)\n( a6 : A) (p6 : a5 = a6)\n( a7 : A) (p7 : a6 = a7)\n( a8 : A) (p8 : a7 = a8)\n( a9 : A) (p9 : a8 = a9)\n( a10 : A) (p10 : a9 = a10)\n( a11 : A) (p11 : a10 = a11)\n( a12 : A) (p12 : a11 = a12)\n  : a0 = a12\n  :=\n    12ary-concat\n      a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12\n      p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12\n#end higher-concatenation\n</code></pre>"},{"location":"hott/01-paths.rzk/#higher-order-coherences","title":"Higher-order coherences","text":"<pre><code>#def rev-refl-id-triple-concat\n( A : U)\n( x y : A)\n( p : x = y)\n  : triple-concat A y x x y (rev A x y p) refl p = refl\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 triple-concat A y' x x y' (rev A x y' p') refl p' = refl)\n      ( refl)\n      ( y)\n      ( p)\n#def ap-rev-refl-id-triple-concat\n( A B : U)\n( x y : A)\n( f : A \u2192 B)\n( p : x = y)\n  : (ap A B y y f (triple-concat A y x x y (rev A x y p) refl p)) = refl\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( ap A B y' y' f (triple-concat A y' x x y' (rev A x y' p') refl p')) =\n        ( refl))\n      ( refl)\n      ( y)\n      ( p)\n#def ap-triple-concat\n( A B : U)\n( w x y z : A)\n( f : A \u2192 B)\n( p : w = x)\n( q : x = y)\n( r : y = z)\n  : ( ap A B w z f (triple-concat A w x y z p q r)) =\n    ( triple-concat\n      ( B)\n      ( f w)\n      ( f x)\n      ( f y)\n      ( f z)\n      ( ap A B w x f p)\n      ( ap A B x y f q)\n      ( ap A B y z f r))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' r' \u2192\n        ( ap A B w z' f (triple-concat A w x y z' p q r')) =\n        ( triple-concat\n          ( B)\n          ( f w) (f x) (f y) (f z')\n          ( ap A B w x f p)\n          ( ap A B x y f q)\n          ( ap A B y z' f r')))\n      ( ap-concat A B w x y f p q)\n      ( z)\n      ( r)\n#def triple-concat-eq-first\n( A : U)\n( w x y z : A)\n( p q : w = x)\n( r : x = y)\n( s : y = z)\n( H : p = q)\n  : (triple-concat A w x y z p r s) = (triple-concat A w x y z q r s)\n  := concat-eq-left A w x z p q H (concat A x y z r s)\n#def triple-concat-eq-second\n( A : U)\n( w x y z : A)\n( p : w = x)\n( q r : x = y)\n( s : y = z)\n( H : q = r)\n  : (triple-concat A w x y z p q s) = (triple-concat A w x y z p r s)\n  :=\n    ind-path\n      ( x = y)\n      ( q)\n      ( \\ r' H' \u2192\n        triple-concat A w x y z p q s = triple-concat A w x y z p r' s)\n      ( refl)\n      ( r)\n      ( H)\n</code></pre> <p>The function below represents a somewhat special situation, which nevertheless arises when dealing with certain naturality diagrams. One has a commutative square and a path that cancels that top path. Then the type below witnesses the equivalence between the right side of the square (in blue) and a particular zig-zag of paths, the red zig-zag. We choose the assocativity order for the triple compostion for ease of use in a later proof.</p> <p> </p> <pre><code>#def eq-top-cancel-commutative-square\n(A : U)\n(v w y z : A)\n(p : v = w)\n(q : w = v)\n(s : w = y)\n(r : v = z)\n(t : y = z)\n(H : (concat A w v z q r) = (concat A w y z s t))\n(H' : (concat A v w v p q) = refl)\n  : r = (concat A v w z p (concat A w y z s t))\n  :=\n  (concat\n    (v = z)\n    ( r)\n    ( concat A v v z refl r)\n    ( concat A v w z p (concat A w y z s t))\n    (rev\n      (v = z)\n      (concat  A v v z refl r)\n      ( r )\n      (left-unit-concat A v z r))\n    (concat\n      ( v = z)\n      ( concat A v v z refl r)\n      ( concat A v v z (concat A v w v p q) r)\n      ( concat A v w z p (concat A w y z s t ))\n      (rev\n        ( v = z )\n        (concat A v v z  (concat A v w v p q) r)\n        (concat A v v z refl r)\n        ( concat-eq-left\n          ( A)\n          ( v)\n          ( v)\n          ( z)\n          ( concat A v w v p q)\n          ( refl )\n          ( H')\n          ( r) ))\n      ( concat\n        ( v = z)\n        ( concat A v v z (concat A v w v p q) r)\n        ( concat A v w z p (concat A w v z q r))\n        ( concat A v w z p (concat A w y z s t))\n        ( associative-concat A v w v z p q r)\n        ( concat-eq-right\n          ( A)\n          ( v)\n          ( w)\n          ( z)\n          ( p)\n          ( concat A w v z q r)\n          ( concat A w y z s t)\n          ( H)))))\n</code></pre> <p>It is also convenient to have a a version with the opposite associativity.</p> <pre><code>#def eq-top-cancel-commutative-square'\n( A : U)\n( v w y z : A)\n( p : v = w)\n( q : w = v)\n( s : w = y)\n( r : v = z)\n( t : y = z)\n( H : (concat A w v z q r) = (concat A w y z s t))\n( H' : (concat A v w v p q) = refl)\n  : r = ( concat A v y z (concat A v w y p s) t)\n  :=\n  concat\n  ( v = z)\n  ( r)\n  ( concat A v w z p (concat A w y z s t))\n  ( concat A v y z (concat A v w y p s) t)\n  ( eq-top-cancel-commutative-square A v w y z p q s r t H H')\n  ( rev-associative-concat A v w y z p s t)\n</code></pre> <p>And a reversed version.</p> <pre><code>#def rev-eq-top-cancel-commutative-square'\n( A : U)\n( v w y z : A)\n( p : v = w)\n( q : w = v)\n( s : w = y)\n( r : v = z)\n( t : y = z)\n( H : (concat A w v z q r) = (concat A w y z s t))\n( H' : (concat A v w v p q) = refl)\n  : ( concat A v y z (concat A v w y p s) t) = r\n  :=\n  rev\n  ( v = z)\n  ( r)\n  ( concat A v y z (concat A v w y p s) t)\n  ( eq-top-cancel-commutative-square' A v w y z p q s r t H H')\n</code></pre> <p> </p> <p>Given a homotopy between paths <code>H : p = q</code>, then we can cancel on the left to get a homotopy between <code>concat (rev p) q</code> and <code>refl</code>.</p> <pre><code>#def htpy-id-cancel-left-concat-left-eq\n(A : U)\n(a b : A)\n(p : a = b)\n(q : a = b)\n(H : p = q)\n(r : b = a)\n(H' : (concat A a b a q r) = refl)\n  : (concat A a b a p r) = refl\n  :=\n  concat\n  ( a = a)\n  ( concat A a b a p r )\n  ( concat A a b a q r )\n  ( refl )\n  ( concat-eq-left A a b a p q H r)\n  ( H' )\n</code></pre>"},{"location":"hott/02-homotopies.rzk/","title":"2. Homotopies","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#homotopies-and-their-algebra","title":"Homotopies and their algebra","text":"<pre><code>#section homotopies\n#variables A B : U\n</code></pre> The type of homotopies between parallel functions<pre><code>#def homotopy\n( f g : A \u2192 B)\n  : U\n  := ( a : A) \u2192 (f a = g a)\n</code></pre> The reversal of a homotopy<pre><code>#def rev-homotopy\n( f g : A \u2192 B)\n( H : homotopy f g)\n  : homotopy g f\n  := \\ a \u2192 rev B (f a) (g a) (H a)\n</code></pre> <pre><code>#def concat-homotopy\n( f g h : A \u2192 B)\n( H : homotopy f g)\n( K : homotopy g h)\n  : homotopy f h\n  := \\ a \u2192 concat B (f a) (g a) (h a) (H a) (K a)\n</code></pre> <p>Homotopy composition is defined in diagrammatic order like <code>concat</code> but unlike composition.</p> <p>The following is the unit for compositions of homotopies.</p> <pre><code>#def refl-htpy\n(f : A \u2192 B)\n  : homotopy f f\n  := \\ x \u2192 refl\n</code></pre> <pre><code>#end homotopies\n</code></pre> <p>There is also a dependent version of homotopy.</p> <pre><code>#def dhomotopy\n( A : U)\n( B : A \u2192 U)\n(f g : (a : A) \u2192 B a)\n  : U\n  := (a : A) \u2192 (f a = g a)\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#some-path-algebra-for-homotopies","title":"Some path algebra for homotopies","text":"<p>In this section we prove some lemmas on the groupoidal structure of homotopies.</p> <p>Given a homotopy between two homotopies \\(C : H \\sim K\\) this produces a homotopy \\(K^{-1} \\cdot H  \\sim \\text{refl-htpy}_{g}\\)</p> <pre><code>#def htpy-cancel-left\n(A B : U)\n(f g : A \u2192 B)\n(H K : homotopy A B f g)\n(C : dhomotopy A (\\ a \u2192 f a = g a) H K)\n  : dhomotopy\n    A\n    (\\ b \u2192 g b = g b)\n    (\\ x \u2192 concat B (g x) (f x) (g x) (rev B (f x) (g x) (K x)) (H x))\n    (refl-htpy A B g)\n  := \\ x \u2192\n      cancel-left-path B (f x) (g x) (H x) (K x) (C x)\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#whiskering-homotopies","title":"Whiskering homotopies","text":"<pre><code>#section homotopy-whiskering\n#variables A B C : U\n#def postwhisker-homotopy\n( f g : A \u2192 B)\n( H : homotopy A B f g)\n( h : B \u2192 C)\n  : homotopy A C (comp A B C h f) (comp A B C h g)\n  := \\ a \u2192 ap B C (f a) (g a) h (H a)\n#def prewhisker-homotopy\n( f g : B \u2192 C)\n( H : homotopy B C f g)\n( h : A \u2192 B)\n  : homotopy A C (comp A B C f h) (comp A B C g h)\n  := \\ a \u2192 H (h a)\n#end homotopy-whiskering\n#def whisker-homotopy\n( A B C D : U)\n( h k : B \u2192 C)\n( H : homotopy B C h k)\n( f : A \u2192 B)\n( g : C \u2192 D)\n  : homotopy\n      A\n      D\n      (triple-comp A B C D g h f)\n      (triple-comp A B C D g k f)\n  :=\n    postwhisker-homotopy\n      A\n      C\n      D\n      ( comp A B C h f)\n      ( comp A B C k f)\n      ( prewhisker-homotopy A B C h k H f)\n      g\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#naturality","title":"Naturality","text":"The naturality square associated to a homotopy and a path<pre><code>#def nat-htpy\n( A B : U)\n( f g : A \u2192 B)\n( H : homotopy A B f g)\n( x y : A)\n( p : x = y)\n  : ( concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) =\n    ( concat B (f x) (g x) (g y) (H x) (ap A B x y g p))\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) =\n        ( concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')))\n      ( left-unit-concat B (f x) (g x) (H x))\n      ( y)\n      ( p)\n</code></pre> <p>It is sometimes useful to have this in inverse form.</p> <pre><code>#def rev-nat-htpy\n( A B : U)\n( f g : A \u2192 B)\n( H : homotopy A B f g)\n( x y : A)\n( p : x = y)\n  : ( concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) =\n    ( concat B (f x) (f y) (g y) (ap A B x y f p) (H y))\n  :=\n  rev\n  ( f x = g y)\n  ( concat B (f x) (f y) (g y) (ap A B x y f p) (H y))\n  ( concat B (f x) (g x) (g y) (H x) (ap A B x y g p))\n  ( nat-htpy A B f g H x y p)\n</code></pre> Naturality in another form<pre><code>#def triple-concat-nat-htpy\n( A B : U)\n( f g : A \u2192 B)\n( H : homotopy A B f g)\n( x y : A)\n( p : x = y)\n  : triple-concat\n      ( B) (g x) (f x) (f y) (g y)\n      ( rev B (f x) (g x) (H x)) (ap A B x y f p) (H y) =\n    ap A B x y g p\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n          triple-concat\n            ( B)\n            ( g x)\n            ( f x)\n            ( f y')\n            ( g y')\n            ( rev B (f x) (g x) (H x))\n            ( ap A B x y' f p')\n            ( H y') =\n          ap A B x y' g p')\n      ( rev-refl-id-triple-concat B (f x) (g x) (H x))\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#an-application","title":"An application","text":"<pre><code>#section cocone-naturality\n#variable A : U\n#variable f : A \u2192 A\n#variable H : homotopy A A f (identity A)\n#variable a : A\n</code></pre> <p>In the case of a homotopy <code>H</code> from <code>f</code> to the identity the previous square applies to the path <code>H a</code> to produce the following naturality square.</p> <pre><code>#def cocone-naturality\n  : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) =\n    ( concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a)))\n  := nat-htpy A A f (identity A) H (f a) a (H a)\n</code></pre> <p>After composing with <code>ap-id</code>, this naturality square transforms to the following:</p> <pre><code>#def reduced-cocone-naturality\n  : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) =\n    ( concat A (f (f a)) (f a) (a) (H (f a)) (H a))\n  :=\n    concat\n      ( (f (f a)) = a)\n      ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a))\n      ( concat\n        ( A)\n        ( f (f a))\n        ( f a)\n        ( a)\n        ( H (f a))\n        ( ap A A (f a) a (identity A) (H a)))\n      ( concat A (f (f a)) (f a) (a) (H (f a)) (H a))\n      ( cocone-naturality)\n      ( concat-eq-right\n        ( A)\n        ( f (f a))\n        ( f a)\n        ( a)\n        ( H (f a))\n        ( ap A A (f a) a (identity A) (H a))\n        ( H a)\n        ( ap-id A (f a) a (H a)))\n</code></pre> <p>Cancelling the path <code>H a</code> on the right and reversing yields a path we need:</p> <pre><code>#def cocone-naturality-coherence\n  : (H (f a)) = (ap A A (f a) a f (H a))\n  :=\n    rev\n      ( f (f a) = f a)\n      ( ap A A (f a) a f (H a)) (H (f a))\n      ( right-cancel-concat\n        ( A)\n        ( f (f a))\n        ( f a)\n        ( a)\n        ( ap A A (f a) a f (H a))\n        ( H (f a))\n        ( H a)\n        ( reduced-cocone-naturality))\n#end cocone-naturality\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#conjugation-with-higher-homotopies","title":"Conjugation with higher homotopies","text":"<pre><code>#def triple-concat-higher-homotopy\n( A B : U)\n( f g : A \u2192 B)\n( H K : homotopy A B f g)\n( \u03b1 : (a : A) \u2192 H a = K a)\n( x y : A)\n( p : f x = f y)\n  : triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (H x)) p (H y) =\n    triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (K x)) p (K y)\n  :=\n    ind-path\n      ( f y = g y)\n      ( H y)\n      ( \\ Ky \u03b1' \u2192\n        ( triple-concat\n          ( B) (g x) (f x) (f y) (g y)\n          ( rev B (f x) (g x) (H x)) (p) (H y)) =\n        ( triple-concat\n          ( B) (g x) (f x) (f y) (g y)\n          ( rev B (f x) (g x) (K x)) (p) (Ky)))\n      ( triple-concat-eq-first\n        ( B) (g x) (f x) (f y) (g y)\n        ( rev B (f x) (g x) (H x))\n        ( rev B (f x) (g x) (K x))\n        ( p)\n        ( H y)\n        ( ap\n          ( f x = g x)\n          ( g x = f x)\n          ( H x)\n          ( K x)\n          ( rev B (f x) (g x))\n          ( \u03b1 x)))\n      ( K y)\n      (\u03b1 y)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/","title":"3. Equivalences","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#sections-retractions-and-equivalences","title":"Sections, retractions, and equivalences","text":"<pre><code>#section is-equiv\n#variables A B : U\n#def has-section\n( f : A \u2192 B)\n  : U\n  := \u03a3 (s : B \u2192 A) , (homotopy B B (comp B A B f s) (identity B))\n#def has-retraction\n( f : A \u2192 B)\n  : U\n  := \u03a3 (r : B \u2192 A) , (homotopy A A (comp A B A r f) (identity A))\n</code></pre> <p>We define equivalences to be bi-invertible maps.</p> <pre><code>#def is-equiv\n( f : A \u2192 B)\n  : U\n  := product (has-retraction f) (has-section f)\n#end is-equiv\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#the-identity-is-an-equivalence","title":"The identity is an equivalence","text":"<pre><code>#def is-equiv-identity\n( A : U)\n  : is-equiv A A (\\ a \u2192 a)\n  :=\n    ( (\\ a \u2192 a , \\ _ \u2192 refl) , (\\ a \u2192 a , \\ _ \u2192 refl))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalence-data","title":"Equivalence data","text":"<pre><code>#section equivalence-data\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-equiv-f : is-equiv A B f\n#def section-is-equiv uses (f)\n  : B \u2192 A\n  := first (second is-equiv-f)\n#def has-section-is-equiv\n  : has-section A B f\n  := second is-equiv-f\n#def retraction-is-equiv uses (f)\n  : B \u2192 A\n  := first (first is-equiv-f)\n#def has-retraction-is-equiv\n  : has-retraction A B f\n  := first is-equiv-f\n</code></pre> The homotopy between the section and retraction of an equivalence<pre><code>#def homotopy-section-retraction-is-equiv uses (f)\n  : homotopy B A section-is-equiv retraction-is-equiv\n  :=\n    concat-homotopy B A\n      ( section-is-equiv)\n      ( triple-comp B A B A retraction-is-equiv f section-is-equiv)\n      ( retraction-is-equiv)\n      ( rev-homotopy B A\n        ( triple-comp B A B A retraction-is-equiv f section-is-equiv)\n        ( section-is-equiv)\n        ( prewhisker-homotopy B A A\n          ( comp A B A retraction-is-equiv f)\n          ( identity A)\n          ( second (first is-equiv-f))\n          ( section-is-equiv)))\n      ( postwhisker-homotopy B B A\n        ( comp B A B f section-is-equiv)\n        ( identity B)\n        ( second (second is-equiv-f))\n        ( retraction-is-equiv))\n#end equivalence-data\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#invertible-maps","title":"Invertible maps","text":"<p>The following type of more coherent equivalences is not a proposition.</p> <pre><code>#def has-inverse\n( A B : U)\n( f : A \u2192 B)\n  : U\n  :=\n\u03a3 ( g : B \u2192 A) ,\n      ( product\n        ( homotopy A A (comp A B A g f) (identity A))\n        ( homotopy B B (comp B A B f g) (identity B)))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalences-are-invertible-maps","title":"Equivalences are invertible maps","text":"Invertible maps are equivalences<pre><code>#def is-equiv-has-inverse\n( A B : U)\n( f : A \u2192 B)\n( has-inverse-f : has-inverse A B f)\n  : is-equiv A B f\n  :=\n    ( ( first has-inverse-f , first (second has-inverse-f)) ,\n      ( first has-inverse-f , second (second has-inverse-f)))\n</code></pre> Equivalences are invertible<pre><code>#def has-inverse-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : has-inverse A B f\n  :=\n    ( section-is-equiv A B f is-equiv-f ,\n      ( concat-homotopy A A\n        ( comp A B A (section-is-equiv A B f is-equiv-f) f)\n        ( comp A B A (retraction-is-equiv A B f is-equiv-f) f)\n        ( identity A)\n        ( prewhisker-homotopy A B A\n          ( section-is-equiv A B f is-equiv-f)\n          ( retraction-is-equiv A B f is-equiv-f)\n          ( homotopy-section-retraction-is-equiv A B f is-equiv-f)\n          ( f))\n        ( second (first is-equiv-f)) ,\n      ( second (second is-equiv-f))))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#invertible-map-data","title":"Invertible map data","text":"<pre><code>#section has-inverse-data\n#variables A B : U\n#variable f : A \u2192 B\n#variable has-inverse-f : has-inverse A B f\n</code></pre> The inverse of a map with an inverse<pre><code>#def map-inverse-has-inverse uses (f)\n  : B \u2192 A\n  := first (has-inverse-f)\n</code></pre> <p>The following are some iterated composites associated to a pair of invertible maps.</p> <pre><code>#def retraction-composite-has-inverse uses (B has-inverse-f)\n  : A \u2192 A\n  := comp A B A map-inverse-has-inverse f\n#def section-composite-has-inverse uses (A has-inverse-f)\n  : B \u2192 B\n  := comp B A B f map-inverse-has-inverse\n</code></pre> <p>This composite is parallel to <code>f</code>; we won't need the dual notion.</p> <pre><code>#def triple-composite-has-inverse uses (has-inverse-f)\n  : A \u2192 B\n  := triple-comp A B A B f map-inverse-has-inverse f\n</code></pre> <p>This composite is also parallel to <code>f</code>; again we won't need the dual notion.</p> <pre><code>#def quintuple-composite-has-inverse uses (has-inverse-f)\n  : A \u2192 B\n  := \\ a \u2192 f (map-inverse-has-inverse (f (map-inverse-has-inverse (f a))))\n#end has-inverse-data\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#symmetry-of-having-an-inverse","title":"Symmetry of having an inverse","text":"<p>The inverse of an invertible map has an inverse.</p> <pre><code>#def has-inverse-map-inverse-has-inverse\n( A B : U)\n( f : A \u2192 B)\n( has-inverse-f : has-inverse A B f)\n  : has-inverse B A ( map-inverse-has-inverse A B f has-inverse-f)\n  :=\n    ( f,\n      ( second ( second has-inverse-f) ,\nfirst ( second has-inverse-f)))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#the-type-of-equivalences","title":"The type of equivalences","text":"<p>The type of equivalences between types uses <code>is-equiv</code> rather than <code>has-inverse</code>.</p> <pre><code>#def Equiv\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B) , (is-equiv A B f)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#induction-with-section","title":"Induction with section","text":"<p>We have two variants of induction with section that say that if <code>f : A \u2192 B</code> has a section, it suffices to prove statements about <code>b : B</code> by doing so terms of the form <code>f a</code>.</p> <pre><code>#def ind-has-section\n( A B : U)\n( f : A \u2192 B)\n  ( ( sec-f , \u03b5-f) : has-section A B f)\n( C : B \u2192 U)\n( s : (a : A) \u2192 C (f a))\n( b : B)\n  : C b\n  := transport B C (f (sec-f b)) b (\u03b5-f b) (s (sec-f b))\n#def ind-has-section'\n( A B : U)\n( f : A \u2192 B)\n  ( ( sec-f , \u03b5-f) : has-section A B f)\n( C : B \u2192 U)\n( c' : (b : B) \u2192 C (f (sec-f b)))\n( b : B)\n  : C b\n  := transport B C (f (sec-f b)) b (\u03b5-f b) (c' b)\n</code></pre> <p>It is convenient to have available the special case where <code>f</code> is an equivalence.</p> <pre><code>#def ind-has-section-equiv\n( A B : U)\n  ( (f, is-equiv-f) : Equiv A B)\n  : ( C : B \u2192 U) \u2192 ((a : A) \u2192 C (f a)) \u2192 (b : B) \u2192 C b\n  := ind-has-section A B f (second is-equiv-f)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#composing-equivalences","title":"Composing equivalences","text":"<p>The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry:</p> <pre><code>#def inv-equiv\n( A B : U)\n( e : Equiv A B)\n  : Equiv B A\n  :=\n    ( first (has-inverse-is-equiv A B (first e) (second e)) ,\n      ( ( first e ,\nsecond (second (has-inverse-is-equiv A B (first e) (second e)))) ,\n        ( first e ,\nfirst (second (has-inverse-is-equiv A B (first e) (second e))))))\n</code></pre> Composition of equivalences in diagrammatic order<pre><code>#def equiv-comp\n( A B C : U)\n( A\u2243B : Equiv A B)\n( B\u2243C : Equiv B C)\n  : Equiv A C\n  :=\n    ( ( \\ a \u2192 first B\u2243C (first A\u2243B a)) ,\n      ( ( ( \\ c \u2192 first (first (second A\u2243B)) (first (first (second (B\u2243C))) c)) ,\n          ( \\ a \u2192\n            concat A\n              ( first\n                ( first (second A\u2243B))\n                ( first\n                  ( first (second B\u2243C))\n                  ( first B\u2243C (first A\u2243B a))))\n              ( first (first (second A\u2243B)) (first A\u2243B a))\n              ( a)\n              ( ap B A\n                ( first (first (second B\u2243C)) (first B\u2243C (first A\u2243B a)))\n                ( first A\u2243B a)\n                ( first (first (second A\u2243B)))\n                ( second (first (second B\u2243C)) (first A\u2243B a)))\n              ( second (first (second A\u2243B)) a))) ,\n        ( ( \\ c \u2192\nfirst\n            ( second (second A\u2243B))\n            ( first (second (second (B\u2243C))) c)) ,\n          ( \\ c \u2192\n            concat C\n              ( first B\u2243C\n                ( first A\u2243B\n                  ( first\n                    ( second (second A\u2243B))\n                    ( first (second (second B\u2243C)) c))))\n              ( first B\u2243C (first (second (second B\u2243C)) c))\n              ( c)\n              ( ap B C\n                ( first A\u2243B\n                  ( first\n                    ( second (second A\u2243B))\n                    ( first (second (second B\u2243C)) c)))\n                ( first (second (second B\u2243C)) c)\n                ( first B\u2243C)\n                ( second\n                  ( second (second A\u2243B))\n                  ( first (second (second B\u2243C)) c)))\n              ( second (second (second B\u2243C)) c)))))\n</code></pre> <p>Now we compose the functions that are equivalences.</p> <pre><code>#def is-equiv-comp\n( A B C : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n( g : B \u2192 C)\n( is-equiv-g : is-equiv B C g)\n  : is-equiv A C (comp A B C g f)\n  :=\n    ( ( comp C B A\n        ( retraction-is-equiv A B f is-equiv-f)\n        ( retraction-is-equiv B C g is-equiv-g) ,\n        ( \\ a \u2192\n          concat A\n            ( retraction-is-equiv A B f is-equiv-f\n              ( retraction-is-equiv B C g is-equiv-g (g (f a))))\n            ( retraction-is-equiv A B f is-equiv-f (f a))\n            ( a)\n            ( ap B A\n              ( retraction-is-equiv B C g is-equiv-g (g (f a)))\n              ( f a)\n              ( retraction-is-equiv A B f is-equiv-f)\n              ( second (first is-equiv-g) (f a)))\n            ( second (first is-equiv-f) a))) ,\n      ( comp C B A\n        ( section-is-equiv A B f is-equiv-f)\n        ( section-is-equiv B C g is-equiv-g) ,\n        ( \\ c \u2192\n          concat C\n            ( g (f (first (second is-equiv-f) (first (second is-equiv-g) c))))\n            ( g (first (second is-equiv-g) c))\n            ( c)\n            ( ap B C\n              ( f (first (second is-equiv-f) (first (second is-equiv-g) c)))\n              ( first (second is-equiv-g) c)\n              ( g)\n              ( second (second is-equiv-f) (first (second is-equiv-g) c)))\n            ( second (second is-equiv-g) c))))\n</code></pre> Right cancellation of equivalences in diagrammatic order<pre><code>#def equiv-right-cancel\n( A B C : U)\n( A\u2243C : Equiv A C)\n( B\u2243C : Equiv B C)\n  : Equiv A B\n  := equiv-comp A C B (A\u2243C) (inv-equiv B C B\u2243C)\n</code></pre> Left cancellation of equivalences in diagrammatic order<pre><code>#def equiv-left-cancel\n( A B C : U)\n( A\u2243B : Equiv A B)\n( A\u2243C : Equiv A C)\n  : Equiv B C\n  := equiv-comp B A C (inv-equiv A B A\u2243B) (A\u2243C)\n</code></pre> <p>The following functions refine <code>equiv-right-cancel</code> and <code>equiv-left-cancel</code> by providing control over the underlying maps of the equivalence. They also weaken the hypotheses: if a composite is an equivalence and the second map has a retraction the first map is an equivalence, and dually.</p> <pre><code>#def ap-cancel-has-retraction\n( B C : U)\n( g : B \u2192 C)\n  ( (retr-g, \u03b7-g) : has-retraction B C g)\n( b b' : B)\n  : (g b = g b') \u2192 (b = b')\n  :=\n\\ gp \u2192\n      triple-concat B b (retr-g (g b)) (retr-g (g b')) b'\n        (rev B (retr-g (g b)) b\n          (\u03b7-g b))\n        (ap C B (g b) (g b') retr-g gp)\n        (\u03b7-g b')\n</code></pre> Right cancellation of equivalence property in diagrammatic order<pre><code>#def is-equiv-right-cancel\n( A B C : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( has-retraction-g : has-retraction B C g)\n  ( ( (retr-gf, \u03b7-gf), (sec-gf, \u03b5-gf)) : is-equiv A C (comp A B C g f))\n  : is-equiv A B f\n  :=\n    ( ( comp B C A retr-gf g, \u03b7-gf)\n    , ( comp B C A sec-gf g\n      , \\ b \u2192\n            ap-cancel-has-retraction B C g\n            has-retraction-g (f (sec-gf (g b))) b\n            ( \u03b5-gf (g b))))\n</code></pre> Left cancellation of equivalence property in diagrammatic order<pre><code>#def is-equiv-left-cancel\n( A B C : U)\n( f : A \u2192 B)\n( has-section-f : has-section A B f)\n( g : B \u2192 C)\n  ( ( ( retr-gf, \u03b7-gf), (sec-gf, \u03b5-gf)) : is-equiv A C (comp A B C g f))\n  : is-equiv B C g\n  :=\n    ( ( comp C A B f retr-gf\n      , ind-has-section A B f has-section-f\n          ( \\ b \u2192 f (retr-gf (g b)) = b)\n          ( \\ a \u2192 ap A B (retr-gf (g (f a))) a f (\u03b7-gf a)))\n    , ( comp C A B f sec-gf, \u03b5-gf))\n</code></pre> <p>We typically apply the cancelation property in a setting where the composite and one map are known to be equivalences, so we define versions of the above functions with these stronger hypotheses.</p> <pre><code>#def is-equiv-right-factor\n( A B C : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( is-equiv-g : is-equiv B C g)\n( is-equiv-gf : is-equiv A C (comp A B C g f))\n  : is-equiv A B f\n  :=\n    is-equiv-right-cancel A B C f g (first is-equiv-g) is-equiv-gf\n#def is-equiv-left-factor\n( A B C : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n( g : B \u2192 C)\n( is-equiv-gf : is-equiv A C (comp A B C g f))\n  : is-equiv B C g\n  :=\n    is-equiv-left-cancel A B C f (second is-equiv-f) g is-equiv-gf\n</code></pre> A composition of three equivalences<pre><code>#def equiv-triple-comp\n( A B C D : U)\n( A\u2243B : Equiv A B)\n( B\u2243C : Equiv B C)\n( C\u2243D : Equiv C D)\n  : Equiv A D\n  := equiv-comp A B D (A\u2243B) (equiv-comp B C D B\u2243C C\u2243D)\n#def is-equiv-triple-comp\n( A B C D : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n( g : B \u2192 C)\n( is-equiv-g : is-equiv B C g)\n( h : C \u2192 D)\n( is-equiv-h : is-equiv C D h)\n  : is-equiv A D (triple-comp A B C D h g f)\n  :=\n    is-equiv-comp A B D\n      ( f)\n      ( is-equiv-f)\n      ( comp B C D h g)\n      ( is-equiv-comp B C D g is-equiv-g h is-equiv-h)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalences-and-homotopy","title":"Equivalences and homotopy","text":"<p>If a map is homotopic to an equivalence it is an equivalence.</p> <pre><code>#def is-equiv-homotopy\n( A B : U)\n( f g : A \u2192 B)\n( H : homotopy A B f g)\n( is-equiv-g : is-equiv A B g)\n  : is-equiv A B f\n  :=\n    ( ( ( first (first is-equiv-g))\n      , ( \\ a \u2192\n          concat A\n            ( first (first is-equiv-g) (f a))\n            ( first (first is-equiv-g) (g a))\n            ( a)\n            ( ap B A (f a) (g a) (first (first is-equiv-g)) (H a))\n            ( second (first is-equiv-g) a)))\n    , ( ( first (second is-equiv-g))\n      , ( \\ b \u2192\n          concat B\n            ( f (first (second is-equiv-g) b))\n            ( g (first (second is-equiv-g) b))\n            ( b)\n            ( H (first (second is-equiv-g) b))\n            ( second (second is-equiv-g) b))))\n#def is-equiv-rev-homotopy\n( A B : U)\n( f g : A \u2192 B)\n( H : homotopy A B f g)\n( is-equiv-f : is-equiv A B f)\n  : is-equiv A B g\n  := is-equiv-homotopy A B g f (rev-homotopy A B f g H) is-equiv-f\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#reversing-equivalences","title":"Reversing equivalences","text":"<p>The section associated with an equivalence is an equivalence.</p> <pre><code>#def is-equiv-section-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : is-equiv B A ( section-is-equiv A B f is-equiv-f)\n  :=\n    is-equiv-has-inverse B A\n      ( section-is-equiv A B f is-equiv-f)\n      ( has-inverse-map-inverse-has-inverse A B f\n        ( has-inverse-is-equiv A B f is-equiv-f))\n</code></pre> <p>The retraction associated with an equivalence is an equivalence.</p> <pre><code>#def is-equiv-retraction-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : is-equiv B A ( retraction-is-equiv A B f is-equiv-f)\n  :=\n    is-equiv-rev-homotopy B A\n      ( section-is-equiv A B f is-equiv-f)\n      ( retraction-is-equiv A B f is-equiv-f)\n      ( homotopy-section-retraction-is-equiv A B f is-equiv-f)\n      ( is-equiv-section-is-equiv A B f is-equiv-f)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#section-retraction-pairs","title":"Section-retraction pairs","text":"<p>A pair of maps <code>s : A \u2192 B</code> and <code>r : B \u2192 A'</code> is a section-retraction pair if the composite <code>A \u2192 A'</code> is an equivalence.</p> <pre><code>#def is-section-retraction-pair\n( A B A' : U)\n( s : A \u2192 B)\n( r : B \u2192 A')\n  : U\n  := is-equiv A A' (comp A B A' r s)\n</code></pre> <p>When we have such a section-retraction pair <code>(s, r)</code>, we say that <code>r</code> is an external retraction of <code>s</code> and <code>s</code> is an external section of <code>r</code>.</p> <pre><code>#def has-external-retraction\n( A B : U)\n( s : A \u2192 B)\n  : U\n  :=\n\u03a3 ((A', r) : ( \u03a3 (A' : U) , B \u2192 A'))\n    , ( is-section-retraction-pair A B A' s r)\n#def has-external-section\n( B A' : U)\n( r : B \u2192 A')\n  : U\n  :=\n\u03a3 ((A, s) : ( \u03a3 (A : U) , A \u2192 B))\n    , ( is-section-retraction-pair A B A' s r)\n</code></pre> <p>Note that exactly like <code>has-section</code> and <code>has-retraction</code> these are not properties of <code>s</code> or <code>r</code>, but structure.</p> <p>Without univalence, we cannot yet show that the types <code>has-external-retraction</code> and <code>has-retraction</code> (and their section counterparts, respectively) are equivalent, so we content ourselves in showing that there is a logical biimplication between them.</p> <pre><code>#def is-equiv-retraction-section\n( A B : U)\n( s : A \u2192 B)\n( r : B \u2192 A)\n( \u03b7 : (a : A) \u2192 r (s a) = a)\n  : is-equiv A A (\\ a \u2192 r (s a))\n  :=\n    is-equiv-homotopy A A (\\ a \u2192 r (s (a))) (identity A)\n      ( \u03b7) ( is-equiv-identity A)\n#def has-retraction-externalize\n( A B : U)\n( s : A \u2192 B)\n  ( (r , \u03b7) : has-retraction A B s)\n  : has-external-retraction A B s\n  :=\n    ( ( A , r)\n    , is-equiv-retraction-section A B s r \u03b7)\n#def has-section-externalize\n( B A' : U)\n( r : B \u2192 A')\n  ( (s , \u03b5) : has-section B A' r)\n  : has-external-section B A' r\n  :=\n    ( ( A' , s)\n    , is-equiv-retraction-section A' B s r \u03b5)\n#def has-retraction-internalize\n( A B : U)\n( s : A \u2192 B)\n  ( ((A' , r) , ( (rec-rs , \u03b7-rs) , _))\n    : has-external-retraction A B s)\n  : has-retraction A B s\n  := ( comp B A' A rec-rs r , \u03b7-rs)\n#def has-section-internalize\n( B A' : U)\n( r : B \u2192 A')\n  ( ((A , s) , (_ , (sec-rs , \u03b5-rs)))\n    : has-external-section B A' r)\n  : has-section B A' r\n  := ( comp A' A B s sec-rs , \u03b5-rs)\n</code></pre> <p>A consequence of the above is that in a section-retraction pair <code>(s, r)</code>, the map <code>s</code> is a section and the map <code>r</code> is a retraction. Note that not every composable pair <code>(s, r)</code> of such maps is a section-retraction pair; they have to (up to composition with an equivalence) be section and retraction of each other.</p> <p>In a section-retraction pair, if one of <code>s : A \u2192 B</code> and <code>r : B \u2192 A'</code> is an equivalence, then so is the other.</p> <p>This is just a rephrasing of <code>is-equiv-left-factor</code> and <code>is-equiv-right-factor</code>.</p> <pre><code>#section is-equiv-is-section-retraction-pair\n#variables A B A' : U\n#variable s : A \u2192 B\n#variable r : B \u2192 A'\n#variable is-sec-rec-pair : is-section-retraction-pair A B A' s r\n#def is-equiv-section-is-equiv-retraction-is-section-retraction-pair\n( is-equiv-r : is-equiv B A' r)\n  : is-equiv A B s\n  :=\n    is-equiv-right-factor A B A' s r\n    ( is-equiv-r) ( is-sec-rec-pair)\n#def is-equiv-retraction-is-equiv-section-is-section-retraction-pair\n( is-equiv-s : is-equiv A B s)\n  : is-equiv B A' r\n  :=\n    is-equiv-left-factor A B A'\n    ( s) ( is-equiv-s)\n    ( r) ( is-sec-rec-pair)\n#end is-equiv-is-section-retraction-pair\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#retracts","title":"Retracts","text":"<p>We say that a type <code>A</code> is a retract of a type <code>B</code> if we have a map <code>s : A \u2192 B</code> which has a retraction.</p> The type of proofs that A is a retract of B<pre><code>#def is-retract-of\n( A B : U)\n  : U\n  := \u03a3 ( s : A \u2192 B) , has-retraction A B s\n#def section-is-retract-of\n( A B : U)\n  ( (s , (_ , _)) : is-retract-of A B)\n  : A \u2192 B\n  := s\n#def retraction-is-retract-of\n( A B : U)\n  ( (_ , (r , _)) : is-retract-of A B)\n  : B \u2192 A\n  := r\n#def homotopy-is-retract-of\n( A B : U)\n  ( (s , (r , \u03b7)) : is-retract-of A B)\n  : homotopy A A ( \\ a \u2192 r ( s a)) ( identity A)\n  := \u03b7\n</code></pre> <p>Section-retraction pairs <code>A \u2192 B \u2192 A'</code> are a convenient way to exhibit both <code>A</code> and <code>A'</code> as retracts of <code>B</code>.</p> <pre><code>#def is-retract-of-left-section-retraction-pair\n( A B A' : U)\n( s : A \u2192 B)\n( r : B \u2192 A')\n( is-sr-pair-sr : is-section-retraction-pair A B A' s r)\n  : is-retract-of A B\n  :=\n    ( ( s)\n    , ( has-retraction-internalize A B s ((A' , r) , is-sr-pair-sr)))\n#def is-retract-of-right-section-retraction-pair\n( A B A' : U)\n( s : A \u2192 B)\n( r : B \u2192 A')\n( is-sr-pair-sr : is-section-retraction-pair A B A' s r)\n  : is-retract-of A' B\n  :=\n    ( first ( has-section-internalize B A' r ((A , s) , is-sr-pair-sr))\n    , ( r\n      , second ( has-section-internalize B A' r ((A , s) , is-sr-pair-sr))))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#function-extensionality","title":"Function extensionality","text":"<p>By path induction, an identification between functions defines a homotopy.</p> <pre><code>#def htpy-eq\n( X : U)\n( A : X \u2192 U)\n( f g : (x : X) \u2192 A x)\n( p : f = g)\n  : (x : X) \u2192 (f x = g x)\n  :=\n    ind-path\n( (x : X) \u2192 A x)\n      ( f)\n( \\ g' p' \u2192 (x : X) \u2192 (f x = g' x))\n      ( \\ x \u2192 refl)\n      ( g)\n      ( p)\n</code></pre> <p>The function extensionality axiom asserts that this map defines a family of equivalences.</p> The type that encodes the function extensionality axiom<pre><code>#def FunExt : U\n  :=\n( X : U) \u2192\n( A : X \u2192 U) \u2192\n( f : (x : X) \u2192 A x) \u2192\n( g : (x : X) \u2192 A x) \u2192\n    is-equiv (f = g) ((x : X) \u2192 f x = g x) (htpy-eq X A f g)\n</code></pre> <p>In the formalisations below, some definitions will assume function extensionality:</p> <pre><code>#assume funext : FunExt\n</code></pre> <p>Whenever a definition (implicitly) uses function extensionality, we write <code>uses (funext)</code>. In particular, the following definitions rely on function extensionality:</p> The equivalence provided by function extensionality<pre><code>#def equiv-FunExt uses (funext)\n( X : U)\n( A : X \u2192 U)\n( f g : (x : X) \u2192 A x)\n  : Equiv (f = g) ((x : X) \u2192 f x = g x)\n  := (htpy-eq X A f g , funext X A f g)\n</code></pre> <p>In particular, function extensionality implies that homotopies give rise to identifications. This defines <code>eq-htpy</code> to be the retraction to <code>htpy-eq</code>.</p> <pre><code>#def eq-htpy uses (funext)\n( X : U)\n( A : X \u2192 U)\n( f g : (x : X) \u2192 A x)\n  : ((x : X) \u2192 f x = g x) \u2192 (f = g)\n  := first (first (funext X A f g))\n</code></pre> <p>Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types.</p> <pre><code>#def is-equiv-function-is-equiv-family uses (funext)\n( X : U)\n( A B : X \u2192 U)\n( f : (x : X) \u2192 (A x) \u2192 (B x))\n( famisequiv : (x : X) \u2192 is-equiv (A x) (B x) (f x))\n  : is-equiv ((x : X) \u2192 A x) ((x : X) \u2192 B x) ( \\ a x \u2192 f x (a x))\n  :=\n    ( ( ( \\ b x \u2192 first (first (famisequiv x)) (b x))\n      , ( \\ a \u2192\n           eq-htpy\n            X A\n           ( \\ x \u2192\nfirst\n                ( first (famisequiv x))\n                ( f x (a x)))\n            ( a)\n            ( \\ x \u2192 second (first (famisequiv x)) (a x))))\n    , ( ( \\ b x \u2192 first (second (famisequiv x)) (b x))\n      , ( \\ b \u2192\n            eq-htpy\n            X B\n            ( \\ x \u2192 f x (first (second (famisequiv x)) (b x)))\n            ( b)\n            ( \\ x \u2192 second (second (famisequiv x)) (b x)))))\n</code></pre> <pre><code>#def equiv-function-equiv-family uses (funext)\n( X : U)\n( A B : X \u2192 U)\n( famequiv : (x : X) \u2192 Equiv (A x) (B x))\n  : Equiv ((x : X) \u2192 A x) ((x : X) \u2192 B x)\n  :=\n    ( ( \\ a x \u2192 (first (famequiv x)) (a x))\n    , ( is-equiv-function-is-equiv-family\n        ( X)\n        ( A)\n        ( B)\n        ( \\ x ax \u2192 first (famequiv x) (ax))\n        ( \\ x \u2192 second (famequiv x))))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#embeddings","title":"Embeddings","text":"<pre><code>#def is-emb\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := (x : A) \u2192 (y : A) \u2192 is-equiv (x = y) (f x = f y) (ap A B x y f)\n#def Emb\n( A B : U)\n  : U\n  := (\u03a3 (f : A \u2192 B) , is-emb A B f)\n#def is-emb-is-inhabited-emb\n( A B : U)\n( f : A \u2192 B)\n( e : A \u2192 is-emb A B f)\n  : is-emb A B f\n  := \\ x y \u2192 e x x y\n#def inv-ap-is-emb\n( A B : U)\n( f : A \u2192 B)\n( is-emb-f : is-emb A B f)\n( x y : A)\n( p : f x = f y)\n  : (x = y)\n  := first (first (is-emb-f x y)) p\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#reversal-is-an-equivalence","title":"Reversal is an equivalence","text":"<pre><code>#def equiv-rev\n( A : U)\n( x y : A)\n  : Equiv (x = y) (y = x)\n  := (rev A x y , ((rev A y x , rev-rev A x y) , (rev A y x , rev-rev A y x)))\n</code></pre> <pre><code>#def ind-rev\n( A : U)\n( x y : A)\n( B : (x = y) \u2192 U)\n  : ((p : y = x) \u2192 B (rev A y x p)) \u2192 ( q : x = y) \u2192 B q\n  :=\n    ind-has-section-equiv (y = x) (x = y) (equiv-rev A y x) ( B)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#concatenation-with-a-fixed-path-is-an-equivalence","title":"Concatenation with a fixed path is an equivalence","text":"<pre><code>#def equiv-preconcat\n( A : U)\n( x y z : A)\n( p : x = y)\n  : Equiv (y = z) (x = z)\n  :=\n    ( concat A x y z p\n    , ( ( concat A y x z (rev A x y p), retraction-preconcat A x y z p)\n      , ( concat A y x z (rev A x y p), section-preconcat A x y z p)))\n#def equiv-postconcat\n( A : U)\n( x y z : A)\n( q : y = z) : Equiv (x = y) (x = z)\n  :=\n    ( \\ p \u2192 concat A x y z p q\n    , ( ( \\ r \u2192 concat A x z y r (rev A y z q)\n        , retraction-postconcat A x y z q)\n      , ( \\ r \u2192 concat A x z y r (rev A y z q)\n        , section-postconcat A x y z q)))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#transport-along-a-path-is-an-equivalence","title":"Transport along a path is an equivalence","text":"<pre><code>#def is-equiv-transport\n( A : U)\n( C : A \u2192 U)\n( x : A)\n  : (y : A) \u2192 ( p : x = y) \u2192 is-equiv (C x) (C y) (transport A C x y p)\n  := ind-path A x\n       ( \\ y p \u2192 is-equiv (C x) (C y) (transport A C x y p))\n       ( is-equiv-identity (C x) )\n#def equiv-transport\n( A : U)\n( C : A \u2192 U)\n( x y : A)\n( p : x = y)\n  : Equiv (C x) (C y)\n  := (transport A C x y p , is-equiv-transport A C x y p)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalence-is-equivalence-invariant","title":"Equivalence is equivalence invariant","text":"<pre><code>#def map-of-maps\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  : U\n  :=\n\u03a3 ( ( s',s) : product ( A' \u2192 B' ) ( A \u2192 B))\n    , ( ( a' : A') \u2192 \u03b2 ( s' a') = s ( \u03b1 a'))\n#def map-Map\n  ( ((A',A),\u03b1) : Map)\n  ( ((B',B),\u03b2) : Map)\n  : U\n  := map-of-maps A' A \u03b1 B' B \u03b2\n#def Equiv-of-maps\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  : U\n  :=\n\u03a3 ( ((s', s), _) : map-of-maps A' A \u03b1 B' B \u03b2)\n    , ( product\n        ( is-equiv A' B' s')\n        ( is-equiv A B s))\n#def is-equiv-equiv-is-equiv\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( ((s', s), \u03b7) : map-of-maps A' A \u03b1 B' B \u03b2)\n( is-equiv-s' : is-equiv A' B' s')\n( is-equiv-s : is-equiv A B s)\n( is-equiv-\u03b2 : is-equiv B' B \u03b2)\n  : is-equiv A' A \u03b1\n  :=\n    is-equiv-right-factor A' A B \u03b1 s is-equiv-s\n      ( is-equiv-rev-homotopy A' B\n        ( comp A' B' B \u03b2 s')\n        ( comp A' A B s \u03b1)\n        ( \u03b7 )\n        ( is-equiv-comp A' B' B s' is-equiv-s' \u03b2 is-equiv-\u03b2))\n#def is-equiv-Equiv-is-equiv\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( ( S, (is-equiv-s',is-equiv-s)) : Equiv-of-maps A' A \u03b1 B' B \u03b2 )\n  : is-equiv B' B \u03b2 \u2192 is-equiv A' A \u03b1\n  := is-equiv-equiv-is-equiv A' A \u03b1 B' B \u03b2 S is-equiv-s' is-equiv-s\n#def is-equiv-equiv-is-equiv'\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( ((s', s), \u03b7) : map-of-maps A' A \u03b1 B' B \u03b2)\n( is-equiv-s' : is-equiv A' B' s')\n( is-equiv-s : is-equiv A B s)\n( is-equiv-\u03b1 : is-equiv A' A \u03b1)\n  : is-equiv B' B \u03b2\n  :=\n    is-equiv-left-factor A' B' B s' is-equiv-s' \u03b2\n      ( is-equiv-homotopy A' B\n        ( comp A' B' B \u03b2 s')\n        ( comp A' A B s \u03b1)\n        ( \u03b7)\n        ( is-equiv-comp A' A B \u03b1 is-equiv-\u03b1 s is-equiv-s))\n#def is-equiv-Equiv-is-equiv'\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( ( S, (is-equiv-s',is-equiv-s)) : Equiv-of-maps A' A \u03b1 B' B \u03b2 )\n  : is-equiv A' A \u03b1 \u2192 is-equiv B' B \u03b2\n  := is-equiv-equiv-is-equiv' A' A \u03b1 B' B \u03b2 S is-equiv-s' is-equiv-s\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/","title":"4. Half adjoint equivalences","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#half-adjoint-equivalences","title":"Half adjoint equivalences","text":"<p>We'll require a more coherent notion of equivalence. Namely, the notion of half adjoint equivalences.</p> <pre><code>#def is-half-adjoint-equiv\n( A B : U)\n( f : A \u2192 B)\n  : U\n  :=\n\u03a3 ( has-inverse-f : (has-inverse A B f)) ,\n( ( a : A) \u2192\n        ( second (second has-inverse-f) (f a)) =\n        ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f a)\n          ( a)\n          ( f)\n          ( first (second has-inverse-f) a)))\n</code></pre> <p>By function extensionality, the previous definition coincides with the following one:</p> <pre><code>#def is-half-adjoint-equiv'\n(A B : U)\n(f : A \u2192 B)\n  : U\n  :=\n\u03a3 ( has-inverse-f : (has-inverse A B f)) ,\n( ( a : A) \u2192\n        ( second (second has-inverse-f) (f a)) =\n        ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f a)\n          ( a)\n          ( f)\n          ( first (second has-inverse-f) a)))\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#half-adjoint-equivalence-data","title":"Half adjoint equivalence data","text":"<pre><code>#section half-adjoint-equivalence-data\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-hae-f : is-half-adjoint-equiv A B f\n#def map-inverse-is-half-adjoint-equiv uses (f)\n  : B \u2192 A\n  := map-inverse-has-inverse A B f (first is-hae-f)\n#def retraction-htpy-is-half-adjoint-equiv\n  : homotopy A A (comp A B A map-inverse-is-half-adjoint-equiv f) (identity A)\n  := first (second (first is-hae-f))\n#def section-htpy-is-half-adjoint-equiv\n  : homotopy B B (comp B A B f map-inverse-is-half-adjoint-equiv) (identity B)\n  := second (second (first is-hae-f))\n#def coherence-is-half-adjoint-equiv\n( a : A)\n  : section-htpy-is-half-adjoint-equiv (f a) =\n    ap A B (map-inverse-is-half-adjoint-equiv (f a)) a f\n    ( retraction-htpy-is-half-adjoint-equiv a)\n  := (second is-hae-f) a\n#end half-adjoint-equivalence-data\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#coherence-data-from-an-invertible-map","title":"Coherence data from an invertible map","text":"<p>To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other.</p> <pre><code>#def has-inverse-kept-htpy\n( A B : U)\n( f : A \u2192 B)\n( has-inverse-f : has-inverse A B f)\n  : homotopy A A\n    ( retraction-composite-has-inverse A B f has-inverse-f) (identity A)\n  := ( first (second has-inverse-f))\n#def has-inverse-discarded-htpy\n( A B : U)\n( f : A \u2192 B)\n( has-inverse-f : has-inverse A B f)\n  : homotopy B B\n    ( section-composite-has-inverse A B f has-inverse-f) (identity B)\n  := (second (second has-inverse-f))\n</code></pre> <p>The required coherence will be built by transforming an instance of the following naturality square.</p> <pre><code>#section has-inverse-coherence\n#variables A B : U\n#variable f : A \u2192 B\n#variable has-inverse-f : has-inverse A B f\n#variable a : A\n#def has-inverse-discarded-naturality-square\n  : concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n    ( triple-composite-has-inverse A B f has-inverse-f a)\n    ( f a)\n    ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( triple-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n    ( has-inverse-discarded-htpy A B f has-inverse-f (f a)) =\n    concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n      ( triple-composite-has-inverse A B f has-inverse-f a)\n      ( f a)\n      ( has-inverse-discarded-htpy A B f has-inverse-f\n        ( triple-composite-has-inverse A B f has-inverse-f a))\n      ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n        f (has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    nat-htpy A B\n    ( triple-composite-has-inverse A B f has-inverse-f)\n    ( f)\n    ( \\ x \u2192 has-inverse-discarded-htpy A B f has-inverse-f (f x))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( a)\n    ( has-inverse-kept-htpy A B f has-inverse-f a)\n</code></pre> <p>We build a path that will be whiskered into the naturality square above:</p> <pre><code>#def has-inverse-cocone-homotopy-coherence\n  : has-inverse-kept-htpy A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a) =\n    ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( retraction-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a)\n  :=\n    cocone-naturality-coherence\n      ( A)\n      ( retraction-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f)\n      ( a)\n#def has-inverse-ap-cocone-homotopy-coherence\n  : ap A B\n    ( retraction-composite-has-inverse A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( f)\n    ( has-inverse-kept-htpy A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a)) =\n    ap A B\n    ( retraction-composite-has-inverse A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( f)\n    ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( retraction-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    ap-eq A B\n      ( retraction-composite-has-inverse A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a))\n      ( retraction-composite-has-inverse A B f has-inverse-f a)\n      ( f)\n      ( has-inverse-kept-htpy A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a))\n      ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a\n        ( retraction-composite-has-inverse A B f has-inverse-f)\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n      ( has-inverse-cocone-homotopy-coherence)\n#def has-inverse-cocone-coherence\n  : ap A B\n    ( retraction-composite-has-inverse A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( f)\n    ( has-inverse-kept-htpy A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a)) =\n    ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( triple-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    concat\n      ( quintuple-composite-has-inverse A B f has-inverse-f a =\n        triple-composite-has-inverse A B f has-inverse-f a)\n      ( ap A B\n        ( retraction-composite-has-inverse A B f has-inverse-f\n          ( retraction-composite-has-inverse A B f has-inverse-f a))\n        ( retraction-composite-has-inverse A B f has-inverse-f a)\n        ( f)\n        ( has-inverse-kept-htpy A B f has-inverse-f\n          ( retraction-composite-has-inverse A B f has-inverse-f a)))\n      ( ap A B\n        ( retraction-composite-has-inverse A B f has-inverse-f\n          ( retraction-composite-has-inverse A B f has-inverse-f a))\n        ( retraction-composite-has-inverse A B f has-inverse-f a)\n        ( f)\n        ( ap A A\n          ( retraction-composite-has-inverse A B f has-inverse-f a) a\n          ( retraction-composite-has-inverse A B f has-inverse-f)\n          ( has-inverse-kept-htpy A B f has-inverse-f a)))\n      ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n        ( triple-composite-has-inverse A B f has-inverse-f)\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n      ( has-inverse-ap-cocone-homotopy-coherence)\n      ( rev-ap-comp A A B\n        ( retraction-composite-has-inverse A B f has-inverse-f a) a\n        ( retraction-composite-has-inverse A B f has-inverse-f)\n        ( f)\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n</code></pre> <p>This morally gives the half adjoint inverse coherence. It just requires rotation.</p> <pre><code>#def has-inverse-replaced-naturality-square\n  : concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n    ( triple-composite-has-inverse A B f has-inverse-f a)\n    ( f a)\n    ( ap A B\n      ( retraction-composite-has-inverse A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a))\n      ( retraction-composite-has-inverse A B f has-inverse-f a)\n      ( f)\n      ( has-inverse-kept-htpy A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a)))\n    ( has-inverse-discarded-htpy A B f has-inverse-f (f a)) =\n    concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n    ( triple-composite-has-inverse A B f has-inverse-f a)\n    ( f a)\n    ( has-inverse-discarded-htpy A B f has-inverse-f\n      ( triple-composite-has-inverse A B f has-inverse-f a))\n    ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    concat\n      ( quintuple-composite-has-inverse A B f has-inverse-f a = f a)\n      ( concat B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a)\n        ( f a)\n        ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a))\n          ( retraction-composite-has-inverse A B f has-inverse-f a) f\n          ( has-inverse-kept-htpy A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a)))\n        ( has-inverse-discarded-htpy A B f has-inverse-f (f a)))\n      ( concat B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a)\n        ( f a)\n        ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n          ( triple-composite-has-inverse A B f has-inverse-f)\n          ( has-inverse-kept-htpy A B f has-inverse-f a))\n        ( has-inverse-discarded-htpy A B f has-inverse-f (f a)))\n      ( concat B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a) (f a)\n        ( has-inverse-discarded-htpy A B f has-inverse-f\n          ( triple-composite-has-inverse A B f has-inverse-f a))\n        ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n          ( has-inverse-kept-htpy A B f has-inverse-f a)))\n      ( concat-eq-left B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a)\n        ( f a)\n        ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a))\n          ( retraction-composite-has-inverse A B f has-inverse-f a)\n          ( f)\n          ( has-inverse-kept-htpy A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a)))\n        ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n          ( triple-composite-has-inverse A B f has-inverse-f)\n          ( has-inverse-kept-htpy A B f has-inverse-f a))\n        ( has-inverse-cocone-coherence)\n        ( has-inverse-discarded-htpy A B f has-inverse-f (f a)))\n      ( has-inverse-discarded-naturality-square)\n</code></pre> <p>This will replace the discarded homotopy.</p> <pre><code>#def has-inverse-corrected-htpy\n  : homotopy B B (section-composite-has-inverse A B f has-inverse-f) (\\ b \u2192 b)\n  :=\n\\ b \u2192\n      concat B\n        ( (section-composite-has-inverse A B f has-inverse-f) b)\n        ( (section-composite-has-inverse A B f has-inverse-f)\n          ((section-composite-has-inverse A B f has-inverse-f) b))\n        ( b)\n        ( rev B\n          ( (section-composite-has-inverse A B f has-inverse-f)\n            ((section-composite-has-inverse A B f has-inverse-f) b))\n          ( (section-composite-has-inverse A B f has-inverse-f) b)\n          ( has-inverse-discarded-htpy A B f has-inverse-f\n            ((section-composite-has-inverse A B f has-inverse-f) b)))\n        ( concat B\n          ( (section-composite-has-inverse A B f has-inverse-f)\n            ((section-composite-has-inverse A B f has-inverse-f) b))\n          ( (section-composite-has-inverse A B f has-inverse-f) b)\n          ( b)\n          ( ap A B\n            ( (retraction-composite-has-inverse A B f has-inverse-f)\n              (map-inverse-has-inverse A B f has-inverse-f b))\n            ( map-inverse-has-inverse A B f has-inverse-f b) f\n            ( (first (second has-inverse-f))\n              (map-inverse-has-inverse A B f has-inverse-f b)))\n          ( (has-inverse-discarded-htpy A B f has-inverse-f b)))\n</code></pre> <p>The following is the half adjoint coherence.</p> <pre><code>#def has-inverse-coherence\n  : ( has-inverse-corrected-htpy (f a)) =\n    ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    triangle-rotation B\n      ( quintuple-composite-has-inverse A B f has-inverse-f a)\n      ( triple-composite-has-inverse A B f has-inverse-f a)\n      ( f a)\n      ( concat B\n        ( (section-composite-has-inverse A B f has-inverse-f)\n          ((section-composite-has-inverse A B f has-inverse-f) (f a)))\n        ( (section-composite-has-inverse A B f has-inverse-f) (f a))\n        ( f a)\n        ( ap A B\n          ( (retraction-composite-has-inverse A B f has-inverse-f)\n            (map-inverse-has-inverse A B f has-inverse-f (f a)))\n          ( map-inverse-has-inverse A B f has-inverse-f (f a))\n            ( f)\n            ( (first (second has-inverse-f))\n              (map-inverse-has-inverse A B f has-inverse-f (f a))))\n        ( (has-inverse-discarded-htpy A B f has-inverse-f (f a))))\n      ( has-inverse-discarded-htpy A B f has-inverse-f\n        ( triple-composite-has-inverse A B f has-inverse-f a))\n      ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n      ( has-inverse-replaced-naturality-square)\n</code></pre> <pre><code>#end has-inverse-coherence\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#invertible-maps-are-half-adjoint-equivalences","title":"Invertible maps are half adjoint equivalences","text":"<p>To promote an invertible map to a half adjoint equivalence we change the data of the invertible map by discarding the homotopy and replacing it with a corrected one.</p> <pre><code>#def corrected-has-inverse-has-inverse\n( A B : U)\n( f : A \u2192 B)\n( has-inverse-f : has-inverse A B f)\n  : has-inverse A B f\n  :=\n    ( map-inverse-has-inverse A B f has-inverse-f ,\n      ( has-inverse-kept-htpy A B f has-inverse-f ,\n        has-inverse-corrected-htpy A B f has-inverse-f))\n</code></pre> Invertible maps are half adjoint equivalences!<pre><code>#def is-half-adjoint-equiv-has-inverse\n( A B : U)\n( f : A \u2192 B)\n( has-inverse-f : has-inverse A B f)\n  : is-half-adjoint-equiv A B f\n  :=\n    ( corrected-has-inverse-has-inverse A B f has-inverse-f ,\n      has-inverse-coherence A B f has-inverse-f)\n</code></pre> Equivalences are half adjoint equivalences!<pre><code>#def is-half-adjoint-equiv-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : is-half-adjoint-equiv A B f\n  :=\n    is-half-adjoint-equiv-has-inverse A B f\n      ( has-inverse-is-equiv A B f is-equiv-f)\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#equivalences-are-embeddings","title":"Equivalences are embeddings","text":"<p>We use the notion of half adjoint equivalence to prove that equivalent types have equivalent identity types by showing that equivalences are embeddings.</p> <pre><code>#section equiv-identity-types-equiv\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-hae-f : is-half-adjoint-equiv A B f\n#def iff-ap-is-half-adjoint-equiv\n( x y : A)\n  : iff (x = y) (f x = f y)\n  :=\n    ( ap A B x y f ,\n\\ q \u2192\n      triple-concat A\n        ( x)\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( y)\n        ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n          ( (first (second (first is-hae-f))) x))\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q)\n        ( (first (second (first is-hae-f))) y))\n#def has-retraction-ap-is-half-adjoint-equiv\n(x y : A)\n  : has-retraction (x = y) (f x = f y) (ap A B x y f)\n  :=\n    ( ( second (iff-ap-is-half-adjoint-equiv x y)) ,\n      ( ind-path\n          ( A)\n          ( x)\n          ( \\ y' p' \u2192\n            ( second (iff-ap-is-half-adjoint-equiv x y')) (ap A B x y' f p') =\n            ( p'))\n          ( rev-refl-id-triple-concat A\n            ( map-inverse-has-inverse A B f (first is-hae-f) (f x))\n            ( x)\n            ( first (second (first is-hae-f)) x))\n          ( y)))\n#def ap-triple-concat-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : ap A B x y f ((second (iff-ap-is-half-adjoint-equiv x y)) q) =\n    (triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( ap A B x ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n        ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n          ( (first (second (first is-hae-f))) x)))\n      ( ap A B\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( f)\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n        ( (first (second (first is-hae-f))) y)))\n  :=\n    ap-triple-concat A B\n      ( x)\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( y)\n      ( f)\n      ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n        ( (first (second (first is-hae-f))) x))\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q)\n      ( (first (second (first is-hae-f))) y)\n#def ap-rev-triple-concat-eq-first-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( ap A B x ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n      (rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n        ( (first (second (first is-hae-f))) x)))\n    ( ap A B\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( f)\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n    ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n      ( (first (second (first is-hae-f))) y)) =\n    triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n        ( (first (second (first is-hae-f))) x)))\n    ( ap A B\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( f)\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n    ( ap A B\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( y)\n      ( f)\n      ( (first (second (first is-hae-f))) y))\n  :=\n    triple-concat-eq-first B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( ap A B\n      ( x) ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n      ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n        ( (first (second (first is-hae-f))) x)))\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n        ( (first (second (first is-hae-f))) x)))\n    ( ap A B\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( f)\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n    ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n      ( (first (second (first is-hae-f))) y))\n    ( ap-rev A B (retraction-composite-has-inverse A B f (first is-hae-f) x) x f\n      ( (first (second (first is-hae-f))) x))\n#def ap-ap-triple-concat-eq-first-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : (triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B\n        ( f (retraction-composite-has-inverse A B f (first is-hae-f) x))\n        ( f x)\n        ( ap A B\n          ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n          ( (first (second (first is-hae-f))) x)))\n      ( ap A B\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( f)\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n        ( (first (second (first is-hae-f))) y))) =\n    ( triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B\n        ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n          ( (first (second (first is-hae-f))) x)))\n      ( ap B B (f x) (f y)\n        ( section-composite-has-inverse A B f (first is-hae-f)) q)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y\n        ( f) ((first (second (first is-hae-f))) y)))\n  :=\n    triple-concat-eq-second B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n          ( (first (second (first is-hae-f))) x)))\n      ( ap A B\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( f)\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n      ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n        ( (first (second (first is-hae-f))) y))\n      ( rev-ap-comp B A B (f x) (f y)\n        ( map-inverse-has-inverse A B f (first is-hae-f)) f q)\n-- This needs to be reversed later.\n#def triple-concat-higher-homotopy-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( (second (second (first is-hae-f))) (f x)))\n      ( ap B B (f x) (f y)\n        ( section-composite-has-inverse A B f (first is-hae-f)) q)\n      ( (second (second (first is-hae-f))) (f y)) =\n    triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      (rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        (ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f ((first (second (first is-hae-f))) x)))\n        (ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n        (ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f ((first (second (first is-hae-f))) y))\n  :=\n    triple-concat-higher-homotopy A B\n      ( triple-composite-has-inverse A B f (first is-hae-f)) f\n      ( \\ a \u2192 (((second (second (first is-hae-f)))) (f a)))\n      ( \\ a \u2192\n        ( ap A B (retraction-composite-has-inverse A B f (first is-hae-f) a) a f\n          ( ((first (second (first is-hae-f)))) a)))\n      ( second is-hae-f)\n      ( x)\n      ( y)\n      ( ap B B (f x) (f y)\n        ( section-composite-has-inverse A B f (first is-hae-f)) q)\n#def triple-concat-nat-htpy-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ((second (second (first is-hae-f)))) (f x)))\n    ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n    ( ((second (second (first is-hae-f)))) (f y))\n    = ap B B (f x) (f y) (identity B) q\n  :=\n    triple-concat-nat-htpy B B\n      ( section-composite-has-inverse A B f (first is-hae-f))\n      ( identity B)\n      ( (second (second (first is-hae-f))))\n      ( f x)\n      ( f y)\n      q\n#def zag-zig-concat-triple-concat-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n        ( (first (second (first is-hae-f))) x)))\n    ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n    ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n      ( (first (second (first is-hae-f))) y)) =\n    ap B B (f x) (f y) (identity B) q\n  :=\n    zag-zig-concat (f x = f y)\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n          ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n            ( (first (second (first is-hae-f))) x)))\n        ( ap B B (f x) (f y)\n          ( section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y\n          f ((first (second (first is-hae-f))) y)))\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x))\n          ( f x)\n          ( ((second (second (first is-hae-f)))) (f x)))\n        ( ap B B (f x) (f y)\n          ( section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ((second (second (first is-hae-f)))) (f y)))\n      ( ap B B (f x) (f y) (identity B) q)\n      ( triple-concat-higher-homotopy-is-half-adjoint-equiv x y q)\n      ( triple-concat-nat-htpy-is-half-adjoint-equiv x y q)\n#def triple-concat-reduction-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : ap B B (f x) (f y) (identity B) q = q\n  := ap-id B (f x) (f y) q\n#def section-htpy-ap-is-half-adjoint-equiv\n( x y : A)\n( q : f x = f y)\n  : ap A B x y f ((second (iff-ap-is-half-adjoint-equiv x y)) q) = q\n  :=\n    alternating-quintuple-concat (f x = f y)\n      ( ap A B x y f ((second (iff-ap-is-half-adjoint-equiv x y)) q))\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( ap A B x ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n          ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n            ( (first (second (first is-hae-f))) x)))\n        ( ap A B\n          ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n          ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y)) f\n          ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n          ( (first (second (first is-hae-f))) y)))\n      ( ap-triple-concat-is-half-adjoint-equiv x y q)\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n          ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n            ( (first (second (first is-hae-f))) x)))\n        ( ap A B\n          ( (map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n          ( (map-inverse-has-inverse A B f (first is-hae-f)) (f y)) f\n          ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n          ( (first (second (first is-hae-f))) y)))\n      ( ap-rev-triple-concat-eq-first-is-half-adjoint-equiv x y q)\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x))\n          ( f x)\n          ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n            ( (first (second (first is-hae-f))) x)))\n        ( ap B B (f x) (f y)\n          ( section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y\n          f ((first (second (first is-hae-f))) y)))\n      ( ap-ap-triple-concat-eq-first-is-half-adjoint-equiv x y q)\n      ( ap B B (f x) (f y) (identity B) q)\n      ( zag-zig-concat-triple-concat-is-half-adjoint-equiv x y q)\n      ( q)\n      ( triple-concat-reduction-is-half-adjoint-equiv x y q)\n#def has-section-ap-is-half-adjoint-equiv uses (is-hae-f)\n( x y : A)\n  : has-section (x = y) (f x = f y) (ap A B x y f)\n  :=\n    ( second (iff-ap-is-half-adjoint-equiv x y) ,\n      section-htpy-ap-is-half-adjoint-equiv x y)\n#def is-equiv-ap-is-half-adjoint-equiv uses (is-hae-f)\n( x y : A)\n  : is-equiv (x = y) (f x = f y) (ap A B x y f)\n  :=\n    ( has-retraction-ap-is-half-adjoint-equiv x y ,\n      has-section-ap-is-half-adjoint-equiv x y)\n#end equiv-identity-types-equiv\n#def is-emb-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : is-emb A B f\n  :=\n    is-equiv-ap-is-half-adjoint-equiv A B f\n    ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f)\n#def emb-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : Emb A B\n  := (f , is-emb-is-equiv A B f is-equiv-f)\n#def equiv-ap-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n( x y : A)\n  : Equiv (x = y) (f x = f y)\n  := (ap A B x y f , is-emb-is-equiv A B f is-equiv-f x y)\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#some-further-useful-coherences","title":"Some further useful coherences","text":"<p>We prove some further coherences from half-adjoint equivalences. Some of the lemmas below resemble lemmas from the section on embeddings.</p> <p>For a half-adjoint equivalence \\(f\\) with inverse \\(g\\) and coherence \\(G \u22c5 f \u223c \\text{ap}_f \u22c5 H\\) we show</p> \\[ \\text{ap}_f (H^{-1} a) \u22c5 G (f a) = \\texttt{refl}_{f (a)}. \\] <p>This is a consequence of cancelling the coherence on the left, and then applying the equality \\(\\text{ap}_f (H^{-1} a) = (\\text{ap}_f (H a))^{-1}\\). It is cumbersome to state and prove only becaues of data revtrieval and the number of reversals.</p> <pre><code>#def ap-rev-retr-htpy-concat-sec-htpy-is-refl-is-hae\n(A B : U)\n(f : A \u2192 B)\n(a : A)\n(b : B)\n(q : (f a) = b)\n(is-hae : is-half-adjoint-equiv A B f)\n  : (concat ( B)\n      ( f a)\n      ( f ((map-inverse-is-half-adjoint-equiv  A B f is-hae) (f a )))\n      ( f a)\n      (ap ( A) ( B)\n        ( a)\n        (((map-inverse-is-half-adjoint-equiv A B f is-hae) ( f a)))\n        ( f)\n        ( rev ( A)\n          ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n          ( a)\n          ((retraction-htpy-is-half-adjoint-equiv A B f is-hae) a)))\n      ( (section-htpy-is-half-adjoint-equiv A B f is-hae) (f a)))\n      = refl\n  :=\n  htpy-id-cancel-left-concat-left-eq\n  ( B)\n  (f a)\n  ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n  ( ap ( A) ( B)\n    ( a)\n    ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n    ( f)\n    (rev ( A)\n      (((map-inverse-is-half-adjoint-equiv A B f is-hae) ( f a)))\n      ( a)\n      ( (retraction-htpy-is-half-adjoint-equiv A B f is-hae) a)))\n  ( rev ( B)\n    ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n    ( f a)\n    ( ap ( A) ( B)\n      ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n      ( a)\n      ( f)\n      (( retraction-htpy-is-half-adjoint-equiv A B f is-hae) a) ))\n  ( ap-rev ( A) ( B)\n    (((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n    ( a)\n    ( f)\n    ( ( retraction-htpy-is-half-adjoint-equiv A B f is-hae) a))\n  ( (section-htpy-is-half-adjoint-equiv A B f is-hae) (f a))\n  ( cancel-left-path\n    ( B)\n    ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n    ( f a)\n    ( (section-htpy-is-half-adjoint-equiv A B f is-hae) (f a))\n    ( ( ap A B ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)) a f\n        (( retraction-htpy-is-half-adjoint-equiv A B f is-hae) a)))\n    ( ((coherence-is-half-adjoint-equiv A B f is-hae) a)))\n</code></pre> <p>Let \\(f : A \u2192 B\\) be an equivalence between \\(A\\) and \\(B\\). We prove that</p> \\[ \\text{ap}_f (H^-1 (a)) \u22c5 \\text{ap}_{f \u2218 g} (q) \u22c5 G (b) = q \\] <p>This expresses a relatively natural statement that if we start with \\(q: f (a) = b\\), apply \\(g\\) to get \\(\\text{ap}_g (q) : g (f (a)) = g(b)\\), precompose with \\(H (a)\\) to get</p> \\[ a = g(f(a)) = g(b) \\] <p>apply \\(g\\) and then postcompose with \\(G : f (g (b)) = b\\), the resulting path \\(f(a) = b\\) is equal to \\(q\\).</p> <p>An alternate proof could use <code>triple-concat-eq-first</code> and <code>triple-concat-nat-htpy</code>. The proofs do not end up much shorter.</p> <pre><code>#def id-conjugate-is-hae-ap-ap-is-hae\n( A B : U)\n( f : A \u2192 B)\n( a : A)\n( b : B)\n( q : (f a) = b)\n(is-hae : is-half-adjoint-equiv A B f)\n  :(concat ( B)\n    ( f a)\n    ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (b)))\n    ( b )\n    (concat ( B)\n      ( f a)\n      ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n      ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) b))\n      ( ap ( A) ( B) ( a)\n        ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n        ( f)\n        (rev ( A)\n          ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n          ( a)\n          ( (retraction-htpy-is-half-adjoint-equiv A B f is-hae) a)))\n      ( ap ( B) ( B) ( f a) ( b)\n        ( \\z \u2192 (f ((map-inverse-is-half-adjoint-equiv A B f is-hae) z)))\n        ( q)))\n    ( ( section-htpy-is-half-adjoint-equiv A B f is-hae) (b))) = q\n  :=\n  concat\n  ((f a) = b)\n  ((concat ( B)\n    ( f a)\n    ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (b)))\n    ( b )\n    (concat ( B)\n      ( f a)\n      ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n      ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) b))\n      ( ap ( A) ( B) ( a)\n        ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n        ( f)\n        (rev ( A)\n          ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n          ( a)\n          ( (retraction-htpy-is-half-adjoint-equiv A B f is-hae) a)))\n      ( ap ( B) ( B) ( f a) ( b)\n        ( \\z \u2192 (f ((map-inverse-is-half-adjoint-equiv A B f is-hae) z)))\n        ( q)))\n    ( ( section-htpy-is-half-adjoint-equiv A B f is-hae) (b))) )\n  ((ap B B (f a) b (identity B) q))\n  ( q)\n  (rev-eq-top-cancel-commutative-square'\n    ( B)\n    (f a)\n    ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (f a)))\n    ( f ((map-inverse-is-half-adjoint-equiv A B f is-hae)  b))\n    ( b)\n    (ap ( A) ( B)\n      ( a)\n      ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n      ( f)\n      ( rev ( A)\n        ( (map-inverse-is-half-adjoint-equiv A B f is-hae) (f a))\n        ( a)\n        ( (retraction-htpy-is-half-adjoint-equiv A B f is-hae) a)))\n    ((section-htpy-is-half-adjoint-equiv A B f is-hae) (f a))\n    (ap ( B) ( B) ( f a) ( b)\n      (\\z \u2192 (f ((map-inverse-is-half-adjoint-equiv A B f is-hae) z)))\n      ( q))\n    ( ap B B (f a) b (identity B) q )\n    ( (section-htpy-is-half-adjoint-equiv A B f is-hae) b)\n    (rev-nat-htpy ( B) ( B)\n      ( \\ x \u2192 f ((map-inverse-is-half-adjoint-equiv A B f is-hae) (x)))\n      ( identity B)\n      ( section-htpy-is-half-adjoint-equiv A B f is-hae)\n      ( f a)\n      ( b)\n      ( q))\n    ( ap-rev-retr-htpy-concat-sec-htpy-is-refl-is-hae A B f a b q is-hae))\n  (ap-id B (f a) b q )\n</code></pre>"},{"location":"hott/05-sigma.rzk/","title":"5. Sigma types","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>It is convenient to have a shorthand for <code>\u03a3 (x : A), B x</code> which avoids explicit naming the variable <code>x : A</code>.</p> <pre><code>#def total-type\n( A : U)\n( B : A \u2192 U)\n  : U\n  := \u03a3 (x : A), B x\n#def projection-total-type\n( A : U)\n( B : A \u2192 U)\n  : (total-type A B) \u2192 A\n  := \\ z \u2192 first z\n</code></pre>"},{"location":"hott/05-sigma.rzk/#paths-involving-products","title":"Paths involving products","text":"<pre><code>#section paths-in-products\n#variables A B : U\n#def path-product\n( a a' : A)\n( b b' : B)\n( e_A : a = a')\n( e_B : b = b')\n  : ( a , b) =_{product A B} (a' , b')\n  :=\n    transport A (\\ x \u2192 (a , b) =_{product A B} (x , b')) a a' e_A\n      ( transport B (\\ y \u2192 (a , b) =_{product A B} (a , y)) b b' e_B refl)\n#def first-path-product\n( x y : product A B)\n( e : x =_{product A B} y)\n  : first x = first y\n  := ap (product A B) A x y (\\ z \u2192 first z) e\n#def second-path-product\n( x y : product A B)\n( e : x =_{product A B} y)\n  : second x = second y\n  := ap (product A B) B x y (\\ z \u2192 second z) e\n#end paths-in-products\n</code></pre>"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types","title":"Identity types of Sigma types","text":"<pre><code>#section paths-in-sigma\n#variable A : U\n#variable B : A \u2192 U\n#def first-path-\u03a3\n( s t : \u03a3 (a : A) , B a)\n( e : s = t)\n  : first s = first t\n  := ap (\u03a3 (a : A) , B a) A s t (\\ z \u2192 first z) e\n#def second-path-\u03a3\n( s t : \u03a3 (a : A) , B a)\n( e : s = t)\n  : ( transport A B (first s) (first t) (first-path-\u03a3 s t e) (second s)) =\n    ( second t)\n  :=\n    ind-path\n( \u03a3 (a : A) , B a)\n      ( s)\n      ( \\ t' e' \u2192\n        ( transport A B\n          ( first s) (first t') (first-path-\u03a3 s t' e') (second s)) =\n        ( second t'))\n      ( refl)\n      ( t)\n      ( e)\n</code></pre> Rijke 22, Definition 9.3.1<pre><code>#def Eq-\u03a3\n( s t : \u03a3 (a : A) , B a)\n  : U\n  :=\n\u03a3 ( p : (first s) = (first t)) ,\n      ( transport A B (first s) (first t) p (second s)) = (second t)\n</code></pre> Rijke 22, Definition 9.3.3<pre><code>#def pair-eq\n( s t : \u03a3 (a : A) , B a)\n( e : s = t)\n  : Eq-\u03a3 s t\n  := (first-path-\u03a3 s t e , second-path-\u03a3 s t e)\n</code></pre> <p>A path in a fiber defines a path in the total space.</p> <pre><code>#def eq-eq-fiber-\u03a3\n( x : A)\n( u v : B x)\n( p : u = v)\n  : (x , u) =_{\u03a3 (a : A) , B a} (x , v)\n  := ind-path (B x) (u) (\\ v' p' \u2192 (x , u) = (x , v')) (refl) (v) (p)\n</code></pre> <p>The following is essentially <code>eq-pair</code> but with explicit arguments.</p> <pre><code>#def path-of-pairs-pair-of-paths\n( x y : A)\n( p : x = y)\n  : ( u : B x) \u2192\n( v : B y) \u2192\n    ( (transport A B x y p u) = v) \u2192\n    ( x , u) =_{\u03a3 (z : A) , B z} (y , v)\n  :=\n    ind-path\n      ( A)\n      ( x)\n( \\ y' p' \u2192 (u' : B x) \u2192 (v' : B y') \u2192\n        ((transport A B x y' p' u') = v') \u2192\n        (x , u') =_{\u03a3 (z : A) , B z} (y' , v'))\n      ( \\ u' v' q' \u2192 (eq-eq-fiber-\u03a3 x u' v' q'))\n      ( y)\n      ( p)\n</code></pre> The inverse to pair-eq<pre><code>#def eq-pair\n( s t : \u03a3 (a : A) , B a)\n( e : Eq-\u03a3 s t)\n  : (s = t)\n  :=\n    path-of-pairs-pair-of-paths\n      ( first s) (first t) (first e) (second s) (second t) (second e)\n#def eq-pair-pair-eq\n( s t : \u03a3 (a : A) , B a)\n( e : s = t)\n  : (eq-pair s t (pair-eq s t e)) = e\n  :=\n    ind-path\n( \u03a3 (a : A) , (B a))\n      ( s)\n      ( \\ t' e' \u2192 (eq-pair s t' (pair-eq s t' e')) = e')\n      ( refl)\n      ( t)\n      ( e)\n</code></pre> <p>Here we've decomposed <code>e : Eq-\u03a3 s t</code> as <code>(e0, e1)</code> and decomposed <code>s</code> and <code>t</code> similarly for induction purposes.</p> <pre><code>#def pair-eq-eq-pair-split\n( s0 : A)\n( s1 : B s0)\n( t0 : A)\n( e0 : s0 = t0)\n  : ( t1 : B t0) \u2192\n( e1 : (transport A B s0 t0 e0 s1) = t1) \u2192\n    ( ( pair-eq (s0 , s1) (t0 , t1) (eq-pair (s0 , s1) (t0 , t1) (e0 , e1)))\n      =_{Eq-\u03a3 (s0 , s1) (t0 , t1)}\n      ( e0 , e1))\n  :=\n    ind-path\n      ( A)\n      ( s0)\n( \\ t0' e0' \u2192\n        ( t1 : B t0') \u2192\n( e1 : (transport A B s0 t0' e0' s1) = t1) \u2192\n        ( pair-eq (s0 , s1) (t0' , t1) (eq-pair (s0 , s1) (t0' , t1) (e0' , e1)))\n        =_{Eq-\u03a3 (s0 , s1) (t0' , t1)}\n        ( e0' , e1))\n      ( ind-path\n        ( B s0)\n        ( s1)\n        ( \\ t1' e1' \u2192\n          ( pair-eq\n            ( s0 , s1)\n            ( s0 , t1')\n            ( eq-pair (s0 , s1) (s0 , t1') (refl , e1')))\n          =_{Eq-\u03a3 (s0 , s1) (s0 , t1')}\n          ( refl , e1'))\n        ( refl))\n      ( t0)\n      ( e0)\n#def pair-eq-eq-pair\n( s t : \u03a3 (a : A) , B a)\n( e : Eq-\u03a3 s t)\n  : ( pair-eq s t (eq-pair s t e)) =_{Eq-\u03a3 s t} e\n  :=\n    pair-eq-eq-pair-split\n      ( first s) (second s) (first t) (first e) (second t) (second e)\n#def extensionality-\u03a3\n( s t : \u03a3 (a : A) , B a)\n  : Equiv (s = t) (Eq-\u03a3 s t)\n  :=\n    ( pair-eq s t ,\n      ( ( eq-pair s t , eq-pair-pair-eq s t) ,\n        ( eq-pair s t , pair-eq-eq-pair s t)))\n#end paths-in-sigma\n#def first-path-\u03a3-eq-pair\n( A : U)\n( B : A \u2192 U)\n  ( (a,b) (a',b') : \u03a3 (a : A), B a)\n  ( (e0, e1) : Eq-\u03a3 A B (a,b) (a',b'))\n  : first-path-\u03a3 A B (a,b) (a',b') (eq-pair A B (a,b) (a',b') (e0, e1)) = e0\n  :=\n    first-path-\u03a3\n      ( a = a' )\n      ( \\ p \u2192 transport A B a a' p b = b' )\n      ( pair-eq A B (a,b) (a',b') (eq-pair A B (a,b) (a',b') (e0,e1)) )\n      ( e0, e1 )\n      ( pair-eq-eq-pair A B (a,b) (a',b') (e0,e1))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types-over-a-product","title":"Identity types of Sigma types over a product","text":"<pre><code>#section paths-in-sigma-over-product\n#variables A B : U\n#variable C : A \u2192 B \u2192 U\n#def product-transport\n( a a' : A)\n( b b' : B)\n( p : a = a')\n( q : b = b')\n( c : C a b)\n  : C a' b'\n  :=\n    ind-path\n      ( B)\n      ( b)\n      ( \\ b'' q' \u2192 C a' b'')\n      ( ind-path (A) (a) (\\ a'' p' \u2192 C a'' b) (c) (a') (p))\n      ( b')\n      ( q)\n#def Eq-\u03a3-over-product\n( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  : U\n  :=\n\u03a3 ( p : (first s) = (first t)) ,\n( \u03a3 ( q : (first (second s)) = (first (second t))) ,\n          ( product-transport\n            ( first s) (first t)\n            ( first (second s)) (first (second t)) p q (second (second s)) =\n            ( second (second t))))\n</code></pre> <p>Warning</p> <p>The following definition of <code>triple-eq</code> is the lazy definition with bad computational properties.</p> <pre><code>#def triple-eq\n( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( e : s = t)\n  : Eq-\u03a3-over-product s t\n  :=\n    ind-path\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n      ( s)\n      ( \\ t' e' \u2192 (Eq-\u03a3-over-product s t'))\n      ( ( refl , (refl , refl)))\n      ( t)\n      ( e)\n</code></pre> <p>It's surprising that the following typechecks since we defined product-transport by a dual path induction over both <code>p</code> and <code>q</code>, rather than by saying that when <code>p</code> is <code>refl</code> this is ordinary transport.</p> The inverse with explicit arguments<pre><code>#def triple-of-paths-path-of-triples\n( a a' : A)\n( u u' : B)\n( c : C a u)\n( p : a = a')\n  : ( q : u = u') \u2192\n( c' : C a' u') \u2192\n( r : product-transport a a' u u' p q c = c') \u2192\n    ( (a , (u , c)) =_{(\u03a3 (x : A) , (\u03a3 (y : B) , C x y))} (a' , (u' , c')))\n  :=\n    ind-path\n      ( A)\n      ( a)\n( \\ a'' p' \u2192\n        ( q : u = u') \u2192\n( c' : C a'' u') \u2192\n( r : product-transport a a'' u u' p' q c = c') \u2192\n        ( (a , (u , c)) =_{(\u03a3 (x : A) , (\u03a3 (y : B) , C x y))} (a'' , (u' , c'))))\n      ( \\ q c' r \u2192\n        eq-eq-fiber-\u03a3\n          ( A) (\\ x \u2192 (\u03a3 (v : B) , C x v)) (a)\n          ( u , c) ( u' , c')\n          ( path-of-pairs-pair-of-paths B (\\ y \u2192 C a y) u u' q c c' r))\n      ( a')\n      ( p)\n#def eq-triple\n( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( e : Eq-\u03a3-over-product s t)\n  : (s = t)\n  :=\n    triple-of-paths-path-of-triples\n    ( first s) (first t)\n    ( first (second s)) (first (second t))\n    ( second (second s)) (first e)\n    ( first (second e)) (second (second t))\n    ( second (second e))\n#def eq-triple-triple-eq\n( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( e : s = t)\n  : (eq-triple s t (triple-eq s t e)) = e\n  :=\n    ind-path\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n      ( s)\n      ( \\ t' e' \u2192 (eq-triple s t' (triple-eq s t' e')) = e')\n      ( refl)\n      ( t)\n      ( e)\n</code></pre> <p>Here we've decomposed <code>s</code>, <code>t</code> and <code>e</code> for induction purposes:</p> <pre><code>#def triple-eq-eq-triple-split\n( a a' : A)\n( b b' : B)\n( c : C a b)\n  : ( p : a = a') \u2192\n( q : b = b') \u2192\n( c' : C a' b') \u2192\n( r : product-transport a a' b b' p q c = c') \u2192\n    ( triple-eq\n      ( a , (b , c)) (a' , (b' , c'))\n      ( eq-triple (a , (b , c)) (a' , (b' , c')) (p , (q , r)))) =\n    ( p , (q , r))\n  :=\n    ind-path\n      ( A)\n      ( a)\n( \\ a'' p' \u2192\n        ( q : b = b') \u2192\n( c' : C a'' b') \u2192\n( r : product-transport a a'' b b' p' q c = c') \u2192\n        ( triple-eq\n          ( a , (b , c)) (a'' , (b' , c'))\n          ( eq-triple (a , (b , c)) (a'' , (b' , c')) (p' , (q , r)))) =\n        ( p' , (q , r)))\n      ( ind-path\n        ( B)\n        ( b)\n( \\ b'' q' \u2192\n          ( c' : C a b'') \u2192\n( r : product-transport a a b b'' refl q' c = c') \u2192\n          ( triple-eq\n            ( a , (b , c)) (a , (b'' , c'))\n            ( eq-triple (a , (b , c)) (a , (b'' , c')) (refl , (q' , r)))) =\n          ( refl , (q' , r)))\n        ( ind-path\n            ( C a b)\n            ( c)\n            ( \\ c'' r' \u2192\n              triple-eq\n                ( a , (b , c)) (a , (b , c''))\n                ( eq-triple\n                  ( a , (b , c)) (a , (b , c''))\n                  ( refl , (refl , r'))) =\n                ( refl , (refl , r')))\n            ( refl))\n        ( b'))\n      ( a')\n#def triple-eq-eq-triple\n( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( e : Eq-\u03a3-over-product s t)\n  : (triple-eq s t (eq-triple s t e)) = e\n  :=\n    triple-eq-eq-triple-split\n      ( first s) (first t)\n      ( first (second s)) (first (second t))\n      ( second (second s)) (first e)\n      ( first (second e)) (second (second t))\n      ( second (second e))\n#def extensionality-\u03a3-over-product\n( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  : Equiv (s = t) (Eq-\u03a3-over-product s t)\n  :=\n    ( triple-eq s t ,\n      ( ( eq-triple s t , eq-triple-triple-eq s t) ,\n        ( eq-triple s t , triple-eq-eq-triple s t)))\n#end paths-in-sigma-over-product\n</code></pre>"},{"location":"hott/05-sigma.rzk/#symmetry-of-products","title":"Symmetry of products","text":"<pre><code>#def sym-product\n( A B : U)\n  : Equiv (product A B) (product B A)\n  :=\n    ( \\ (a , b) \u2192 (b , a) ,\n      ( ( \\ (b , a) \u2192 (a , b) ,\\ p \u2192 refl) ,\n        ( \\ (b , a) \u2192 (a , b) ,\\ p \u2192 refl)))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#fubini","title":"Fubini","text":"<p>Given a family over a pair of independent types, the order of summation is unimportant.</p> <pre><code>#def fubini-\u03a3\n( A B : U)\n( C : A \u2192 B \u2192 U)\n  : Equiv ( \u03a3 (x : A) , \u03a3 (y : B) , C x y) (\u03a3 (y : B) , \u03a3 (x : A) , C x y)\n  :=\n    ( \\ t \u2192 (first (second t) , (first t , second (second t))) ,\n      ( ( \\ t \u2192 (first (second t) , (first t , second (second t))) ,\n\\ t \u2192 refl) ,\n        ( \\ t \u2192 (first (second t) , (first t , second (second t))) ,\n\\ t \u2192 refl)))\n</code></pre> Products distribute inside Sigma types<pre><code>#def distributive-product-\u03a3\n( A B : U)\n( C : B \u2192 U)\n  : Equiv (product A (\u03a3 (b : B) , C b)) (\u03a3 (b : B) , product A (C b))\n  :=\n    ( \\ (a , (b , c)) \u2192 (b , (a , c)) ,\n      ( ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl) ,\n        ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl)))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#associativity","title":"Associativity","text":"<pre><code>#def associative-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (a : A) \u2192 B a \u2192 U)\n  : Equiv\n( \u03a3 (a : A) , \u03a3 (b : B a) , C a b)\n( \u03a3 (ab : \u03a3 (a : A) , B a) , C (first ab) (second ab))\n  :=\n    ( \\ (a , (b , c)) \u2192 ((a , b) , c) ,\n      ( ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl) ,\n        ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl)))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#currying","title":"Currying","text":"<p>This is the dependent version of the currying equivalence.</p> <pre><code>#def equiv-dependent-curry\n( A : U)\n( B : A \u2192 U)\n( C : (a : A) \u2192 B a \u2192 U)\n  : Equiv\n((p : \u03a3 (a : A) , (B a)) \u2192 C (first p) (second p))\n((a : A) \u2192 (b : B a) \u2192 C a b)\n  :=\n    ( ( \\ s a b \u2192 s (a , b)) ,\n      ( ( ( \\ f (a , b) \u2192 f a b ,\n\\ f \u2192 refl) ,\n          ( \\ f (a , b) \u2192 f a b ,\n\\ s \u2192 refl))))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#type-theoretic-principle-of-choice","title":"Type theoretic principle of choice","text":"Rijke 22, Theorem 13.2.1<pre><code>#def choice\n( A : U)\n( B : A \u2192 U)\n( C : (x : A) \u2192 B x \u2192 U)\n  : ( (x : A) \u2192 \u03a3 (y : B x) , C x y) \u2192\n( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x))\n  := \\ h \u2192 (\\ x \u2192 first (h x) , \\ x \u2192 second (h x))\n#def choice-inverse\n( A : U)\n( B : A \u2192 U)\n( C : (x : A) \u2192 B x \u2192 U)\n  : ( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x)) \u2192\n( (x : A) \u2192 \u03a3 (y : B x) , C x y)\n  := \\ s \u2192 \\ x \u2192 ((first s) x , (second s) x)\n#def is-equiv-choice\n( A : U)\n( B : A \u2192 U)\n( C : (x : A) \u2192 B x \u2192 U)\n  : is-equiv\n( (x : A) \u2192 \u03a3 (y : B x) , C x y)\n( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x))\n      ( choice A B C)\n  :=\n    is-equiv-has-inverse\n( (x : A) \u2192 \u03a3 (y : B x) , C x y)\n( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x))\n      ( choice A B C)\n      ( choice-inverse A B C , ( \\ h \u2192 refl , \\ s \u2192 refl))\n#def equiv-choice\n( A : U)\n( B : A \u2192 U)\n( C : (x : A) \u2192 B x \u2192 U)\n  : Equiv\n( (x : A) \u2192 \u03a3 (y : B x) , C x y)\n( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x))\n  := (choice A B C , is-equiv-choice A B C)\n#def inv-equiv-choice\n( A : U)\n( B : A \u2192 U)\n( C : (x : A) \u2192 B x \u2192 U)\n  : Equiv\n( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x))\n( (x : A) \u2192 \u03a3 (y : B x) , C x y)\n  :=\n  inv-equiv\n( (x : A) \u2192 \u03a3 (y : B x) , C x y)\n( \u03a3 ( f : (x : A) \u2192 B x) , (x : A) \u2192 C x (f x))\n  ( equiv-choice A B C)\n</code></pre>"},{"location":"hott/06-contractible.rzk/","title":"6. Contractible","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/06-contractible.rzk/#contractible-types","title":"Contractible types","text":"The type of contractibility proofs<pre><code>#def is-contr (A : U) : U\n  := \u03a3 (x : A) , ((y : A) \u2192 x = y)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#contractible-type-data","title":"Contractible type data","text":"<pre><code>#section contractible-data\n#variable A : U\n#variable is-contr-A : is-contr A\n#def center-contraction\n  : A\n  := (first is-contr-A)\n</code></pre> The path from the contraction center to any point<pre><code>#def homotopy-contraction\n  : ( z : A) \u2192 center-contraction = z\n  := second is-contr-A\n#def realign-homotopy-contraction uses (is-contr-A)\n  : ( z : A) \u2192 center-contraction = z\n  :=\n\\ z \u2192\n      ( concat A center-contraction center-contraction z\n          (rev A center-contraction center-contraction\n            ( homotopy-contraction center-contraction))\n          (homotopy-contraction z))\n#def path-realign-homotopy-contraction uses (is-contr-A)\n  : ( realign-homotopy-contraction center-contraction) = refl\n  :=\n    ( left-inverse-concat A center-contraction center-contraction\n      ( homotopy-contraction center-contraction))\n</code></pre> A path between any pair of terms in a contractible type<pre><code>#def all-elements-equal-is-contr uses (is-contr-A)\n(x y : A)\n  : x = y\n  :=\n    zag-zig-concat A x center-contraction y\n      ( homotopy-contraction x) (homotopy-contraction y)\n#end contractible-data\n</code></pre>"},{"location":"hott/06-contractible.rzk/#unit-type","title":"Unit type","text":"<p>The prototypical contractible type is the unit type, which is built-in to rzk.</p> <pre><code>#def ind-unit\n( C : Unit \u2192 U)\n( C-unit : C unit)\n( x : Unit)\n  : C x\n  := C-unit\n#def is-contr-Unit\n  : is-contr Unit\n  := (unit, \\ _ \u2192 refl)\n</code></pre> The terminal projection as a constant map<pre><code>#def terminal-map\n( A : U)\n  : A \u2192 Unit\n  := constant A Unit unit\n</code></pre>"},{"location":"hott/06-contractible.rzk/#identity-types-of-unit-types","title":"Identity types of unit types","text":"<pre><code>#def has-retraction-terminal-map-path-types-Unit\n( x y : Unit)\n  : has-retraction (x = y) Unit (terminal-map (x = y))\n  :=\n    ( \\ a \u2192 refl ,\n\\ p \u2192 ind-path (Unit) (x) (\\ y' p' \u2192 refl =_{x = y'} p') (refl) (y) (p))\n#def has-section-terminal-map-path-types-Unit\n( x y : Unit)\n  : has-section (x = y) Unit (terminal-map (x = y))\n  := ( \\ a \u2192 refl , \\ a \u2192 refl)\n#def is-equiv-terminal-map-path-types-Unit\n( x y : Unit)\n  : is-equiv (x = y) Unit (terminal-map (x = y))\n  :=\n    ( has-retraction-terminal-map-path-types-Unit x y ,\n      has-section-terminal-map-path-types-Unit x y)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#characterization-of-contractibility","title":"Characterization of contractibility","text":"<p>A type is contractible if and only if its terminal map is an equivalence.</p> <pre><code>#def terminal-map-is-equiv\n( A : U)\n  : U\n  := is-equiv A Unit (terminal-map A)\n#def has-retraction-terminal-map-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n  : has-retraction A Unit (terminal-map A)\n  :=\n    ( constant Unit A (center-contraction A is-contr-A) ,\n\\ y \u2192 (homotopy-contraction A is-contr-A) y)\n#def has-section-terminal-map-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n  : has-section A Unit (terminal-map A)\n  := ( constant Unit A (center-contraction A is-contr-A) , \\ z \u2192 refl)\n#def is-equiv-terminal-map-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n  : is-equiv A Unit (terminal-map A)\n  :=\n    ( has-retraction-terminal-map-is-contr A is-contr-A ,\n      has-section-terminal-map-is-contr A is-contr-A)\n#def is-contr-is-equiv-terminal-map\n( A : U)\n(e : terminal-map-is-equiv A)\n  : is-contr A\n  := ( (first (first e)) unit , (second (first e)))\n#def is-equiv-terminal-map-iff-is-contr\n( A : U)\n  : iff (is-contr A) (terminal-map-is-equiv A)\n  :=\n    ( ( is-equiv-terminal-map-is-contr A) ,\n      ( is-contr-is-equiv-terminal-map A))\n#def equiv-with-contractible-domain-implies-contractible-codomain\n( A B : U)\n( f : Equiv A B)\n( is-contr-A : is-contr A)\n  : is-contr B\n  :=\n    ( is-contr-is-equiv-terminal-map B\n      ( second\n        ( equiv-comp B A Unit\n          ( inv-equiv A B f)\n          ( ( terminal-map A) ,\n            ( is-equiv-terminal-map-is-contr A is-contr-A)))))\n#def is-contr-path-types-Unit\n( x y : Unit)\n  : is-contr (x = y)\n  :=\n    ( is-contr-is-equiv-terminal-map\n      ( x = y) (is-equiv-terminal-map-path-types-Unit x y))\n</code></pre>"},{"location":"hott/06-contractible.rzk/#retracts-of-contractible-types","title":"Retracts of contractible types","text":"<p>A retract of contractible types is contractible.</p> If A is a retract of a contractible type it has a term<pre><code>#section is-contr-is-retract-of-is-contr\n#variables A B : U\n#variable is-retr-of-A-B : is-retract-of A B\n#def is-inhabited-is-contr-is-retract-of uses (is-retr-of-A-B)\n( is-contr-B : is-contr B)\n  : A\n  :=\n    retraction-is-retract-of A B is-retr-of-A-B\n    ( center-contraction B is-contr-B)\n</code></pre> If A is a retract of a contractible type it has a contracting homotopy<pre><code>#def has-homotopy-is-contr-is-retract-of uses (is-retr-of-A-B)\n( is-contr-B : is-contr B)\n( a : A)\n  : ( is-inhabited-is-contr-is-retract-of is-contr-B) = a\n  :=\n    concat\n      ( A)\n      ( is-inhabited-is-contr-is-retract-of is-contr-B)\n      ( comp A B A\n        ( retraction-is-retract-of A B is-retr-of-A-B)\n        ( section-is-retract-of A B is-retr-of-A-B)\n        ( a))\n      ( a)\n      ( ap B A\n        ( center-contraction B is-contr-B)\n        ( section-is-retract-of A B is-retr-of-A-B a)\n        ( retraction-is-retract-of A B is-retr-of-A-B)\n        ( homotopy-contraction B is-contr-B\n          ( section-is-retract-of A B is-retr-of-A-B a)))\n      ( homotopy-is-retract-of A B is-retr-of-A-B a)\n</code></pre> If A is a retract of a contractible type it is contractible<pre><code>#def is-contr-is-retract-of-is-contr uses (is-retr-of-A-B)\n( is-contr-B : is-contr B)\n  : is-contr A\n  :=\n    ( is-inhabited-is-contr-is-retract-of is-contr-B ,\n      has-homotopy-is-contr-is-retract-of is-contr-B)\n#end is-contr-is-retract-of-is-contr\n</code></pre> <pre><code>\n</code></pre>"},{"location":"hott/06-contractible.rzk/#functions-between-contractible-types","title":"Functions between contractible types","text":"Any function between contractible types is an equivalence<pre><code>#def is-equiv-are-contr\n( A B : U)\n( is-contr-A : is-contr A)\n( is-contr-B : is-contr B)\n( f : A \u2192 B)\n  : is-equiv A B f\n  :=\n    ( ( \\ b \u2192 center-contraction A is-contr-A ,\n\\ a \u2192 homotopy-contraction A is-contr-A a) ,\n      ( \\ b \u2192 center-contraction A is-contr-A ,\n\\ b \u2192 all-elements-equal-is-contr B is-contr-B\n                (f (center-contraction A is-contr-A)) b))\n</code></pre> A type equivalent to a contractible type is contractible<pre><code>#def is-contr-equiv-is-contr'\n( A B : U)\n( e : Equiv A B)\n( is-contr-B : is-contr B)\n  : is-contr A\n  :=\n    is-contr-is-retract-of-is-contr A B (first e , first (second e)) is-contr-B\n#def is-contr-equiv-is-contr\n( A B : U)\n( e : Equiv A B)\n( is-contr-A : is-contr A)\n  : is-contr B\n  :=\n    is-contr-is-retract-of-is-contr B A\n      ( first (second (second e)) , (first e , second (second (second e))))\n      ( is-contr-A)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#based-path-spaces","title":"Based path spaces","text":"<p>For example, we prove that based path spaces are contractible.</p> Transport in the space of paths starting at a is concatenation<pre><code>#def concat-as-based-transport\n( A : U)\n( a x y : A)\n( p : a = x)\n( q : x = y)\n  : ( transport A (\\ z \u2192 (a = z)) x y q p) = (concat A a x y p q)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' q' \u2192\n        ( transport A (\\ z \u2192 (a = z)) x y' q' p) = (concat A a x y' p q'))\n      ( refl)\n      ( y)\n      ( q)\n</code></pre> <p>The center of contraction in the based path space is <code>(a , refl)</code>.</p> The center of contraction in the based path space<pre><code>#def center-based-paths\n( A : U)\n( a : A)\n  : \u03a3 (x : A) , (a = x)\n  := (a , refl)\n</code></pre> The contracting homotopy in the based path space<pre><code>#def contraction-based-paths\n( A : U)\n( a : A)\n( p : \u03a3 (x : A) , a = x)\n  : (center-based-paths A a) = p\n  :=\n    path-of-pairs-pair-of-paths\n      A ( \\ z \u2192 a = z) a (first p) (second p) (refl) (second p)\n      ( concat\n        ( a = (first p))\n        ( transport A (\\ z \u2192 (a = z)) a (first p) (second p) (refl))\n        ( concat A a a (first p) (refl) (second p))\n        ( second p)\n        ( concat-as-based-transport A a a (first p) (refl) (second p))\n        ( left-unit-concat A a (first p) (second p)))\n</code></pre> Based path spaces are contractible<pre><code>#def is-contr-based-paths\n( A : U)\n( a : A)\n  : is-contr (\u03a3 (x : A) , a = x)\n  := (center-based-paths A a , contraction-based-paths A a)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#contractible-products","title":"Contractible products","text":"<pre><code>#def is-contr-product\n( A B : U)\n( is-contr-A : is-contr A)\n( is-contr-B : is-contr B)\n  : is-contr (product A B)\n  :=\n    ( (first is-contr-A , first is-contr-B) ,\n\\ p \u2192 path-product A B\n              ( first is-contr-A) (first p)\n              ( first is-contr-B) (second p)\n              ( second is-contr-A (first p))\n              ( second is-contr-B (second p)))\n#def first-is-contr-product\n( A B : U)\n( AxB-is-contr : is-contr (product A B))\n  : is-contr A\n  :=\n    ( first (first AxB-is-contr) ,\n\\ a \u2192 first-path-product A B\n              ( first AxB-is-contr)\n              ( a , second (first AxB-is-contr))\n              ( second AxB-is-contr (a , second (first AxB-is-contr))))\n#def is-contr-base-is-contr-\u03a3\n( A : U)\n( B : A \u2192 U)\n( b : (a : A) \u2192 B a)\n( is-contr-AB : is-contr (\u03a3 (a : A) , B a))\n  : is-contr A\n  :=\n    ( first (first is-contr-AB) ,\n\\ a \u2192 first-path-\u03a3 A B\n              ( first is-contr-AB)\n              ( a , b a)\n              ( second is-contr-AB (a , b a)))\n</code></pre>"},{"location":"hott/06-contractible.rzk/#weak-function-extensionality","title":"Weak function extensionality","text":"<p>The weak function extensionality axiom asserts that if a dependent type is locally contractible then its dependent function type is contractible.</p> <p>Weak function extensionality is logically equivalent to function extensionality. However, for various applications it may be useful to have it stated as a separate hypothesis.</p> Weak function extensionality gives us contractible pi types<pre><code>#def WeakFunExt : U\n  :=\n( A : U ) \u2192 (C : A \u2192 U) \u2192\n(is-contr-C : (a : A) \u2192 is-contr (C a) ) \u2192\n(is-contr ( (a : A) \u2192 C a ))\n</code></pre> <p>Function extensionality implies weak function extensionality.</p> <pre><code>#def map-weakfunext\n(A : U)\n(C : A \u2192 U)\n(is-contr-C : (a : A) \u2192 is-contr (C a))\n  : (a : A) \u2192 C a\n  :=\n\\ a \u2192 first (is-contr-C a)\n#def weakfunext-funext\n(funext : FunExt)\n  : WeakFunExt\n  :=\n\\ A C is-contr-C \u2192\n  ( map-weakfunext A C is-contr-C ,\n    ( \\ g \u2192\n      ( eq-htpy funext\n        ( A)\n        ( C)\n        ( map-weakfunext A C is-contr-C)\n        ( g)\n        ( \\ a \u2192 second (is-contr-C a) (g a)))))\n</code></pre>"},{"location":"hott/06-contractible.rzk/#singleton-induction","title":"Singleton induction","text":"<p>A type is contractible if and only if it has singleton induction.</p> <pre><code>#def ev-pt\n( A : U)\n( a : A)\n( B : A \u2192 U)\n  : ((x : A) \u2192 B x) \u2192 B a\n  := \\ f \u2192 f a\n#def has-singleton-induction-pointed\n( A : U)\n( a : A)\n( B : A \u2192 U)\n  : U\n  := has-section ((x : A) \u2192 B x) (B a) (ev-pt A a B)\n#def has-singleton-induction-pointed-structure\n( A : U)\n( a : A)\n  : U\n  := ( B : A \u2192 U) \u2192 has-section ((x : A) \u2192 B x) (B a) (ev-pt A a B)\n#def has-singleton-induction\n( A : U)\n  : U\n  := \u03a3 ( a : A) , (B : A \u2192 U) \u2192 (has-singleton-induction-pointed A a B)\n#def ind-sing\n( A : U)\n( a : A)\n( B : A \u2192 U)\n(singleton-ind-A : has-singleton-induction-pointed A a B)\n  : (B a) \u2192 ((x : A) \u2192 B x)\n  := ( first singleton-ind-A)\n#def compute-ind-sing\n( A : U)\n( a : A)\n( B : A \u2192 U)\n( singleton-ind-A : has-singleton-induction-pointed A a B)\n  : ( homotopy\n      ( B a)\n      ( B a)\n      ( comp\n        ( B a)\n( (x : A) \u2192 B x)\n        ( B a)\n        ( ev-pt A a B)\n        ( ind-sing A a B singleton-ind-A))\n      ( identity (B a)))\n  := (second singleton-ind-A)\n#def contr-implies-singleton-induction-ind\n( A : U)\n( is-contr-A : is-contr A)\n  : (has-singleton-induction A)\n  :=\n    ( ( center-contraction A is-contr-A) ,\n\\ B \u2192\n        ( ( \\ b x \u2192\n                ( transport A B\n                  ( center-contraction A is-contr-A) x\n                  ( realign-homotopy-contraction A is-contr-A x) b)) ,\n          ( \\ b \u2192\n                ( ap\n                  ( (center-contraction A is-contr-A) =\n                    (center-contraction A is-contr-A))\n                  ( B (center-contraction A is-contr-A))\n                  ( realign-homotopy-contraction A is-contr-A\n                    ( center-contraction A is-contr-A))\nrefl_{(center-contraction A is-contr-A)}\n                  ( \\ p \u2192\n                    ( transport-loop A B (center-contraction A is-contr-A) b p))\n                  ( path-realign-homotopy-contraction A is-contr-A)))))\n#def contr-implies-singleton-induction-pointed\n( A : U)\n( is-contr-A : is-contr A)\n( B : A \u2192 U)\n  : has-singleton-induction-pointed A (center-contraction A is-contr-A) B\n  := ( second (contr-implies-singleton-induction-ind A is-contr-A)) B\n#def singleton-induction-ind-implies-contr\n( A : U)\n( a : A)\n( f : has-singleton-induction-pointed-structure A a)\n  : ( is-contr A)\n  := ( a , (first (f ( \\ x \u2192 a = x))) (refl_{a}))\n</code></pre>"},{"location":"hott/06-contractible.rzk/#identity-types-of-contractible-types","title":"Identity types of contractible types","text":"<p>We show that any two paths between the same endpoints in a contractible type are the same.</p> <p>In a contractible type any path \\(p : x = y\\) is equal to the path constructed in <code>all-elements-equal-is-contr</code>.</p> <pre><code>#define path-eq-path-through-center-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n( x y : A)\n( p : x = y)\n  : ((all-elements-equal-is-contr A is-contr-A x y) = p)\n  :=\n    ind-path\n    ( A)\n    ( x)\n    ( \\ y' p' \u2192 (all-elements-equal-is-contr A is-contr-A x y') = p')\n    ( left-inverse-concat A (center-contraction A is-contr-A) x (homotopy-contraction A is-contr-A x))\n    ( y)\n    ( p)\n</code></pre> <p>Finally, in a contractible type any two paths between the same end points are equal. There are many possible proofs of this (e.g. identifying contractible types with the unit type where it is more transparent), but we proceed by gluing together the two identifications to the out and back path.</p> <pre><code>#define all-paths-equal-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n( x y : A)\n( p q : x = y)\n : (p = q)\n :=\n  concat\n    ( x = y)\n    ( p)\n    ( all-elements-equal-is-contr A is-contr-A x y)\n    ( q)\n    ( rev\n      (x = y)\n      ( all-elements-equal-is-contr A is-contr-A x y)\n      ( p)\n      ( path-eq-path-through-center-is-contr A is-contr-A x y p))\n    ( path-eq-path-through-center-is-contr A is-contr-A x y q)\n</code></pre>"},{"location":"hott/07-fibers.rzk/","title":"7. Fibers","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/07-fibers.rzk/#fibers","title":"Fibers","text":"<p>The homotopy fiber of a map is the following type:</p> The fiber of a map<pre><code>#def fib\n( A B : U)\n( f : A \u2192 B)\n( b : B)\n  : U\n  := \u03a3 (a : A) , (f a) = b\n#def rev-fib\n( A B : U)\n( f : A \u2192 B)\n( b : B)\n  : U\n  := \u03a3 (a : A) , b = (f a)\n</code></pre> <p>We calculate the transport of <code>(a , q) : fib b</code> along <code>p : a = a'</code>:</p> <pre><code>#def transport-in-fiber\n( A B : U)\n( f : A \u2192 B)\n( b : B)\n( a a' : A)\n( u : (f a) = b)\n( p : a = a')\n  : ( transport A ( \\ x \u2192 (f x) = b) a a' p u) =\n    ( concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u)\n  :=\n    ind-path\n      ( A)\n      ( a)\n      ( \\ a'' p' \u2192\n        ( transport (A) (\\ x \u2192 (f x) = b) (a) (a'') (p') (u)) =\n        ( concat (B) (f a'') (f a) (b) (ap A B a'' a f (rev A a a'' p')) (u)))\n      ( rev\n        ( (f a) = b) (concat B (f a) (f a) b refl u) (u)\n        ( left-unit-concat B (f a) b u))\n      ( a')\n      ( p)\n</code></pre>"},{"location":"hott/07-fibers.rzk/#induction-principle-for-fibers","title":"Induction principle for fibers","text":"<p>The family of fibers has the following induction principle: To prove/construct something about/for every point in every fiber, it suffices to do so for points of the form <code>(a, refl : f a = f a) : fib A B f</code>.</p> <pre><code>#def ind-fib\n( A B : U)\n( f : A \u2192 B)\n( C : (b : B) \u2192 fib A B f b \u2192 U)\n( s : (a : A) \u2192 C (f a) (a, refl))\n( b : B)\n  ( (a, q) : fib A B f b)\n  : C b (a, q)\n  :=\n    ind-path B (f a) (\\ b p \u2192 C b (a, p)) (s a) b q\n#def ind-rev-fib\n( A B : U)\n( f : A \u2192 B)\n( C : (b : B) \u2192 rev-fib A B f b \u2192 U)\n( s : (a : A) \u2192 C (f a) (a, refl))\n( b : B)\n  ( (a, q) : rev-fib A B f b)\n  : C b (a, q)\n  :=\n    ind-path-end B (f a) (\\ b p \u2192 C b (a, p)) (s a) b q\n#def compute-ind-fib\n( A B : U)\n( f : A \u2192 B)\n( C : (b : B) \u2192 fib A B f b \u2192 U)\n( s : (a : A) \u2192 C (f a) (a, refl))\n( a : A)\n  : ind-fib A B f C s (f a) (a, refl) = s a\n  := refl\n</code></pre>"},{"location":"hott/07-fibers.rzk/#contractible-maps","title":"Contractible maps","text":"<p>A map is contractible just when its fibers are contractible.</p> Contractible maps<pre><code>#def is-contr-map\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := (b : B) \u2192 is-contr (fib A B f b)\n</code></pre>"},{"location":"hott/07-fibers.rzk/#contractible-maps-are-equivalences","title":"Contractible maps are equivalences","text":"<p>Contractible maps are equivalences:</p> <pre><code>#section is-equiv-is-contr-map\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-contr-f : is-contr-map A B f\n</code></pre> The inverse to a contractible map<pre><code>#def is-contr-map-inverse\n  : B \u2192 A\n  := \\ b \u2192 first (center-contraction (fib A B f b) (is-contr-f b))\n#def has-section-is-contr-map\n  : has-section A B f\n  :=\n    ( is-contr-map-inverse ,\n\\ b \u2192 second (center-contraction (fib A B f b) (is-contr-f b)))\n#def is-contr-map-data-in-fiber uses (is-contr-f)\n(a : A)\n  : fib A B f (f a)\n  := (is-contr-map-inverse (f a) , (second has-section-is-contr-map) (f a))\n#def is-contr-map-path-in-fiber\n(a : A)\n  : (is-contr-map-data-in-fiber a) =_{fib A B f (f a)} (a , refl)\n  :=\n    all-elements-equal-is-contr\n      ( fib A B f (f a))\n      ( is-contr-f (f a))\n      ( is-contr-map-data-in-fiber a)\n      ( a , refl)\n#def is-contr-map-has-retraction uses (is-contr-f)\n  : has-retraction A B f\n  :=\n    ( is-contr-map-inverse ,\n\\ a \u2192 ( ap (fib A B f (f a)) A\n                ( is-contr-map-data-in-fiber a)\n                ( (a , refl))\n                ( \\ u \u2192 first u)\n                ( is-contr-map-path-in-fiber a)))\n#def is-equiv-is-contr-map uses (is-contr-f)\n  : is-equiv A B f\n  := (is-contr-map-has-retraction , has-section-is-contr-map)\n#end is-equiv-is-contr-map\n</code></pre>"},{"location":"hott/07-fibers.rzk/#half-adjoint-equivalences-are-contractible-maps","title":"Half adjoint equivalences are contractible maps","text":"<p>We prove the converse by fiber induction. To define the contracting homotopy to the point <code>(f a, refl)</code> in the fiber over <code>f a</code> we find it easier to work from the assumption that <code>f</code> is a half adjoint equivalence.</p> <pre><code>#section is-contr-map-is-equiv\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-hae-f : is-half-adjoint-equiv A B f\n#def is-split-surjection-is-half-adjoint-equiv\n( b : B)\n  : fib A B f b\n  :=\n    ( map-inverse-is-half-adjoint-equiv A B f is-hae-f b,\n      section-htpy-is-half-adjoint-equiv A B f is-hae-f b)\n#def calculate-is-split-surjection-is-half-adjoint-equiv\n( a : A)\n  : is-split-surjection-is-half-adjoint-equiv (f a) = (a, refl)\n  :=\n    path-of-pairs-pair-of-paths\n    ( A)\n    ( \\ a' \u2192 f a' = f a)\n    ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n    ( a)\n    ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)\n    ( section-htpy-is-half-adjoint-equiv A B f is-hae-f (f a))\n    ( refl)\n    ( triple-concat\n      ( f a = f a)\n      ( transport A ( \\ x \u2192 (f x) = (f a))\n        ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n        ( a)\n        ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)\n        ( section-htpy-is-half-adjoint-equiv A B f is-hae-f (f a)))\n      ( concat B\n        ( f a)\n        ( f (map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)))\n        ( f a)\n        ( ap A B\n          ( a)\n          ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n          ( f)\n          ( rev A ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)) a\n            ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)))\n        ( section-htpy-is-half-adjoint-equiv A B f is-hae-f (f a)))\n      ( concat B\n        ( f a)\n        ( f (map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)))\n        ( f a)\n        ( ap A B\n          ( a)\n          ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n          ( f)\n          ( rev A (map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)) a\n            ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)))\n        ( ap A B (map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)) a f\n          ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)))\n      ( refl)\n      ( transport-in-fiber A B f (f a)\n        ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n        ( a)\n        ( section-htpy-is-half-adjoint-equiv A B f is-hae-f (f a))\n        ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a))\n      ( concat-eq-right B\n        ( f a)\n        ( f (map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)))\n        ( f a)\n        ( ap A B\n          ( a)\n          ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n          ( f)\n          ( rev A ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)) a\n            ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)))\n        ( section-htpy-is-half-adjoint-equiv A B f is-hae-f (f a))\n        ( ap A B (map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a)) a f\n          ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a))\n        (coherence-is-half-adjoint-equiv A B f is-hae-f a))\n      ( concat-ap-rev-ap-id A B\n        ( map-inverse-is-half-adjoint-equiv A B f is-hae-f (f a))\n        ( a)\n        ( f)\n        ( retraction-htpy-is-half-adjoint-equiv A B f is-hae-f a)))\n#def contraction-fib-is-half-adjoint-equiv uses (is-hae-f)\n( b : B)\n( z : fib A B f b)\n  : is-split-surjection-is-half-adjoint-equiv b = z\n  :=\n    ind-fib\n    ( A) (B) (f)\n    ( \\ b' z' \u2192 is-split-surjection-is-half-adjoint-equiv b' = z')\n    ( calculate-is-split-surjection-is-half-adjoint-equiv)\n    ( b)\n    ( z)\n#def is-contr-map-is-half-adjoint-equiv uses (is-hae-f)\n  : is-contr-map A B f\n  :=\n\\ b \u2192\n      ( is-split-surjection-is-half-adjoint-equiv b,\n        contraction-fib-is-half-adjoint-equiv b)\n#end is-contr-map-is-equiv\n</code></pre>"},{"location":"hott/07-fibers.rzk/#equivalences-are-contractible-maps","title":"Equivalences are contractible maps","text":"<pre><code>#def is-contr-map-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n  : is-contr-map A B f\n  :=\n\\ b \u2192\n    ( is-split-surjection-is-half-adjoint-equiv A B f\n      ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b ,\n\\ z \u2192 contraction-fib-is-half-adjoint-equiv A B f\n        ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b z)\n#def is-contr-map-iff-is-equiv\n( A B : U)\n( f : A \u2192 B)\n  : iff (is-contr-map A B f) (is-equiv A B f)\n  := (is-equiv-is-contr-map A B f , is-contr-map-is-equiv A B f)\n</code></pre>"},{"location":"hott/07-fibers.rzk/#fibers-of-projections","title":"Fibers of projections","text":"<p>For a family of types <code>B : A \u2192 U</code>, the fiber of the projection from <code>total-type A B</code> to <code>A</code> over <code>a : A</code> is equivalent to <code>B a</code>. While both types deserve the name \"fibers\" to disambiguate, we temporarily refer to the fiber as the \"homotopy fiber\" and <code>B a</code> as the \"strict fiber.\"</p> <pre><code>#section strict-vs-homotopy-fiber\n#variable A : U\n#variable B : A \u2192 U\n#def homotopy-fiber-strict-fiber\n(a : A)\n(b : B a)\n  : fib (total-type A B) A (projection-total-type A B) a\n  := ((a, b), refl)\n#def strict-fiber-homotopy-fiber\n(a : A)\n  (((a', b'), p) : fib (total-type A B) A (projection-total-type A B) a)\n  : B a\n  := transport A B a' a p b'\n#def retract-homotopy-fiber-strict-fiber\n(a : A)\n(b : B a)\n  : strict-fiber-homotopy-fiber a (homotopy-fiber-strict-fiber a b) = b\n  := refl\n#def calculation-retract-strict-fiber-homotopy-fiber\n(a : A)\n(b : B a)\n  : homotopy-fiber-strict-fiber a\n    ( strict-fiber-homotopy-fiber a ((a, b), refl)) =\n    ( (a, b), refl)\n  := refl\n#def retract-strict-fiber-homotopy-fiber\n(a : A)\n  (((a', b'), p) : fib (total-type A B) A (projection-total-type A B) a)\n  : homotopy-fiber-strict-fiber a (strict-fiber-homotopy-fiber a ((a', b'), p))\n    = ((a', b'), p)\n  :=\n    ind-fib\n    ( total-type A B)\n    ( A)\n    ( projection-total-type A B)\n    ( \\ a0 ((a'', b''), p') \u2192\n      homotopy-fiber-strict-fiber a0\n      ( strict-fiber-homotopy-fiber a0 ((a'', b''), p')) = ((a'', b''), p'))\n    ( \\ (a'', b'') \u2192 refl)\n    ( a)\n    ( ((a', b'), p))\n#def equiv-homotopy-fiber-strict-fiber\n(a : A)\n  : Equiv\n    ( B a)\n    ( fib (total-type A B) A (projection-total-type A B) a)\n  :=\n    ( homotopy-fiber-strict-fiber a,\n      ( ( strict-fiber-homotopy-fiber a,\n          retract-homotopy-fiber-strict-fiber a),\n        ( strict-fiber-homotopy-fiber a,\n          retract-strict-fiber-homotopy-fiber a)))\n#end strict-vs-homotopy-fiber\n</code></pre>"},{"location":"hott/07-fibers.rzk/#fibers-of-composites","title":"Fibers of composites","text":"<p>The fiber of a composite function is a sum over the fiber of the second function of the fibers of the first function.</p> <pre><code>#section fiber-composition\n#variables A B C : U\n#variable f : A \u2192 B\n#variable g : B \u2192 C\n#def fiber-sum-fiber-comp\n(c : C)\n  ((a, r) : fib A C (comp A B C g f) c)\n  : ( \u03a3 ((b, q) : fib B C g c), fib A B f b)\n  := ((f a, r), (a, refl))\n#def fiber-comp-fiber-sum\n(c : C)\n  ( ((b, q), (a, p)) : \u03a3 ((b, q) : fib B C g c), fib A B f b)\n  : fib A C (comp A B C g f) c\n  := (a, concat C (g (f a)) (g b) c (ap B C (f a) b g p) q)\n#def is-retract-fiber-sum-fiber-comp\n(c : C)\n  ((a, r) : fib A C (comp A B C g f) c)\n  : fiber-comp-fiber-sum c (fiber-sum-fiber-comp c (a, r)) = (a, r)\n  :=\n    eq-eq-fiber-\u03a3\n    ( A)\n    ( \\ a0 \u2192 (g (f a0)) = c)\n    ( a)\n    ( concat C (g (f a)) (g (f a)) c refl r)\n    ( r)\n    ( left-unit-concat C (g (f a)) c r)\n#def is-retract-fiber-comp-fiber-sum'\n(c : C)\n  ((b, q) : fib B C g c)\n  : ((a, p) : fib A B f b) \u2192\n    fiber-sum-fiber-comp c (fiber-comp-fiber-sum c ((b, q), (a, p))) =\n    ((b, q), (a, p))\n  :=\n    ind-fib B C g\n    ( \\ c' (b', q') \u2192 ((a, p) : fib A B f b') \u2192\n      fiber-sum-fiber-comp c' (fiber-comp-fiber-sum c' ((b', q'), (a, p))) =\n      ((b', q'), (a, p)))\n    ( \\ b0 (a, p) \u2192\n      ( ind-fib A B f\n        ( \\b0' (a', p') \u2192\n          fiber-sum-fiber-comp (g b0')\n          ( fiber-comp-fiber-sum (g b0') ((b0', refl), (a', p'))) =\n          ((b0', refl), (a', p')))\n        ( \\a0 \u2192 refl)\n        ( b0)\n        ( (a, p))))\n    ( c)\n    ( (b, q))\n#def is-retract-fiber-comp-fiber-sum\n(c : C)\n  ( ((b, q), (a, p)) : \u03a3 ((b, q) : fib B C g c), fib A B f b)\n  : fiber-sum-fiber-comp c (fiber-comp-fiber-sum c ((b, q), (a, p))) =\n    ((b, q), (a, p))\n  := is-retract-fiber-comp-fiber-sum' c (b, q) (a, p)\n#def equiv-fiber-sum-fiber-comp\n(c : C)\n  : Equiv\n    ( fib A C (comp A B C g f) c)\n    ( \u03a3 ((b, q) : fib B C g c), fib A B f b)\n  :=\n    ( fiber-sum-fiber-comp c,\n      ( ( fiber-comp-fiber-sum c,\n          is-retract-fiber-sum-fiber-comp c),\n        ( fiber-comp-fiber-sum c,\n          is-retract-fiber-comp-fiber-sum c)))\n#end fiber-composition\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/","title":"8. Families of maps","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#fiber-of-total-map","title":"Fiber of total map","text":"<p>We now calculate the fiber of the map on total spaces associated to a family of maps.</p> <pre><code>#def total-map\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  : ( total-type A B) \u2192 (total-type A C)\n  := \\ (a , b) \u2192 (a , f a b)\n#def fib-total-map-fib-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( (a , c) : total-type A C)\n  : fib (B a) (C a) (f a) (c)\n  \u2192 fib (total-type A B) (total-type A C) (total-map A B C f) (a , c)\n  := \\ (b , p) \u2192 ((a , b) , eq-eq-fiber-\u03a3 A C a (f a b) c p)\n#def fib-fiberwise-fib-total-map\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  : ( (a , c) : total-type A C)\n  \u2192 fib (total-type A B) (total-type A C) (total-map A B C f) (a , c)\n  \u2192 fib (B a) (C a) (f a) (c)\n  :=\n    ind-fib (total-type A B) (total-type A C) (total-map A B C f)\n    ( \\ (a' , c') _ \u2192 fib (B a') (C a') (f a') c')\n    ( \\ (_ , b') \u2192 (b' , refl))\n#def has-retraction-fib-total-map-fib-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( (a , c) : total-type A C)\n  : has-retraction\n    ( fib (B a) (C a) (f a) (c))\n    ( fib (total-type A B) (total-type A C) (total-map A B C f) (a , c))\n    ( fib-total-map-fib-fiberwise A B C f (a , c))\n  :=\n    ( ( fib-fiberwise-fib-total-map A B C f (a , c))\n    , ( \\ (b , p) \u2192\n        ind-path ( C a) ( f a b)\n        ( \\ c' p' \u2192\n          ( ( fib-fiberwise-fib-total-map A B C f ((a , c')))\n            ( (fib-total-map-fib-fiberwise A B C f (a , c')) (b , p'))\n          = ( b , p')))\n        ( refl)\n        ( c)\n        ( p)))\n#def has-section-fib-total-map-fib-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( (a , c) : (\u03a3 (x : A) , C x))\n  : has-section\n    ( fib (B a) (C a) (f a) c)\n    ( fib (total-type A B) (total-type A C) (total-map A B C f) (a , c))\n    ( fib-total-map-fib-fiberwise A B C f (a , c))\n  :=\n    ( ( fib-fiberwise-fib-total-map A B C f (a , c))\n    , ( \\ ((a', b') , p) \u2192\n        ind-path\n          ( total-type A C)\n          ( a' , f a' b')\n          ( \\ w' p' \u2192\n            ( ( fib-total-map-fib-fiberwise A B C f w')\n              ( ( fib-fiberwise-fib-total-map A B C f w') ((a' , b') , p'))\n            = ( (a' , b') , p')))\n          ( refl)\n          ( a , c)\n          ( p)))\n#def is-equiv-fib-total-map-fib-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( (a , c) : total-type A C)\n  : is-equiv\n    ( fib (B a) (C a) (f a) c)\n    ( fib (total-type A B) (total-type A C) ( total-map A B C f) (a , c))\n    ( fib-total-map-fib-fiberwise A B C f (a , c))\n  :=\n    ( has-retraction-fib-total-map-fib-fiberwise A B C f (a , c)\n    , has-section-fib-total-map-fib-fiberwise A B C f (a , c))\n#def equiv-fib-total-map-fib-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( (a , c) : total-type A C)\n  : Equiv\n    ( fib (B a) (C a) (f a) c)\n    ( fib (total-type A B) (total-type A C) ( total-map A B C f) (a , c))\n  :=\n    ( fib-total-map-fib-fiberwise A B C f (a , c)\n    , is-equiv-fib-total-map-fib-fiberwise A B C f (a, c))\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#families-of-equivalences","title":"Families of equivalences","text":"<p>A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses.</p> <pre><code>#def map-inverse-total-has-inverse-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : (total-type A C) \u2192 (total-type A B)\n  :=\n    \\ (a , c) \u2192\n      (a , (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c)\n#def has-retraction-total-has-inverse-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : has-retraction (total-type A B) (total-type A C) (total-map A B C f)\n  :=\n    ( map-inverse-total-has-inverse-fiberwise A B C f invfamily ,\n      \\ (a , b) \u2192\n        (eq-eq-fiber-\u03a3 A B a\n          ( (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b\n          ( (first (second (invfamily a))) b)))\n#def has-section-total-has-inverse-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : has-section (total-type A B) (total-type A C) (total-map A B C f)\n  :=\n    ( map-inverse-total-has-inverse-fiberwise A B C f invfamily ,\n      \\ (a , c) \u2192\n        ( eq-eq-fiber-\u03a3 A C a\n          ( f a ((map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c)) c\n          ( (second (second (invfamily a))) c)))\n#def has-inverse-total-has-inverse-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : has-inverse (total-type A B) (total-type A C) (total-map A B C f)\n  :=\n    ( map-inverse-total-has-inverse-fiberwise A B C f invfamily ,\n      ( second (has-retraction-total-has-inverse-fiberwise A B C f invfamily) ,\nsecond (has-section-total-has-inverse-fiberwise A B C f invfamily)))\n</code></pre> <p>The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces.</p> <pre><code>#def has-inverse-total-is-equiv-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( familyequiv : (a : A) \u2192 is-equiv (B a) (C a) (f a))\n  : has-inverse (total-type A B) ( total-type A C) ( total-map A B C f)\n  :=\n    has-inverse-total-has-inverse-fiberwise A B C f\n    ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a))\n#def is-equiv-total-is-equiv-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( familyequiv : (a : A) \u2192 is-equiv (B a) (C a) (f a))\n  : is-equiv ( total-type A B) (total-type A C) (total-map A B C f)\n  :=\n    is-equiv-has-inverse\n    ( total-type A B) ( total-type A C) ( total-map A B C f)\n    ( has-inverse-total-is-equiv-fiberwise A B C f familyequiv)\n#def total-equiv-family-of-equiv\n( A : U)\n( B C : A \u2192 U)\n( familyeq : (a : A) \u2192 Equiv (B a) (C a))\n  : Equiv (total-type A B) (total-type A C)\n  :=\n    ( total-map A B C (\\ a \u2192 first (familyeq a))\n    , is-equiv-total-is-equiv-fiberwise A B C\n      ( \\ a \u2192 first (familyeq a))\n      ( \\ a \u2192 second (familyeq a)))\n</code></pre> <p>For the converse, we make use of our calculation on fibers. The first implication could be proven similarly.</p> <pre><code>#def is-contr-map-total-is-contr-map-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( totalcontrmap\n    : is-contr-map (total-type A B) ( total-type A C) ( total-map A B C f))\n( a : A)\n  : is-contr-map (B a) (C a) (f a)\n  :=\n\\ c \u2192\n      is-contr-equiv-is-contr'\n      ( fib (B a) (C a) (f a) c)\n      ( fib ( total-type A B) ( total-type A C) ( total-map A B C f) (a , c))\n      ( equiv-fib-total-map-fib-fiberwise A B C f (a , c))\n      ( totalcontrmap (a , c))\n#def is-equiv-fiberwise-is-equiv-total\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( totalequiv\n    : is-equiv (total-type A B) (total-type A C) ( total-map A B C f))\n(a : A)\n  : is-equiv (B a) (C a) (f a)\n  :=\n    is-equiv-is-contr-map (B a) (C a) (f a)\n    ( is-contr-map-total-is-contr-map-fiberwise A B C f\n      ( is-contr-map-is-equiv\n        ( total-type A B) (total-type A C) (total-map A B C f)\n        ( totalequiv))\n      ( a))\n#def family-of-equiv-is-equiv-total\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n( totalequiv\n    : is-equiv (total-type A B) (total-type A C) ( total-map A B C f))\n( a : A)\n  : Equiv (B a) (C a)\n  := ( f a , is-equiv-fiberwise-is-equiv-total A B C f totalequiv a)\n</code></pre> <p>In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence.</p> <pre><code>#def is-equiv-total-iff-is-equiv-fiberwise\n( A : U)\n( B C : A \u2192 U)\n( f : (a : A) \u2192 (B a) \u2192 (C a))\n  : iff\n( (a : A) \u2192 is-equiv (B a) (C a) (f a))\n( is-equiv (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x)\n        ( total-map A B C f))\n  :=\n    ( is-equiv-total-is-equiv-fiberwise A B C f\n    , is-equiv-fiberwise-is-equiv-total A B C f)\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#path-spaces","title":"Path spaces","text":""},{"location":"hott/08-families-of-maps.rzk/#based-path-spaces","title":"Based path spaces","text":"An equivalence between the based path spaces<pre><code>#def equiv-based-paths\n( A : U)\n( a : A)\n  : Equiv (\u03a3 (x : A) , x = a) (\u03a3 (x : A) , a = x)\n  := total-equiv-family-of-equiv A (\\ x \u2192 x = a) (\\ x \u2192 a = x) (\\ x \u2192 equiv-rev A x a)\n</code></pre> Endpoint based path spaces are contractible<pre><code>#def is-contr-endpoint-based-paths\n( A : U)\n( a : A)\n  : is-contr (\u03a3 (x : A) , x = a)\n  :=\n    is-contr-equiv-is-contr' (\u03a3 (x : A) , x = a) (\u03a3 (x : A) , a = x)\n      ( equiv-based-paths A a)\n      ( is-contr-based-paths A a)\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#free-path-spaces","title":"Free path spaces","text":"<p>The canonical map from a type to its the free path type is an equivalence.</p> <pre><code>#def free-paths\n( A : U)\n  : U\n  := \u03a3 ( (x , y) : product A A) , (x = y)\n#def constant-free-path\n( A : U)\n( a : A)\n  : free-paths A\n  := ((a , a) , refl)\n#def is-constant-free-path\n( A : U)\n  ( ((a , y) , p) : free-paths A)\n  : constant-free-path A a = ((a , y), p)\n  :=\n    ind-path A a\n    ( \\ x p' \u2192  constant-free-path A a = ((a , x) , p'))\n    ( refl)\n    ( y) ( p)\n#def start-free-path\n( A : U)\n  : free-paths A \u2192 A\n  := \\ ((a , _) , _) \u2192 a\n#def is-equiv-constant-free-path\n( A : U)\n  : is-equiv A (free-paths A) (constant-free-path A)\n  :=\n    ( ( start-free-path A , \\ _ \u2192 refl)\n    , ( start-free-path A , is-constant-free-path A))\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#pullback-of-a-type-family","title":"Pullback of a type family","text":"<p>A family of types over B pulls back along any function f : A \u2192 B to define a family of types over A.</p> <pre><code>#def pullback\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n  : A \u2192 U\n  := \\ a \u2192 C (f a)\n</code></pre> <p>The pullback of a family along homotopic maps is equivalent.</p> <pre><code>#section is-equiv-pullback-htpy\n#variables A B : U\n#variables f g : A \u2192 B\n#variable \u03b1 : homotopy A B f g\n#variable C : B \u2192 U\n#variable a : A\n#def pullback-homotopy\n  : (pullback A B f C a) \u2192 (pullback A B g C a)\n  := transport B C (f a) (g a) (\u03b1 a)\n#def map-inverse-pullback-homotopy\n  : (pullback A B g C a) \u2192 (pullback A B f C a)\n  := transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a))\n#def has-retraction-pullback-homotopy\n  : has-retraction\n    ( pullback A B f C a)\n    ( pullback A B g C a)\n    ( pullback-homotopy)\n  :=\n    ( map-inverse-pullback-homotopy\n    , \\ c \u2192\n        concat\n        ( pullback A B f C a)\n        ( transport B C (g a) (f a)\n          ( rev B (f a) (g a) (\u03b1 a))\n          ( transport B C (f a) (g a) (\u03b1 a) c))\n        ( transport B C (f a) (f a)\n          ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) c)\n        ( c)\n        ( transport-concat-rev B C (f a) (g a) (f a) (\u03b1 a)\n          ( rev B (f a) (g a) (\u03b1 a)) c)\n        ( transport2 B C (f a) (f a)\n          ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) refl\n          ( right-inverse-concat B (f a) (g a) (\u03b1 a)) c))\n#def has-section-pullback-homotopy\n  : has-section (pullback A B f C a) (pullback A B g C a)\n    ( pullback-homotopy)\n  :=\n    ( map-inverse-pullback-homotopy\n    , \\ c \u2192\n      concat\n        ( pullback A B g C a)\n        ( transport B C (f a) (g a) (\u03b1 a)\n          ( transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c))\n        ( transport B C (g a) (g a)\n          ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) c)\n        ( c)\n        ( transport-concat-rev B C (g a) (f a) (g a)\n          ( rev B (f a) (g a) (\u03b1 a)) (\u03b1 a) (c))\n        ( transport2 B C (g a) (g a)\n          ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a))\n          ( refl)\n          ( left-inverse-concat B (f a) (g a) (\u03b1 a)) c))\n#def is-equiv-pullback-homotopy uses (\u03b1)\n  : is-equiv\n      ( pullback A B f C a)\n      ( pullback A B g C a)\n      ( pullback-homotopy)\n  := ( has-retraction-pullback-homotopy , has-section-pullback-homotopy)\n#def equiv-pullback-homotopy uses (\u03b1)\n  : Equiv (pullback A B f C a) (pullback A B g C a)\n  := (pullback-homotopy , is-equiv-pullback-homotopy)\n#end is-equiv-pullback-htpy\n</code></pre> <p>The total space of a pulled back family of types maps to the original total space.</p> <pre><code>#def pullback-comparison-map\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n  : (\u03a3 (a : A) , (pullback A B f C) a) \u2192 (\u03a3 (b : B) , C b)\n  := \\ (a , c) \u2192 (f a , c)\n</code></pre> <p>Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map.</p> <pre><code>#def pullback-comparison-fiber\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( z : \u03a3 (b : B) , C b)\n  : U\n  :=\n    fib\n( \u03a3 (a : A) , (pullback A B f C) a)\n( \u03a3 (b : B) , C b)\n      ( pullback-comparison-map A B f C) z\n#def pullback-comparison-fiber-to-fiber\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( z : \u03a3 (b : B) , C b)\n  : (pullback-comparison-fiber A B f C z) \u2192 (fib A B f (first z))\n  :=\n    \\ (w , p) \u2192\n    ind-path\n( \u03a3 (b : B) , C b)\n      ( pullback-comparison-map A B f C w)\n      ( \\ z' p' \u2192\n        ( fib A B f (first z')))\n      ( first w , refl)\n      ( z)\n      ( p)\n#def from-base-fiber-to-pullback-comparison-fiber\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( b : B)\n  : (fib A B f b) \u2192 (c : C b) \u2192 (pullback-comparison-fiber A B f C (b , c))\n  :=\n    \\ (a , p) \u2192\n    ind-path\n      ( B)\n      ( f a)\n( \\ b' p' \u2192\n          (c : C b') \u2192 (pullback-comparison-fiber A B f C ((b' , c))))\n      ( \\ c \u2192 ((a , c) , refl))\n      ( b)\n      ( p)\n#def pullback-comparison-fiber-to-fiber-inv\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( z : \u03a3 (b : B) , C b)\n  : (fib A B f (first z)) \u2192 (pullback-comparison-fiber A B f C z)\n  :=\n    \\ (a , p) \u2192\n      from-base-fiber-to-pullback-comparison-fiber A B f C\n      ( first z) (a , p) (second z)\n#def pullback-comparison-fiber-to-fiber-retracting-homotopy\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( z : \u03a3 (b : B) , C b)\n  ( (w , p) : pullback-comparison-fiber A B f C z)\n  : ( (pullback-comparison-fiber-to-fiber-inv A B f C z)\n      ( (pullback-comparison-fiber-to-fiber A B f C z) (w , p))) = (w , p)\n  :=\n    ind-path\n( \u03a3 (b : B) , C b)\n      ( pullback-comparison-map A B f C w)\n      ( \\ z' p' \u2192\n        ( ( pullback-comparison-fiber-to-fiber-inv A B f C z')\n          ( ( pullback-comparison-fiber-to-fiber A B f C z') (w , p'))) =\n        ( w , p'))\n      ( refl)\n      ( z)\n      ( p)\n#def pullback-comparison-fiber-to-fiber-section-homotopy-map\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( b : B)\n  ( (a , p) : fib A B f b)\n  : (c : C b) \u2192\n      ((pullback-comparison-fiber-to-fiber A B f C (b , c))\n        ((pullback-comparison-fiber-to-fiber-inv A B f C (b , c)) (a , p))) =\n      (a , p)\n  :=\n    ind-path\n      ( B)\n      ( f a)\n( \\ b' p' \u2192\n        ( c : C b') \u2192\n        ( ( pullback-comparison-fiber-to-fiber A B f C (b' , c))\n          ( (pullback-comparison-fiber-to-fiber-inv A B f C (b' , c)) (a , p'))) =\n        ( a , p'))\n      ( \\ c \u2192 refl)\n      ( b)\n      ( p)\n#def pullback-comparison-fiber-to-fiber-section-homotopy\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( z : \u03a3 (b : B) , C b)\n  ( (a , p) : fib A B f (first z))\n  : ( pullback-comparison-fiber-to-fiber A B f C z\n      ( pullback-comparison-fiber-to-fiber-inv A B f C z (a , p))) = (a , p)\n  :=\n    pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C\n      ( first z) (a , p) (second z)\n#def equiv-pullback-comparison-fiber\n( A B : U)\n( f : A \u2192 B)\n( C : B \u2192 U)\n( z : \u03a3 (b : B) , C b)\n  : Equiv (pullback-comparison-fiber A B f C z) (fib A B f (first z))\n  :=\n    ( pullback-comparison-fiber-to-fiber A B f C z ,\n      ( ( pullback-comparison-fiber-to-fiber-inv A B f C z ,\n          pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z) ,\n        ( pullback-comparison-fiber-to-fiber-inv A B f C z ,\n          pullback-comparison-fiber-to-fiber-section-homotopy A B f C z)))\n</code></pre> <p>As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces.</p> <pre><code>#def equiv-total-pullback-is-equiv\n( A B : U)\n( f : A \u2192 B)\n( is-equiv-f : is-equiv A B f)\n( C : B \u2192 U)\n  : Equiv (\u03a3 (a : A) , (pullback A B f C) a) (\u03a3 (b : B) , C b)\n  :=\n( pullback-comparison-map A B f C ,\n      is-equiv-is-contr-map\n        ( \u03a3 (a : A) , (pullback A B f C) a)\n( \u03a3 (b : B) , C b)\n        ( pullback-comparison-map A B f C)\n        ( \\ z \u2192\n          ( is-contr-equiv-is-contr'\n            ( pullback-comparison-fiber A B f C z)\n            ( fib A B f (first z))\n            ( equiv-pullback-comparison-fiber A B f C z)\n            ( is-contr-map-is-equiv A B f is-equiv-f (first z)))))\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#fundamental-theorem-of-identity-types","title":"Fundamental theorem of identity types","text":"<p>The fundamental theorem of identity types concerns the following question: Given a type family <code>B : A \u2192 U</code>, when is <code>B</code> equivalent to <code>\\ x \u2192 a x</code> for some <code>a : A</code>?</p> <p>We start by fixing <code>a : A</code> and investigating when a map of families <code>x : A \u2192 (a = x) \u2192 B x</code> is a (fiberwise) equivalence.</p> <pre><code>#section fundamental-thm-id-types\n#variable A : U\n#variable a : A\n#variable B : A \u2192 U\n#variable f : (x : A) \u2192 (a = x) \u2192 B x\n#def is-contr-total-are-equiv-from-paths\n  : ( (x : A) \u2192 (is-equiv (a = x) (B x) (f x)))\n  \u2192 ( is-contr (\u03a3 (x : A) , B x))\n  :=\n( \\ familyequiv \u2192\n      ( equiv-with-contractible-domain-implies-contractible-codomain\n        ( \u03a3 (x : A) , a = x) (\u03a3 (x : A) , B x)\n        ( ( total-map A ( \\ x \u2192 (a = x)) B f)\n        , ( is-equiv-has-inverse (\u03a3 (x : A) , a = x) (\u03a3 (x : A) , B x)\n            ( total-map A ( \\ x \u2192 (a = x)) B f)\n            ( has-inverse-total-is-equiv-fiberwise A\n              ( \\ x \u2192 (a = x)) B f familyequiv)))\n        ( is-contr-based-paths A a)))\n#def are-equiv-from-paths-is-contr-total\n  : ( is-contr (\u03a3 (x : A) , B x))\n  \u2192 ( (x : A) \u2192 (is-equiv (a = x) (B x) (f x)))\n  :=\n    ( \\ is-contr-\u03a3-A-B x \u2192\n      is-equiv-fiberwise-is-equiv-total A\n        ( \\ x' \u2192 (a = x'))\n        ( B)\n        ( f)\n( is-equiv-are-contr\n          ( \u03a3 (x' : A) , (a = x'))\n( \u03a3 (x' : A) , (B x'))\n          ( is-contr-based-paths A a)\n          ( is-contr-\u03a3-A-B)\n          ( total-map A (\\ x' \u2192 (a = x')) B f))\n        ( x))\n</code></pre> <p>This allows us to apply \"based path induction\" to a family satisfying the fundamental theorem:</p> <pre><code>-- Please suggest a better name.\n#def ind-based-path\n( familyequiv : (z : A) \u2192 (is-equiv (a = z) (B z) (f z)))\n( P : (z : A) \u2192 B z \u2192 U)\n( p0 : P a (f a refl))\n( u : A)\n( p : B u)\n  : P u p\n  :=\n    ind-sing\n( \u03a3 (v : A) , B v)\n      ( a , f a refl)\n      ( \\ (u' , p') \u2192 P u' p')\n( contr-implies-singleton-induction-pointed\n        ( \u03a3 (z : A) , B z)\n        ( is-contr-total-are-equiv-from-paths familyequiv)\n        ( \\ (x' , p') \u2192 P x' p'))\n      ( p0)\n      ( u , p)\n#end fundamental-thm-id-types\n</code></pre> <p>We can now answer the original question. A type family <code>B : A \u2192 U</code> is equivalent to the family of based paths at a point if and only if its total space is contractible.</p> <pre><code>#def map-from-paths-inhabited-total\n( A : U)\n( B : A \u2192 U)\n  ( (a , b) : total-type A B)\n( x : A)\n  : (a = x) \u2192 B x\n  := ind-path A a ( \\ y _ \u2192 B y) b x\n#def fundamental-theorem-of-identity-types\n( A : U)\n( B : A \u2192 U)\n  : iff\n    ( is-contr (total-type A B))\n( \u03a3 (a : A) , ((x : A) \u2192 Equiv (a = x) (B x)))\n  :=\n  ( ( \\ ((a , b) , h) \u2192\n      ( a\n      , \\ x \u2192\n        ( map-from-paths-inhabited-total A B (a , b) x\n        , are-equiv-from-paths-is-contr-total A a B\n          ( map-from-paths-inhabited-total A B (a , b))\n          ( (a , b) , h)\n          ( x))))\n  , ( \\ (a , familyequiv) \u2192\n      is-contr-total-are-equiv-from-paths A a B\n      ( \\ x \u2192 first (familyequiv x))\n      ( \\ x \u2192 second (familyequiv x))))\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#maps-over-product-types","title":"Maps over product types","text":"<p>For later use, we specialize the previous results to the case of a family of types over a product type.</p> <pre><code>#section fibered-map-over-product\n#variables A A' B B' : U\n#variable C : A \u2192 B \u2192 U\n#variable C' : A' \u2192 B' \u2192 U\n#variable f : A \u2192 A'\n#variable g : B \u2192 B'\n#variable h : (a : A) \u2192 (b : B) \u2192 (C a b) \u2192 C' (f a) (g b)\n#def total-map-fibered-map-over-product\n  : ( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  \u2192 ( \u03a3 (a' : A') , (\u03a3 (b' : B') , C' a' b'))\n  := \\ (a , (b , c)) \u2192 (f a , (g b , h a b c))\n#def pullback-is-equiv-base-is-equiv-total-is-equiv\n( is-equiv-total\n    : is-equiv\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a' : A') , (\u03a3 (b' : B') , C' a' b'))\n      ( total-map-fibered-map-over-product))\n( is-equiv-f : is-equiv A A' f)\n  : is-equiv\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a : A) , (\u03a3 (b' : B') , C' (f a) b'))\n    ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c)))\n  :=\n    is-equiv-right-factor\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a : A) , (\u03a3 (b' : B') , C' (f a) b'))\n( \u03a3 (a' : A') , (\u03a3 (b' : B') , C' a' b'))\n    ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c)))\n    ( \\ (a , (b' , c')) \u2192 (f a , (b' , c')))\n    ( second\n      ( equiv-total-pullback-is-equiv\n        ( A) (A')\n        ( f) (is-equiv-f)\n( \\ a' \u2192 (\u03a3 (b' : B') , C' a' b'))))\n    ( is-equiv-total)\n#def pullback-is-equiv-bases-are-equiv-total-is-equiv\n( is-equiv-total\n    : is-equiv\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a' : A') , (\u03a3 (b' : B') , C' a' b'))\n      ( total-map-fibered-map-over-product))\n( is-equiv-f : is-equiv A A' f)\n( is-equiv-g : is-equiv B B' g)\n  : is-equiv\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a : A) , (\u03a3 (b : B) , C' (f a) (g b)))\n    ( \\ (a , (b , c)) \u2192 (a , (b , h a b c)))\n  :=\n    is-equiv-right-factor\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a : A) , (\u03a3 (b : B) , C' (f a) (g b)))\n( \u03a3 (a : A) , (\u03a3 (b' : B') , C' (f a) b'))\n    ( \\ (a , (b , c)) \u2192 (a , (b , h a b c)))\n    ( \\ (a , (b , c)) \u2192 (a , (g b , c)))\n( is-equiv-total-is-equiv-fiberwise A\n      ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b)))\n( \\ a \u2192 (\u03a3 (b' : B') , C' (f a) b'))\n      ( \\ a (b , c) \u2192 (g b , c))\n      ( \\ a \u2192\n        ( second\n          ( equiv-total-pullback-is-equiv\n            ( B) (B')\n            ( g) (is-equiv-g)\n            ( \\ b' \u2192 C' (f a) b')))))\n    ( pullback-is-equiv-base-is-equiv-total-is-equiv is-equiv-total is-equiv-f)\n#def fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv\n( is-equiv-total\n    : is-equiv\n( \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n( \u03a3 (a' : A') , (\u03a3 (b' : B') , C' a' b'))\n      ( total-map-fibered-map-over-product))\n( is-equiv-f : is-equiv A A' f)\n( is-equiv-g : is-equiv B B' g)\n( a0 : A)\n( b0 : B)\n  : is-equiv (C a0 b0) (C' (f a0) (g b0)) (h a0 b0)\n  :=\n    is-equiv-fiberwise-is-equiv-total B\n      ( \\ b \u2192 C a0 b)\n      ( \\ b \u2192 C' (f a0) (g b))\n      ( \\ b c \u2192 h a0 b c)\n      ( is-equiv-fiberwise-is-equiv-total\n        ( A)\n( \\ a \u2192 (\u03a3 (b : B) , C a b))\n( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b)))\n        ( \\ a (b , c) \u2192 (b , h a b c))\n        ( pullback-is-equiv-bases-are-equiv-total-is-equiv\n            is-equiv-total is-equiv-f is-equiv-g)\n        ( a0))\n      ( b0)\n#end fibered-map-over-product\n</code></pre>"},{"location":"hott/09-propositions.rzk/","title":"9. Propositions","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Some of the definitions in this file rely on function extensionality and weak function extensionality:</p> <pre><code>#assume funext : FunExt\n#assume weakfunext : WeakFunExt\n</code></pre>"},{"location":"hott/09-propositions.rzk/#propositions","title":"Propositions","text":"<p>A type is a proposition when its identity types are contractible.</p> <pre><code>#def is-prop\n(A : U)\n  : U\n  := (a : A) \u2192 (b : A) \u2192 is-contr (a = b)\n</code></pre> <p>For example, the type <code>Unit</code> is a proposition. In fact we will show below that this is true for every contractible type.</p> <pre><code>#def is-prop-Unit\n  : is-prop Unit\n  := \\ x y \u2192 (is-contr-path-types-Unit x y)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-definitions","title":"Alternative characterizations: definitions","text":"<pre><code>#def all-elements-equal\n(A : U)\n  : U\n  := (a : A) \u2192 (b : A) \u2192 (a = b)\n#def is-contr-is-inhabited\n(A : U)\n  : U\n  := A \u2192 is-contr A\n#def is-emb-terminal-map\n(A : U)\n  : U\n  := is-emb A Unit (terminal-map A)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-proofs","title":"Alternative characterizations: proofs","text":"<pre><code>#def all-elements-equal-is-prop\n( A : U)\n( is-prop-A : is-prop A)\n  : all-elements-equal A\n  := \\ a b \u2192 (first (is-prop-A a b))\n#def is-contr-is-inhabited-all-elements-equal\n( A : U)\n( all-elements-equal-A : all-elements-equal A)\n  : is-contr-is-inhabited A\n  := \\ a \u2192 (a , all-elements-equal-A a)\n#def is-contr-is-inhabited-is-prop\n( A : U)\n( is-prop-A : is-prop A)\n  : is-contr-is-inhabited A\n  :=\n\\ a \u2192 (a, \\ b \u2192 first (is-prop-A a b))\n#def terminal-map-is-emb-is-inhabited-is-contr-is-inhabited\n( A : U)\n( c : is-contr-is-inhabited A)\n  : A \u2192 (is-emb-terminal-map A)\n  :=\n\\ x \u2192\n      ( is-emb-is-equiv A Unit (terminal-map A)\n        ( is-equiv-terminal-map-is-contr A (c x)))\n#def terminal-map-is-emb-is-contr-is-inhabited\n( A : U)\n( c : is-contr-is-inhabited A)\n  : (is-emb-terminal-map A)\n  :=\n    ( is-emb-is-inhabited-emb A Unit (terminal-map A)\n      ( terminal-map-is-emb-is-inhabited-is-contr-is-inhabited A c))\n#def is-prop-is-emb-terminal-map\n( A : U)\n( f : is-emb-terminal-map A)\n  : is-prop A\n  :=\n\\ x y \u2192\n      ( is-contr-equiv-is-contr' (x = y) (unit = unit)\n        ( (ap A Unit x y (terminal-map A)) , (f x y))\n        ( is-contr-path-types-Unit unit unit))\n#def is-prop-is-contr-is-inhabited\n( A : U)\n( c : is-contr-is-inhabited A)\n  : is-prop A\n  :=\n    ( is-prop-is-emb-terminal-map A\n      ( terminal-map-is-emb-is-contr-is-inhabited A c))\n#def is-prop-all-elements-equal\n( A : U)\n( all-elements-equal-A : all-elements-equal A)\n  : is-prop A\n  :=\n    is-prop-is-contr-is-inhabited A\n    (  is-contr-is-inhabited-all-elements-equal A all-elements-equal-A)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#properties-of-propositions","title":"Properties of propositions","text":"<p>If two propositions are logically equivalent, then they are equivalent:</p> <pre><code>#def is-equiv-iff-is-prop-is-prop\n( A B : U)\n( is-prop-A : is-prop A)\n( is-prop-B : is-prop B)\n  ( (f , g) : iff A B)\n  : is-equiv A B f\n  :=\n    ( ( g ,\n\\ a \u2192\n          (all-elements-equal-is-prop A is-prop-A) ((comp A B A g f) a) a) ,\n      ( g ,\n\\ b \u2192\n          (all-elements-equal-is-prop B is-prop-B) ((comp B A B f g) b) b))\n#def equiv-iff-is-prop-is-prop\n( A B : U)\n( is-prop-A : is-prop A)\n( is-prop-B : is-prop B)\n( e : iff A B)\n  : Equiv A B\n  := (first e, is-equiv-iff-is-prop-is-prop A B is-prop-A is-prop-B e)\n</code></pre> <p>Every contractible type is a proposition:</p> <pre><code>#def is-prop-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n  : is-prop A\n  :=\n    is-prop-is-contr-is-inhabited A ( \\ _ \u2192 is-contr-A)\n</code></pre> <p>All parallel paths in a proposition are equal.</p> <pre><code>#def all-paths-equal-is-prop\n( A : U)\n( is-prop-A : is-prop A)\n( a b : A)\n  : ( p : a = b) \u2192 (q : a = b) \u2192 p = q\n  :=\n    all-elements-equal-is-prop (a = b)\n    ( is-prop-is-contr (a = b)\n      ( is-prop-A a b))\n</code></pre>"},{"location":"hott/09-propositions.rzk/#proposition-induction","title":"Proposition induction","text":"<pre><code>#def ind-prop\n( A : U)\n( is-prop-A : is-prop A)\n( B : A \u2192 U)\n( a : A)\n( b : B a)\n( x : A)\n  : B x\n  :=\n    transport A B a x (first (is-prop-A a x)) b\n</code></pre> <p>It is convenient to able to apply this to contractible types without explicitly invoking <code>is-prop-is-contr</code>.</p> <pre><code>#def ind-prop-is-contr\n( A : U)\n( is-contr-A : is-contr A)\n  : ( B : A \u2192 U) \u2192 ( a : A) \u2192 ( b : B a) \u2192 ( x : A) \u2192  B x\n  := ind-prop A (is-prop-is-contr A is-contr-A)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#closure-properties-of-propositions","title":"Closure properties of propositions","text":""},{"location":"hott/09-propositions.rzk/#retracts-and-equivalences","title":"Retracts and equivalences","text":"<p>Retracts of propositions are propositions:</p> <pre><code>#def is-prop-is-retract-of-is-prop\n( A B : U)\n  ( (f,(g,\u03b7)) : is-retract-of A B) -- f : A \u2192 B with retraction g\n( is-prop-B : is-prop B)\n  : is-prop A\n  :=\n    is-prop-all-elements-equal A\n    ( \\ a a' \u2192\n      triple-concat A a (g (f a)) (g (f a')) a'\n      ( rev A (g (f a)) a (\u03b7 a))\n      ( ap B A (f a) (f a') g ( first (is-prop-B (f a) (f a'))))\n      ( \u03b7 a'))\n</code></pre> <p>In particular, propositions are closed under equivalences:</p> <pre><code>#def is-prop-Equiv-is-prop\n( A B : U)\n  ( (f, (rec-f, _)) : Equiv A B)\n  : is-prop B \u2192 is-prop A\n  := is-prop-is-retract-of-is-prop A B (f, rec-f)\n#def is-prop-Equiv-is-prop'\n( A B : U)\n( A\u2243B : Equiv A B)\n  : is-prop A \u2192 is-prop B\n  := is-prop-Equiv-is-prop B A (inv-equiv A B A\u2243B)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#product-types","title":"Product types","text":"<p>If some family <code>B : A \u2192 U</code> is fiberwise a proposition, then the type of dependent functions <code>(x : A) \u2192 B x</code> is a proposition.</p> <pre><code>#def is-prop-fiberwise-prop uses (funext weakfunext)\n( A : U)\n( B : A \u2192 U)\n( fiberwise-prop-B : (x : A) \u2192 is-prop (B x))\n  : is-prop ((x : A) \u2192 B x)\n  :=\n\\ f g \u2192\n    is-contr-equiv-is-contr'\n      ( f = g)\n( (x : A) \u2192 f x = g x)\n      ( equiv-FunExt funext A B f g)\n      ( weakfunext A (\\ x \u2192 f x = g x) (\\ x \u2192 fiberwise-prop-B x (f x) (g x)))\n</code></pre>"},{"location":"hott/09-propositions.rzk/#sum-types-over-a-propositions","title":"Sum types over a propositions","text":"<p>We consider a type family <code>C : A \u2192 U</code> over a proposition <code>A</code>.</p> <pre><code>#section families-over-propositions\n#variable A : U\n#variable is-prop-A : is-prop A\n#variable C : A \u2192 U\n</code></pre> <p>If each <code>C a</code> is a proposition, then so is the total type <code>total-type A C</code>.</p> <pre><code>#def is-prop-total-type-is-fiberwise-prop-is-prop-base uses (is-prop-A)\n( is-fiberwise-prop-C : (a : A) \u2192 is-prop (C a))\n  : is-prop (total-type A C)\n  :=\n    is-prop-all-elements-equal (total-type A C)\n    ( \\ (a, c) (a', c') \u2192\n      eq-pair A C (a, c) (a', c')\n      ( first ( is-prop-A a a')\n      , first\n        ( is-fiberwise-prop-C a'\n          ( transport A C a a' (first (is-prop-A a a')) c)\n          ( c'))))\n</code></pre> <p>Conversely, if the total type <code>total-type A C</code> is a proposition, then so is every fiber <code>C a</code>.</p> <pre><code>#def is-fiberwise-prop-is-prop-total-type-is-prop-base uses (is-prop-A)\n( is-prop-\u03a3C : is-prop (total-type A C))\n( a : A)\n  : is-prop (C a)\n  :=\n    is-prop-all-elements-equal (C a)\n    ( \\ c c' \u2192\n      transport\n      ( a = a)\n      ( \\ p \u2192 transport A C a a p c = c')\n      ( first-path-\u03a3 A C (a, c) (a, c') ( first (is-prop-\u03a3C (a, c) (a, c'))))\n      ( refl)\n      ( all-paths-equal-is-prop A is-prop-A a a\n        ( first-path-\u03a3 A C (a, c) (a, c') ( first (is-prop-\u03a3C (a, c) (a, c'))))\n        ( refl))\n      ( second-path-\u03a3 A C (a, c) (a, c') ( first (is-prop-\u03a3C (a, c) (a, c')))))\n#end families-over-propositions\n</code></pre>"},{"location":"hott/09-propositions.rzk/#propositions-and-embeddings","title":"Propositions and embeddings","text":"<p>A map <code>f : A \u2192 B</code> is an embedding if and only if its fibers are propositions.</p> <pre><code>#def is-contr-image-based-paths-is-emb\n( A B : U)\n( f : A \u2192 B)\n( is-emb-f : is-emb A B f)\n( x : A)\n  : is-contr (\u03a3 (y : A) , f x = f y)\n  :=\n  is-contr-total-are-equiv-from-paths A x\n  ( \\ y \u2192 f x = f y)\n  ( \\ y \u2192 ap A B x y f)\n  ( \\ y \u2192 is-emb-f x y)\n#def is-contr-image-endpoint-based-paths-is-emb\n( A B : U)\n( f : A \u2192 B)\n( is-emb-f : is-emb A B f)\n( y : A)\n  : is-contr (\u03a3 (x : A) , f x = f y)\n  :=\n    is-contr-equiv-is-contr'\n( \u03a3 (x : A) , f x = f y)\n( \u03a3 (x : A) , f y = f x)\n    ( total-equiv-family-of-equiv A (\\ x \u2192 f x = f y) (\\ x \u2192 f y = f x)\n      ( \\ x \u2192 equiv-rev B (f x) (f y)))\n    ( is-contr-image-based-paths-is-emb A B f is-emb-f y)\n#def is-contr-fib-over-image-is-emb\n( A B : U)\n( f : A \u2192 B)\n( is-emb-f : is-emb A B f)\n( y : A)\n  : is-contr (fib A B f (f y))\n  := is-contr-image-endpoint-based-paths-is-emb A B f is-emb-f y\n#def is-contr-is-inhabited-fib-is-emb\n( A B : U)\n( f : A \u2192 B)\n( is-emb-f : is-emb A B f)\n  : ( b : B) \u2192 is-contr-is-inhabited (fib A B f b)\n  :=\n  ind-fib A B f\n  ( \\ b p \u2192 is-contr (fib A B f b))\n  ( \\ a \u2192 is-contr-fib-over-image-is-emb A B f is-emb-f a)\n#def is-prop-fib-is-emb\n( A B : U)\n( f : A \u2192 B)\n( is-emb-f : is-emb A B f)\n( b : B)\n  : is-prop (fib A B f b)\n  :=\n  is-prop-is-contr-is-inhabited (fib A B f b)\n  ( is-contr-is-inhabited-fib-is-emb A B f is-emb-f b)\n#def is-contr-image-based-paths-is-contr-is-inhabited-fib\n( A B : U)\n( f : A \u2192 B)\n( is-contr-is-inhabited-fib-f : (b : B) \u2192 is-contr-is-inhabited (fib A B f b))\n( x : A)\n  : is-contr (\u03a3 (y : A) , f x = f y)\n  :=\n  is-contr-equiv-is-contr'\n( \u03a3 (y : A) , f x = f y)\n( \u03a3 (y : A) , f y = f x)\n  ( total-equiv-family-of-equiv A (\\ y \u2192 f x = f y) (\\ y \u2192 f y = f x)\n    ( \\ y \u2192 equiv-rev B (f x) (f y)))\n  ( is-contr-is-inhabited-fib-f (f x) ((x, refl)))\n#def is-emb-is-contr-is-inhabited-fib\n( A B : U)\n( f : A \u2192 B)\n( is-contr-is-inhabited-fib-f : (b : B) \u2192 is-contr-is-inhabited (fib A B f b))\n  : is-emb A B f\n  :=\n\\ x y \u2192\n  are-equiv-from-paths-is-contr-total A x (\\ z \u2192 f x = f z)(\\ z \u2192 ap A B x z f)\n  ( is-contr-image-based-paths-is-contr-is-inhabited-fib A B f is-contr-is-inhabited-fib-f x) y\n#def is-emb-is-prop-fib\n( A B : U)\n( f : A \u2192 B)\n( is-prop-fib-f : (b : B) \u2192 is-prop (fib A B f b))\n  : is-emb A B f\n  :=\n  is-emb-is-contr-is-inhabited-fib A B f\n  ( \\ b \u2192 is-contr-is-inhabited-is-prop (fib A B f b) (is-prop-fib-f b))\n#def is-emb-iff-is-prop-fib\n( A B : U)\n( f : A \u2192 B)\n  : iff (is-emb A B f) ((b : B) \u2192 is-prop (fib A B f b))\n  := (is-prop-fib-is-emb A B f, is-emb-is-prop-fib A B f)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#subtypes","title":"Subtypes","text":"<p>A family of propositions <code>P : A \u2192 U</code> over a type <code>A</code> may be thought of as a predicate.</p> <pre><code>#def is-predicate\n( A : U)\n( P : A \u2192 U)\n  : U\n  := (a : A) \u2192 is-prop (P a)\n</code></pre> <p>When <code>P</code> is a predicate on <code>A</code> then <code>total-type A P</code> is referred to a subtype of <code>A</code>.</p> <pre><code>#def is-emb-subtype-projection\n( A : U)\n( P : A \u2192 U)\n( is-predicate-P : is-predicate A P)\n  : is-emb (total-type A P) A (projection-total-type A P)\n  :=\n  is-emb-is-prop-fib (total-type A P) A (projection-total-type A P)\n  ( \\ a \u2192\n    is-prop-Equiv-is-prop'\n    ( P a) ( fib (total-type A P) A (projection-total-type A P) a)\n    ( equiv-homotopy-fiber-strict-fiber A P a) (is-predicate-P a))\n</code></pre> <p>The subtype projection embedding reflects identifications.</p> <pre><code>#def subtype-eq-reflection\n( A : U)\n( P : A \u2192 U)\n( is-predicate-P : is-predicate A P)\n  : ( (a, p) : total-type A P)\n    \u2192 ( (b, q) : total-type A P)\n    \u2192 (a = b) \u2192 (a, p) =_{total-type A P} (b, q)\n  :=\n  inv-ap-is-emb (total-type A P) A (projection-total-type A P)\n  ( is-emb-subtype-projection A P is-predicate-P)\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/","title":"10. Trivial fibrations","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>In what follows we show that the projection from the total space of a Sigma type is an equivalence if and only if its fibers are contractible.</p>"},{"location":"hott/10-trivial-fibrations.rzk/#contractible-fibers","title":"Contractible fibers","text":"<p>The following type asserts that the fibers of a type family are contractible.</p> <pre><code>#def contractible-fibers\n( A : U)\n( B : A \u2192 U)\n  : U\n  := ((x : A) \u2192 is-contr (B x))\n#section contractible-fibers-data\n#variable A : U\n#variable B : A \u2192 U\n#variable contractible-fibers-A-B : contractible-fibers A B\n</code></pre> The center of contraction in contractible fibers<pre><code>#def contractible-fibers-section\n  : (x : A) \u2192 B x\n  := \\ x \u2192 center-contraction (B x) (contractible-fibers-A-B x)\n</code></pre> The section of the total space projection built from the contraction centers<pre><code>#def contractible-fibers-actual-section uses (contractible-fibers-A-B)\n  : (a : A) \u2192 \u03a3 (x : A) , B x\n  := \\ a \u2192 (a , contractible-fibers-section a)\n#def contractible-fibers-section-htpy uses (contractible-fibers-A-B)\n  : homotopy A A\n( comp A (\u03a3 (x : A) , B x) A\n      ( projection-total-type A B) (contractible-fibers-actual-section))\n    ( identity A)\n  := \\ x \u2192 refl\n#def contractible-fibers-section-is-section uses (contractible-fibers-A-B)\n  : has-section (\u03a3 (x : A) , B x) A (projection-total-type A B)\n  := (contractible-fibers-actual-section , contractible-fibers-section-htpy)\n</code></pre> <p>This can be used to define the retraction homotopy for the total space projection, called <code>first</code> here:</p> <pre><code>#def contractible-fibers-retraction-htpy\n  : (z : \u03a3 (x : A) , B x) \u2192\n      (contractible-fibers-actual-section) (first z) = z\n  :=\n\\ z \u2192\n    eq-eq-fiber-\u03a3 A B\n      ( first z)\n      ( (contractible-fibers-section) (first z))\n      ( second z)\n      ( homotopy-contraction (B (first z)) (contractible-fibers-A-B (first z)) (second z))\n#def contractible-fibers-retraction uses (contractible-fibers-A-B)\n  : has-retraction (\u03a3 (x : A) , B x) A (projection-total-type A B)\n  := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy)\n</code></pre> <p>The first half of our main result:</p> <pre><code>#def is-equiv-projection-contractible-fibers uses (contractible-fibers-A-B)\n  : is-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B)\n  := (contractible-fibers-retraction , contractible-fibers-section-is-section)\n#def equiv-projection-contractible-fibers uses (contractible-fibers-A-B)\n  : Equiv (\u03a3 (x : A) , B x) A\n  := (projection-total-type A B , is-equiv-projection-contractible-fibers)\n#end contractible-fibers-data\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/#projection-equivalences","title":"Projection equivalences","text":"<p>From a projection equivalence, it's not hard to inhabit fibers:</p> <pre><code>#def inhabited-fibers-is-equiv-projection\n( A : U)\n( B : A \u2192 U)\n( proj-B-to-A-is-equiv : is-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B))\n( a : A)\n  : B a\n  :=\n    transport A B (first ((first (second proj-B-to-A-is-equiv)) a)) a\n      ( (second (second proj-B-to-A-is-equiv)) a)\n      ( second ((first (second proj-B-to-A-is-equiv)) a))\n</code></pre> <p>This is great but we need more coherence to show that the inhabited fibers are contractible; the following proof fails:</p> <pre><code>#def is-equiv-projection-implies-contractible-fibers\n  ( A : U)\n  ( B : A \u2192 U)\n  ( proj-B-to-A-is-equiv : is-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B))\n  : contractible-fibers A B\n  :=\n    ( \\ x \u2192 (second (first (first proj-B-to-A-is-equiv) x) ,\n      ( \\ u \u2192\n        second-path-\u03a3 A B (first (first proj-B-to-A-is-equiv) x) (x , u)\n          ( second (first proj-B-to-A-is-equiv) (x , u)))))\n</code></pre> <pre><code>#section projection-hae-data\n#variable A : U\n#variable B : A \u2192 U\n#variable proj-B-to-A-is-half-adjoint-equivalence :\n  is-half-adjoint-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B)\n#variable w : (\u03a3 (x : A) , B x)\n</code></pre> <p>We start over from a stronger hypothesis of a half adjoint equivalence.</p> <pre><code>#def projection-hae-inverse\n(a : A)\n  : \u03a3 (x : A) , B x\n  := (first (first proj-B-to-A-is-half-adjoint-equivalence)) a\n#def projection-hae-base-htpy uses (B)\n(a : A)\n  : (first (projection-hae-inverse a)) = a\n  := (second (second (first proj-B-to-A-is-half-adjoint-equivalence))) a\n#def projection-hae-section uses (proj-B-to-A-is-half-adjoint-equivalence)\n(a : A)\n  : B a\n  :=\n    transport A B (first (projection-hae-inverse a)) a\n      ( projection-hae-base-htpy a)\n      ( second (projection-hae-inverse a))\n#def projection-hae-total-htpy\n  : (projection-hae-inverse (first w)) = w\n  := (first (second (first proj-B-to-A-is-half-adjoint-equivalence))) w\n#def projection-hae-fibered-htpy\n  : (transport A B (first ((projection-hae-inverse (first w)))) (first w)\n    ( first-path-\u03a3 A B\n      ( projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy))\n    ( second (projection-hae-inverse (first w)))) =\n    ( second w)\n  :=\n    second-path-\u03a3 A B (projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy)\n#def projection-hae-base-coherence\n  : ( projection-hae-base-htpy (first w)) =\n    ( first-path-\u03a3 A B (projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy))\n  := (second proj-B-to-A-is-half-adjoint-equivalence) w\n#def projection-hae-transport-coherence\n  : ( projection-hae-section (first w)) =\n    ( transport A B (first ((projection-hae-inverse (first w)))) (first w)\n      ( first-path-\u03a3 A B\n        ( projection-hae-inverse (first w)) w\n        ( projection-hae-total-htpy))\n      ( second (projection-hae-inverse (first w))))\n  :=\n    transport2 A B (first (projection-hae-inverse (first w))) (first w)\n    ( projection-hae-base-htpy (first w))\n    ( first-path-\u03a3 A B (projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy))\n    ( projection-hae-base-coherence)\n    ( second (projection-hae-inverse (first w)))\n#def projection-hae-fibered-homotopy-contraction\n  : (projection-hae-section (first w)) =_{B (first w)} (second w)\n  :=\n    concat (B (first w))\n      ( projection-hae-section (first w))\n      ( transport A B\n        ( first ((projection-hae-inverse (first w))))\n        ( first w)\n        ( first-path-\u03a3 A B (projection-hae-inverse (first w)) w\n          ( projection-hae-total-htpy))\n        ( second (projection-hae-inverse (first w))))\n      ( second w)\n      ( projection-hae-transport-coherence)\n      ( projection-hae-fibered-htpy)\n#end projection-hae-data\n</code></pre> <p>Finally, we have:</p> <pre><code>#def contractible-fibers-is-half-adjoint-equiv-projection\n( A : U)\n( B : A \u2192 U)\n( proj-B-to-A-is-half-adjoint-equivalence\n    : is-half-adjoint-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B))\n  : contractible-fibers A B\n  :=\n\\ x \u2192\n      ( (projection-hae-section A B proj-B-to-A-is-half-adjoint-equivalence x) ,\n\\ u \u2192\n          projection-hae-fibered-homotopy-contraction\n          A B proj-B-to-A-is-half-adjoint-equivalence (x , u))\n</code></pre> The converse to our first result<pre><code>#def contractible-fibers-is-equiv-projection\n( A : U)\n( B : A \u2192 U)\n( proj-B-to-A-is-equiv\n    : is-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B))\n  : contractible-fibers A B\n  :=\n    contractible-fibers-is-half-adjoint-equiv-projection A B\n( is-half-adjoint-equiv-is-equiv (\u03a3 (x : A) , B x) A\n        ( projection-total-type A B) proj-B-to-A-is-equiv)\n</code></pre> The main theorem<pre><code>#def projection-theorem\n( A : U)\n( B : A \u2192 U)\n  : iff\n( is-equiv (\u03a3 (x : A) , B x) A (projection-total-type A B))\n    ( contractible-fibers A B)\n  :=\n    ( \\ proj-B-to-A-is-equiv \u2192\n      contractible-fibers-is-equiv-projection A B proj-B-to-A-is-equiv ,\n\\ contractible-fibers-A-B \u2192\n      is-equiv-projection-contractible-fibers A B contractible-fibers-A-B)\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/#equivalence-between-domain-and-sum-of-fibers","title":"Equivalence between domain and sum of fibers","text":"<p>For any map <code>f : A \u2192 B</code> the domain <code>A</code> is equivalent to the sum of the fibers.</p> <pre><code>#def equiv-sum-of-fibers-domain\n( A B : U)\n( f : A \u2192 B)\n  : Equiv A (\u03a3 (b : B), fib A B f b)\n  :=\n    equiv-left-cancel\n( \u03a3 (a : A), \u03a3 (b : B), f a = b)\n    ( A)\n( \u03a3 (b : B), fib A B f b)\n( equiv-projection-contractible-fibers\n      A\n      ( \\ a \u2192 \u03a3 (b : B), f a = b)\n      ( \\ a \u2192 is-contr-based-paths B (f a)))\n    ( fubini-\u03a3 A B (\\ a b \u2192 f a = b))\n</code></pre> <p>The inverse map is just the canonical projection to <code>A</code>.</p> <pre><code>#def is-equiv-domain-sum-of-fibers\n( A B : U)\n( f : A \u2192 B)\n  : is-equiv (\u03a3 (b : B), fib A B f b) A ( \\ (_ , (a , _)) \u2192 a)\n  :=\nsecond\n( inv-equiv A (\u03a3 (b : B) , fib A B f b)\n      ( equiv-sum-of-fibers-domain A B f))\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/#equivalence-between-fibers-in-equivalent-domains","title":"Equivalence between fibers in equivalent domains","text":"<p>As an application of the main theorem, we show that precomposing with an equivalence preserves fibers up to equivalence.</p> <pre><code>#def equiv-fibers-equiv-domains\n( A B C : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( is-equiv-f : is-equiv A B f)\n( c : C)\n  : Equiv (fib A C (comp A B C g f) c) (fib B C g c)\n  :=\n  equiv-comp\n  ( fib A C ( comp A B C g f) c)\n  ( \u03a3 ((b, _) : fib B C g c), fib A B f b)\n  ( fib B C g c)\n  ( equiv-fiber-sum-fiber-comp A B C f g c)\n  ( ( projection-total-type (fib B C g c) (\\ (b, _) \u2192 fib A B f b))\n    , second\n      ( projection-theorem (fib B C g c) (\\ (b, _) \u2192 fib A B f b))\n      ( \\ (b, _) \u2192 (is-contr-map-is-equiv A B f is-equiv-f) b))\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/","title":"11. Homotopy cartesian squares","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#homotopy-cartesian-squares","title":"Homotopy cartesian squares","text":"<p>We start by fixing the data of a map between two type families <code>A' \u2192 U</code> and <code>A \u2192 U</code>, which we think of as a commutative square</p> <pre><code>\u03a3 A' \u2192 \u03a3 A\n \u2193      \u2193\n A'  \u2192  A\n</code></pre> <pre><code>#section homotopy-cartesian\n-- We prepend all local names in this section\n-- with the random identifier temp-uBDx\n-- to avoid cluttering the global name space.\n-- Once rzk supports local variables, these should be renamed.\n#variable A' : U\n#variable C' : A' \u2192 U\n#variable A : U\n#variable C : A \u2192 U\n#variable \u03b1 : A' \u2192 A\n#variable \u03b3 : (a' : A') \u2192 C' a' \u2192 C (\u03b1 a')\n#def temp-uBDx-\u03a3\u03b1\u03b3\n  : total-type A' C' \u2192 total-type A C\n  := \\ (a', c') \u2192 (\u03b1 a', \u03b3 a' c')\n</code></pre> <p>We say that such a square is homotopy cartesian just if it induces an equivalence componentwise.</p> <pre><code>#def is-homotopy-cartesian uses (A)\n  : U\n  :=\n( a' : A') \u2192 is-equiv (C' a') (C (\u03b1 a')) (\u03b3 a')\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#interaction-with-horizontal-equivalences","title":"Interaction with horizontal equivalences","text":"<p>We implement various ways homotopy-cartesian squares interact with horizontal equivalences.</p> <p>For example, if the lower map <code>\u03b1 : A' \u2192 A</code> is an equivalence in a homotopy cartesian square, then so is the upper one <code>\u03a3\u03b1\u03b3 : \u03a3 C' \u2192 \u03a3 C</code>.</p> <pre><code>#def temp-uBDx-comp\n  : (total-type A' C') \u2192 (total-type A C)\n  := comp\n      ( total-type A' C')\n( \u03a3 (a' : A'), C (\u03b1 a'))\n      ( total-type A C)\n      ( \\ (a', c) \u2192 (\u03b1 a', c) )\n      ( total-map A' C' (\\ a' \u2192 C (\u03b1 a')) \u03b3)\n#def pull-up-equiv-is-homotopy-cartesian\n( is-hc-\u03b1-\u03b3 : is-homotopy-cartesian)\n( is-equiv-\u03b1 : is-equiv A' A \u03b1)\n  : is-equiv (total-type A' C') (total-type A C) (\\ (a', c') \u2192 (\u03b1 a', \u03b3 a' c'))\n  :=\n    is-equiv-homotopy\n      ( total-type A' C')\n      ( total-type A C)\n      ( temp-uBDx-\u03a3\u03b1\u03b3 )\n      ( temp-uBDx-comp )\n      (\\ _ \u2192 refl)\n      ( is-equiv-comp\n        ( total-type A' C')\n( \u03a3 (a' : A'), C (\u03b1 a'))\n        ( total-type A C)\n        ( total-map A' C' (\\ a' \u2192 C (\u03b1 a')) \u03b3)\n        ( is-equiv-total-is-equiv-fiberwise A' C'\n          ( \\ a' \u2192 C (\u03b1 a') )\n          ( \u03b3)\n          ( \\ a' \u2192 is-hc-\u03b1-\u03b3 a'))\n        ( \\ (a', c) \u2192 (\u03b1 a', c) )\n        ( second\n          ( equiv-total-pullback-is-equiv A' A \u03b1\n            ( is-equiv-\u03b1 )\n            ( C ))))\n</code></pre> <p>Conversely, if both the upper and the lower maps are equivalences, then the square is homotopy-cartesian.</p> <pre><code>#def is-homotopy-cartesian-is-horizontal-equiv\n( is-equiv-\u03b1 : is-equiv A' A \u03b1)\n( is-equiv-\u03a3\u03b1\u03b3 : is-equiv\n      (total-type A' C') (total-type A C) (\\ (a', c') \u2192 (\u03b1 a', \u03b3 a' c'))\n  )\n  : is-homotopy-cartesian\n  :=\n    is-equiv-fiberwise-is-equiv-total\n        A' C' ( \\ x \u2192 C (\u03b1 x) ) \u03b3\n        ( is-equiv-right-factor\n            ( total-type A' C')\n( \u03a3 (x : A'), C (\u03b1 x))\n            ( total-type A C)\n            ( total-map A' C' (\\ x \u2192 C (\u03b1 x)) \u03b3)\n            ( \\ (x, c) \u2192 (\u03b1 x, c) )\n            ( second ( equiv-total-pullback-is-equiv A' A \u03b1 is-equiv-\u03b1 C))\n            ( is-equiv-homotopy\n                ( total-type A' C')\n                ( total-type A C )\n                ( temp-uBDx-comp )\n                ( temp-uBDx-\u03a3\u03b1\u03b3 )\n                ( \\ _ \u2192 refl)\n                ( is-equiv-\u03a3\u03b1\u03b3)))\n</code></pre> <p>In a general homotopy-cartesian square we cannot deduce <code>is-equiv \u03b1</code> from <code>is-equiv (\u03a3\u03b3)</code>. However, if the square has a vertical section then we can always do this (whether the square is homotopy-cartesian or not).</p> <pre><code>#def has-section-family-over-map\n  : U\n  :=\n\u03a3 ( ( s', s) : product ((a' : A') \u2192 C' a') ((a : A) \u2192 C a) ),\n( (a' : A') \u2192 \u03b3 a' (s' a') = s (\u03b1 a'))\n#def induced-map-on-fibers-\u03a3 uses (\u03b3)\n( c\u0302 : total-type A C)\n  ( (c\u0302', q\u0302) : fib\n                (total-type A' C') (total-type A C)\n                (\\ (a', c') \u2192 (\u03b1 a', \u03b3 a' c'))\n                c\u0302)\n  : fib A' A \u03b1 (first c\u0302)\n  :=\n    (first c\u0302', first-path-\u03a3 A C (temp-uBDx-\u03a3\u03b1\u03b3 c\u0302') c\u0302 q\u0302)\n#def temp-uBDx-helper-type uses (\u03b3 C')\n  ( ((s', s) , \u03b7) : has-section-family-over-map)\n( a : A )\n  ( (a', p) : fib A' A \u03b1 a )\n  : U\n  :=\n\u03a3 ( q\u0302 : temp-uBDx-\u03a3\u03b1\u03b3 (a', s' a') = (a, s a)),\n        ( induced-map-on-fibers-\u03a3 (a, s a) ((a', s' a'), q\u0302) = (a', p))\n#def temp-uBDx-helper uses (\u03b3 C')\n  ( ((s', s) , \u03b7) : has-section-family-over-map)\n  : ( a : A) \u2192\n    ( (a', p) : fib A' A \u03b1 a ) \u2192\n    temp-uBDx-helper-type ((s',s), \u03b7) a (a', p)\n  :=\n    ind-fib A' A \u03b1\n    ( temp-uBDx-helper-type ((s',s), \u03b7))\n    ( \\ a' \u2192\n      ( eq-pair A C (\u03b1 a', \u03b3 a' (s' a')) (\u03b1 a', s (\u03b1 a')) ( refl, \u03b7 a' ) ,\n        eq-pair\n        ( A')\n        ( \\ x \u2192 \u03b1 x = \u03b1 a')\n        ( a' ,\n          first-path-\u03a3 A C\n          ( \u03b1 a', \u03b3 a' (s' a'))\n          ( \u03b1 a', s (\u03b1 a'))\n          ( eq-pair A C (\u03b1 a', \u03b3 a' (s' a')) (\u03b1 a', s (\u03b1 a')) ( refl, \u03b7 a' )))\n        ( a' , refl)\n        ( refl ,\n          first-path-\u03a3-eq-pair\n            A C (\u03b1 a', \u03b3 a' (s' a')) (\u03b1 a', s (\u03b1 a')) ( refl, \u03b7 a' ))))\n#def induced-retraction-on-fibers-with-section uses (\u03b3)\n  ( ((s',s),\u03b7) : has-section-family-over-map)\n( a : A )\n  : ( is-retract-of\n      ( fib A' A \u03b1 a )\n      ( fib\n        ( total-type A' C') (total-type A C)\n        ( \\ (a', c') \u2192 (\u03b1 a', \u03b3 a' c'))\n        ( a, s a)))\n  :=\n    ( \\ (a', p) \u2192 ( (a', s' a'), first (temp-uBDx-helper ((s',s),\u03b7) a (a',p))),\n      ( induced-map-on-fibers-\u03a3 (a, s a) ,\n        \\ (a', p) \u2192 second (temp-uBDx-helper ((s',s),\u03b7) a (a',p))))\n#def push-down-equiv-with-section uses (\u03b3)\n  ( ((s',s),\u03b7) : has-section-family-over-map)\n( is-equiv-\u03a3\u03b1\u03b3 : is-equiv\n      (total-type A' C') (total-type A C) temp-uBDx-\u03a3\u03b1\u03b3)\n  : is-equiv A' A \u03b1\n  :=\n    is-equiv-is-contr-map A' A \u03b1\n    ( \\ a \u2192\n      is-contr-is-retract-of-is-contr\n      ( fib A' A \u03b1 a)\n      ( fib (total-type A' C') (total-type A C) (temp-uBDx-\u03a3\u03b1\u03b3) (a, s a))\n      ( induced-retraction-on-fibers-with-section ((s',s),\u03b7) a)\n      ( is-contr-map-is-equiv\n        ( total-type A' C') (total-type A C)\n        ( temp-uBDx-\u03a3\u03b1\u03b3)\n        ( is-equiv-\u03a3\u03b1\u03b3 )\n        ( a , s a)))\n#end homotopy-cartesian\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#invariance-under-pullbacks","title":"Invariance under pullbacks","text":"<p>We can pullback a homotopy cartesian square over <code>\u03b1 : A' \u2192 A</code> along any map of maps <code>\u03b2 \u2192 \u03b1</code> and obtain another homotopy cartesian square.</p> <pre><code>#def is-homotopy-cartesian-pullback\n( A' : U)\n( C' : A' \u2192 U)\n( A : U)\n( C : A \u2192 U)\n( \u03b1 : A' \u2192 A)\n( \u03b3 : ( a' : A') \u2192 C' a' \u2192 C (\u03b1 a'))\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( ((s', s), \u03b7) : map-of-maps B' B \u03b2 A' A \u03b1)\n( is-hc-\u03b1 : is-homotopy-cartesian A' C' A C \u03b1 \u03b3)\n  : is-homotopy-cartesian\n      B' ( \\ b' \u2192 C' (s' b'))\n      B  ( \\ b \u2192 C (s b))\n      \u03b2  ( \\ b' c' \u2192 transport A C (\u03b1 (s' b')) (s (\u03b2 b')) (\u03b7 b') (\u03b3 (s' b') c'))\n  :=\n\\ b' \u2192\n      is-equiv-comp (C' (s' b')) (C (\u03b1 (s' b'))) (C (s (\u03b2 b')))\n        ( \u03b3 (s' b'))\n        ( is-hc-\u03b1 (s' b'))\n        ( transport A C (\u03b1 (s' b')) (s (\u03b2 b')) (\u03b7 b'))\n        ( is-equiv-transport A C (\u03b1 (s' b')) (s (\u03b2 b')) (\u03b7 b'))\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#pasting-calculus-for-homotopy-cartesian-squares","title":"Pasting calculus for homotopy cartesian squares","text":"<p>Currently our notion of squares is not symmetric, since the vertical maps are given by type families, i.e. they are display maps, while the horizontal maps are arbitrary. Therefore we distinquish between the vertical and the horizontal pasting calculus.</p>"},{"location":"hott/11-homotopy-pullbacks.rzk/#vertical-calculus","title":"Vertical calculus","text":"<p>The following vertical composition and cancellation laws follow easily from the corresponding statements about equivalences established above.</p> <pre><code>#section homotopy-cartesian-vertical-calculus\n#variable A' : U\n#variable C' : A' \u2192 U\n#variable D' : ( a' : A') \u2192 C' a' \u2192 U\n#variable A : U\n#variable C : A \u2192 U\n#variable D : (a : A) \u2192 C a \u2192 U\n#variable \u03b1 : A' \u2192 A\n#variable \u03b3 : (a' : A') \u2192 C' a' \u2192 C (\u03b1 a')\n#variable \u03b4 : (a' : A') \u2192 (c' : C' a') \u2192 D' a' c' \u2192 D (\u03b1 a') (\u03b3 a' c')\n#def is-homotopy-cartesian-upper\n  : U\n  := ( is-homotopy-cartesian\n       ( total-type A' C')\n       ( \\ (a', c') \u2192 D' a' c')\n       ( total-type A C)\n       ( \\ (a, c) \u2192 D a c)\n       ( \\ (a', c') \u2192 (\u03b1 a', \u03b3 a' c'))\n       ( \\ (a', c') \u2192 \u03b4 a' c'))\n#def is-homotopy-cartesian-upper-to-fibers uses (A)\n( is-hc-\u03b3-\u03b4 : is-homotopy-cartesian-upper)\n( a' : A')\n  : is-homotopy-cartesian (C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a')\n  :=\n\\ c' \u2192 is-hc-\u03b3-\u03b4 (a', c')\n#def is-homotopy-cartesian-upper-from-fibers uses (A)\n( is-fiberwise-hc-\u03b3-\u03b4\n    : ( a' : A') \u2192\n      is-homotopy-cartesian (C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a'))\n  : is-homotopy-cartesian-upper\n  :=\n    \\ (a', c') \u2192 is-fiberwise-hc-\u03b3-\u03b4 a' c'\n#def is-homotopy-cartesian-vertical-pasted\n  : U\n  :=\n    is-homotopy-cartesian\n      A' (\\ a' \u2192 total-type (C' a') (D' a'))\n      A (\\ a \u2192 total-type (C a) (D a))\n      \u03b1 (\\ a' (c', d') \u2192 (\u03b3 a' c', \u03b4 a' c' d'))\n#def is-homotopy-cartesian-vertical-pasting\n( is-hc-\u03b1-\u03b3 : is-homotopy-cartesian A' C' A C \u03b1 \u03b3 )\n( is-hc-\u03b3-\u03b4 : is-homotopy-cartesian-upper)\n  : is-homotopy-cartesian-vertical-pasted\n  :=\n\\ a' \u2192\n      pull-up-equiv-is-homotopy-cartesian\n        (C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a')\n        ( is-homotopy-cartesian-upper-to-fibers is-hc-\u03b3-\u03b4 a')\n        ( is-hc-\u03b1-\u03b3 a' )\n#def is-homotopy-cartesian-vertical-pasting-from-fibers\n( is-hc-\u03b1-\u03b3 : is-homotopy-cartesian A' C' A C \u03b1 \u03b3 )\n( is-fiberwise-hc-\u03b3-\u03b4\n    : ( a' : A') \u2192\n      is-homotopy-cartesian (C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a'))\n  : is-homotopy-cartesian-vertical-pasted\n  :=\n    is-homotopy-cartesian-vertical-pasting\n      is-hc-\u03b1-\u03b3\n      ( is-homotopy-cartesian-upper-from-fibers is-fiberwise-hc-\u03b3-\u03b4)\n#def is-homotopy-cartesian-lower-cancel-to-fibers\n( is-hc-\u03b1-\u03b3 : is-homotopy-cartesian A' C' A C \u03b1 \u03b3 )\n( is-hc-\u03b1-\u03b4 : is-homotopy-cartesian-vertical-pasted)\n( a' : A')\n  : is-homotopy-cartesian (C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a')\n  :=\n    is-homotopy-cartesian-is-horizontal-equiv\n      ( C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a')\n      ( is-hc-\u03b1-\u03b3 a')\n      ( is-hc-\u03b1-\u03b4 a')\n#def is-homotopy-cartesian-lower-cancel uses (D D' \u03b4)\n( is-hc-\u03b1-\u03b3 : is-homotopy-cartesian A' C' A C \u03b1 \u03b3 )\n( is-hc-\u03b1-\u03b4 : is-homotopy-cartesian-vertical-pasted\n  )\n  : is-homotopy-cartesian-upper\n  :=\n    is-homotopy-cartesian-upper-from-fibers\n      (is-homotopy-cartesian-lower-cancel-to-fibers is-hc-\u03b1-\u03b3 is-hc-\u03b1-\u03b4)\n#def is-homotopy-cartesian-upper-cancel-with-section\n( has-sec-\u03b3-\u03b4 : (a' : A') \u2192\n      has-section-family-over-map\n        (C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a'))\n( is-hc-\u03b1-\u03b4 : is-homotopy-cartesian-vertical-pasted)\n  : is-homotopy-cartesian A' C' A C \u03b1 \u03b3\n  :=\n\\ a' \u2192\n      push-down-equiv-with-section\n      ( C' a') (D' a') (C (\u03b1 a')) (D (\u03b1 a')) (\u03b3 a') (\u03b4 a')\n      ( has-sec-\u03b3-\u03b4 a')\n      ( is-hc-\u03b1-\u03b4 a')\n#end homotopy-cartesian-vertical-calculus\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#horizontal-calculus","title":"Horizontal calculus","text":"<p>We also have the horizontal version of pasting and cancellation which follows from composition and cancelling laws for equivalences.</p> <pre><code>#section homotopy-cartesian-horizontal-calculus\n#variable A'' : U\n#variable C'' : A'' \u2192 U\n#variable A' : U\n#variable C' : A' \u2192 U\n#variable A : U\n#variable C : A \u2192 U\n#variable f' : A'' \u2192 A'\n#variable F' : (a'' : A'') \u2192 C'' a'' \u2192 C' (f' a'')\n#variable f : A' \u2192 A\n#variable F : (a' : A') \u2192 C' a' \u2192 C (f a')\n#def is-homotopy-cartesian-horizontal-pasting\n( ihc : is-homotopy-cartesian A' C' A C f F)\n( ihc' : is-homotopy-cartesian A'' C'' A' C' f' F')\n  : is-homotopy-cartesian A'' C'' A C\n    ( comp A'' A' A f f')\n    ( \\ a'' \u2192\n        comp (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n         (F (f' a'')) (F' a''))\n  :=\n\\ a'' \u2192\n    is-equiv-comp (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n      (F' a'') (ihc' a'')\n      (F (f' a'')) (ihc (f' a''))\n#def is-homotopy-cartesian-right-cancel\n( ihc : is-homotopy-cartesian A' C' A C f F)\n( ihc'' : is-homotopy-cartesian A'' C'' A C\n              ( comp A'' A' A f f')\n              ( \\ a'' \u2192\n                comp (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n                  (F (f' a'')) (F' a'')))\n  : is-homotopy-cartesian A'' C'' A' C' f' F'\n  :=\n\\ a'' \u2192\n    is-equiv-right-factor (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n    ( F' a'') (F (f' a''))\n    ( ihc (f' a''))\n    ( ihc'' a'')\n</code></pre> <p>We can cancel the left homotopy cartesian square if its lower map <code>f' : A'' \u2192 A'</code> has a section.</p> <pre><code>#def is-homotopy-cartesian-left-cancel-with-lower-section\n( has-section-f' : has-section A'' A' f')\n( ihc' : is-homotopy-cartesian A'' C'' A' C' f' F')\n( ihc'' : is-homotopy-cartesian A'' C'' A C\n              ( comp A'' A' A f f')\n              ( \\ a'' \u2192\n                comp (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n                  (F (f' a'')) (F' a'')))\n  : is-homotopy-cartesian A' C' A C f F\n  :=\n    ind-has-section A'' A' f' has-section-f'\n    ( \\ a' \u2192 is-equiv (C' a') (C (f a')) (F a'))\n    ( \\ a'' \u2192\n      is-equiv-left-factor (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n      ( F' a'') (ihc' a'')\n      ( F (f' a'')) ( ihc'' a''))\n</code></pre> <p>In fact, it suffices to assume that the left square has horizontal sections.</p> <pre><code>#def is-homotopy-cartesian-left-cancel-with-section\n( has-section-f' : has-section A'' A' f')\n( has-sections-F' : (a'' : A'') \u2192 has-section (C'' a'') (C' (f' a'')) (F' a''))\n( ihc'' : is-homotopy-cartesian A'' C'' A C\n              ( comp A'' A' A f f')\n              ( \\ a'' \u2192\n                comp (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n                  (F (f' a'')) (F' a'')))\n  : is-homotopy-cartesian A' C' A C f F\n  :=\n    ind-has-section A'' A' f' has-section-f'\n    ( \\ a' \u2192 is-equiv (C' a') (C (f a')) (F a'))\n    ( \\ a'' \u2192\n      is-equiv-left-cancel (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n      ( F' a'') ( has-sections-F' a'')\n      ( F (f' a'')) ( ihc'' a''))\n#def is-homotopy-cartesian-left-cancel-with-section'\n  ( (sec-f' , \u03b5-f') : has-section A'' A' f')\n( has-sections-F'\n    : (a' : A')\n    \u2192 has-section (C'' (sec-f' a')) (C' (f' (sec-f' a'))) (F' (sec-f' a')))\n( ihc''\n    : is-homotopy-cartesian A'' C'' A C\n      ( comp A'' A' A f f')\n      ( \\ a'' \u2192\n        comp (C'' a'') (C' (f' a'')) (C (f (f' a'')))\n        ( F (f' a'')) (F' a'')))\n  : is-homotopy-cartesian A' C' A C f F\n  :=\n    ind-has-section' A'' A' f' (sec-f', \u03b5-f')\n    ( \\ a' \u2192 is-equiv (C' a') (C (f a')) (F a'))\n    ( \\ a' \u2192\n      is-equiv-left-cancel\n      ( C'' (sec-f' a')) (C' (f' (sec-f' a'))) (C (f (f' (sec-f' a'))))\n      ( F' (sec-f' a')) ( has-sections-F' a')\n      ( F (f' (sec-f' a'))) ( ihc'' (sec-f' a')))\n#end homotopy-cartesian-horizontal-calculus\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#homotopy-cartesian-faces-of-a-cube","title":"Homotopy cartesian faces of a cube","text":"<p>Consider two squares induced by type families as follows</p> <pre><code>#section is-homotopy-cartesian-in-cube\n#variable A' : U\n#variable C' : A' \u2192 U\n#variable A : U\n#variable C : A \u2192 U\n#variable \u03b1 : A' \u2192 A\n#variable \u03b3 : (a' : A') \u2192 C' a' \u2192 C (\u03b1 a')\n#variable B' : U\n#variable D' : B' \u2192 U\n#variable B : U\n#variable D : B \u2192 U\n#variable \u03b2 : B' \u2192 B\n#variable \u03b4 : (b' : B') \u2192 D' b' \u2192 D (\u03b2 b')\n</code></pre> <p>and a map between them in the following strict sense</p> <pre><code>#variable f' : A' \u2192 B'\n#variable f : A \u2192 B\n#variable h : (a' : A') \u2192 \u03b2 (f' a') = f (\u03b1 a')\n#variable F' : (a' : A') \u2192 C' a' \u2192 D' (f' a')\n#variable F : (a : A) \u2192 C a \u2192 D (f a)\n#variable H\n  : (a' : A')\n  \u2192 (c' : C' a')\n  \u2192 ( transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a')\n      ( \u03b4 (f' a') (F' a' c'))\n    = F (\u03b1 a') (\u03b3 a' c'))\n</code></pre> <p>We view this as a cube</p> <pre><code>      \u03a3 D'      \u03a3 D\n\n\u03a3 C'      \u03a3 C\n\n       B'        B\n\n A'        A\n</code></pre> <p>with display maps going down and ordinary maps going to the right and up-right.</p> <p>Assume furthermore that the two squares on the left and right are themselves homotopy cartesian.</p> <pre><code>#variable is-hc-CD' : is-homotopy-cartesian A' C' B' D' f' F'\n#variable is-hc-CD : is-homotopy-cartesian A C B D f F\n</code></pre> <p>If the square <code>B' D' B D</code> is homotopy cartesian, then so is <code>A' C' A C</code>.</p> <pre><code>#def is-homotopy-cartesian-in-cube\n  : is-homotopy-cartesian B' D' B D \u03b2 \u03b4\n  \u2192 is-homotopy-cartesian A' C' A C \u03b1 \u03b3\n  :=\n\\ is-hc-BD a' \u2192\n    is-equiv-equiv-is-equiv\n    ( C' a') (C (\u03b1 a')) (\u03b3 a')\n    ( D' (f' a')) (D (f (\u03b1 a')))\n    (\\ d' \u2192 transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a') (\u03b4 (f' a') d'))\n    ( ( F' a' ,  F (\u03b1 a')) , H a')\n    ( is-hc-CD' a')\n    ( is-hc-CD (\u03b1 a'))\n    ( is-equiv-comp\n      ( D' (f' a')) (D (\u03b2 (f' a'))) (D (f (\u03b1 a')))\n      ( \u03b4 (f' a')) (is-hc-BD (f' a'))\n      ( transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a'))\n      ( is-equiv-transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a')))\n</code></pre> <p>The converse holds provided that the map <code>f' : A' \u2192 B'</code> has a section.</p> <pre><code>#def is-homotopy-cartesian-in-cube'\n( has-sec-f' : has-section A' B' f')\n  : is-homotopy-cartesian A' C' A C \u03b1 \u03b3\n  \u2192 is-homotopy-cartesian B' D' B D \u03b2 \u03b4\n  :=\n\\ is-hc-AC \u2192\n    ind-has-section A' B' f' has-sec-f'\n    ( \\ b' \u2192 is-equiv (D' b') (D (\u03b2 b')) (\u03b4 b'))\n    ( \\ a' \u2192\n      ( is-equiv-right-factor\n        ( D' (f' a')) (D (\u03b2 (f' a'))) (D (f (\u03b1 a')))\n        ( \u03b4 (f' a'))\n        ( transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a'))\n        ( is-equiv-transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a'))\n        ( is-equiv-equiv-is-equiv'\n          ( C' a') (C (\u03b1 a')) (\u03b3 a')\n          ( D' (f' a')) (D (f (\u03b1 a')))\n          (\\ d' \u2192 transport B D (\u03b2 (f' a')) (f (\u03b1 a')) (h a') (\u03b4 (f' a') d'))\n          ( ( F' a' ,  F (\u03b1 a')) , H a')\n          ( is-hc-CD' a')\n          ( is-hc-CD (\u03b1 a'))\n          ( is-hc-AC a'))))\n#end is-homotopy-cartesian-in-cube\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#fiber-products","title":"Fiber products","text":"<p>Given two type families <code>B C : A \u2192 U</code>, we can form their fiberwise product.</p> <pre><code>#def fiberwise-product\n( A : U)\n( B C : A \u2192 U)\n  : A \u2192 U\n  :=\n\\ a \u2192 product (B a) (C a)\n#def first-fiberwise-product\n( A : U)\n( B C : A \u2192 U)\n( a : A)\n  : fiberwise-product A B C a \u2192 B a\n  := \\ (b,_) \u2192 b\n#def second-fiberwise-product\n( A : U)\n( B C : A \u2192 U)\n( a : A)\n  : fiberwise-product A B C a \u2192 C a\n  := \\ (_,c) \u2192 c\n</code></pre> <p>Given two maps <code>B \u2192 A</code> and <code>C \u2192 A</code>, we can form the relative product over <code>A</code>.</p> <pre><code>#section relative-product\n#variable A : U\n#variable B : U\n#variable \u03b2 : B \u2192 A\n#variable C : U\n#variable \u03b3 : C \u2192 A\n#def relative-product\n  : U\n  := \u03a3 ( (b, c) : product B C) , (\u03b2 b = \u03b3 c)\n#def first-relative-product uses (A B \u03b2 C \u03b3)\n  : relative-product \u2192 B\n  := \\ ((b , _), _) \u2192 b\n#def second-relative-product uses (A B \u03b2 C \u03b3)\n  : relative-product \u2192 C\n  := \\ ((_ , c), _) \u2192 c\n#def projection-relative-product uses (A B \u03b2 C)\n  : relative-product \u2192 A\n  := \\ ((_ , c) , _) \u2192 \u03b3 c\n#def homotopy-relative-product uses (A B C)\n  ( (bc, p) : relative-product )\n  : \u03b2 (first-relative-product (bc,p)) = \u03b3 (second-relative-product (bc,p))\n  := p\n</code></pre> <p>This relative product agrees with the fiber product obtained by summing over the product of all fibers.</p> <pre><code>#def fiber-product\n  : U\n  := total-type A (fiberwise-product A (fib B A \u03b2) (fib C A \u03b3))\n#def unpack-fiber-product\n  : fiber-product\n  = ( \u03a3 (a : A), (product (fib B A \u03b2 a) (fib C A \u03b3 a)))\n  := refl\n#def first-fiber-product uses (A B \u03b2 C \u03b3)\n  : fiber-product \u2192 B\n  := \\ (_, ((b, _), _ )) \u2192 b\n#def second-fiber-product uses (A B \u03b2 C \u03b3)\n  : fiber-product \u2192 C\n  := \\ (_, (_, (c, _))) \u2192 c\n#def projection-fiber-product uses (A B \u03b2 C \u03b3)\n  : fiber-product \u2192 A\n  := \\ (a, (_, (_, _))) \u2192 a\n#def homotopy-fiber-product uses (A B C)\n  : ( abpcq : fiber-product )\n  \u2192 \u03b2 (first-fiber-product abpcq) = \u03b3 (second-fiber-product abpcq)\n  :=\n    \\ ( a, ((b, p), (c,q))) \u2192\n      zig-zag-concat A (\u03b2 b) a (\u03b3 c) p q\n#def relative-fiber-product uses (B C)\n  ( (a, ((b, p), (c,q))) : fiber-product )\n  : relative-product\n  := ( ( b , c) , zig-zag-concat A (\u03b2 b) a (\u03b3 c) p q)\n#def fiber-relative-product uses ( A B \u03b2 C)\n  ( ((b,c), e) : relative-product)\n  : fiber-product\n  := ( \u03b3 c , ( (b , e) , (c , refl)))\n#def compatible-projection-fiber-relative-product uses (A B \u03b2 C \u03b3)\n( x : relative-product)\n  : projection-relative-product x = projection-fiber-product (fiber-relative-product x)\n  := refl\n#def compatible-projection-relative-fiber-product uses (A B \u03b2 C \u03b3)\n( abpcq : fiber-product)\n  : ( projection-relative-product (relative-fiber-product abpcq)\n    = projection-fiber-product abpcq)\n  := second (second (second abpcq)) -- evaluates to q\n#def is-id-relative-fiber-relative-product\n( bce : relative-product)\n  : relative-fiber-product (fiber-relative-product bce) = bce\n  := refl\n#def is-id-fiber-relative-fiber-product\n  : ( abpcq : fiber-product)\n  \u2192 ( fiber-relative-product (relative-fiber-product abpcq)) = abpcq\n  :=\n  \\ (a', (bq', cq')) \u2192\n    ind-fib C A \u03b3\n( \\ a cq \u2192\n      ( ( bq : fib B A \u03b2 a)\n      \u2192 ( fiber-relative-product (relative-fiber-product (a, (bq, cq)))\n        = ( a, (bq, cq)))))\n    ( \\ c bq \u2192 refl)\n    ( a')\n    ( cq')\n    ( bq')\n#def is-equiv-relative-fiber-product uses (A B \u03b2 C \u03b3)\n  : is-equiv fiber-product relative-product relative-fiber-product\n  :=\n    ( ( fiber-relative-product\n      , is-id-fiber-relative-fiber-product)\n    , ( fiber-relative-product\n      , is-id-relative-fiber-relative-product))\n#def equiv-relative-product-fiber-product uses (A B \u03b2 C \u03b3)\n  : Equiv fiber-product relative-product\n  :=\n    ( relative-fiber-product\n    , is-equiv-relative-fiber-product)\n#end relative-product\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#fiber-product-with-singleton-type","title":"Fiber product with singleton type","text":"<p>The relative product of <code>f : B \u2192 A</code> with a map <code>Unit \u2192 A</code> corresponding to <code>a : A</code> is nothing but the fiber <code>fib B A f a</code>.</p> <pre><code>#def compute-pullback-to-Unit\n( B A : U)\n( f : B \u2192 A)\n( a : A)\n  : Equiv (fib B A f a) (relative-product A B f Unit (\\ unit \u2192 a))\n  :=\n    ( ( \\ (b , p) \u2192 ((b , unit) , p))\n    , ( ( ( ( \\ ((b , unit) , p) \u2192 (b, p))\n          , ( \\ _ \u2192 refl))\n        , ( ( \\ ((b , unit) , p) \u2192 (b, p))\n          , ( \\ _ \u2192 refl)))))\n#def compute-map-pullback-to-Unit\n( B A : U)\n( f : B \u2192 A)\n( a : A)\n  : Equiv-of-maps\n    ( fib B A f a) (Unit) (\\ _ \u2192 unit)\n    ( relative-product A B f Unit (\\ unit \u2192 a))\n    ( Unit) ( second-relative-product A B f Unit (\\ unit \u2192 a))\n  :=\n    ( ( ( ( \\ (b , p) \u2192 ((b , unit) , p))\n        , ( identity Unit))\n      , \\ _ \u2192 refl)\n    , ( second (compute-pullback-to-Unit B A f a)\n      , is-equiv-identity Unit))\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#total-fibers-of-a-square","title":"Total fibers of a square","text":"<p>We consider a commutative square</p> <pre><code>T \u2192 B\n\u2193   \u2193\nC \u2192 A\n</code></pre> <p>given by the following data:</p> <pre><code>#section fibers-comm-square\n-- the data of a comm square\n#variable A : U\n#variable B : U\n#variable \u03b2 : B \u2192 A\n#variable C : U\n#variable \u03b3 : C \u2192 A\n#variable T : U\n#variable \u03b2' : T \u2192 B\n#variable \u03b3' : T \u2192 C\n#variable \u03b7 : (t : T) \u2192 \u03b2 (\u03b2' t) = \u03b3 (\u03b3' t)\n</code></pre> <p>We define the canonical gap map from <code>T</code> to the relative product over <code>A</code>. The fibers of this gap map are called the total-fibers of the commutative square.</p> <pre><code>#def gap-map-comm-square\n  : T \u2192 relative-product A B \u03b2 C \u03b3\n  := \\ t \u2192 ((\u03b2' t , \u03b3' t) , \u03b7 t)\n#def tot-fib-comm-square uses (\u03b2' \u03b3' \u03b7)\n( bcp : relative-product A B \u03b2 C \u03b3)\n  : U\n  := fib T (relative-product A B \u03b2 C \u03b3) gap-map-comm-square bcp\n-- t , ((\u03b2' t , \u03b3' t) , \u03b7 t) = ((b , c) , p)\n</code></pre> <p>We aim to show that one can compute these total fibers of the commutative square in two steps: first, one takes the fibers in the vertical direction and obtains an induced map <code>fib T C \u03b3 c \u2192 fib B A \u03b2 (\u03b3 c)</code>; second, one takes the fibers of these maps.</p> <p>We define the induced maps on fibers the resulting fibers between fibers.</p> <pre><code>#def map-vertical-fibs-comm-square\n( c : C)\n  : fib T C \u03b3' c \u2192 fib B A \u03b2 (\u03b3 c)\n  := \\ (t , q) \u2192\n     ( (\u03b2' t)\n     , ( concat A (\u03b2 (\u03b2' t)) (\u03b3 (\u03b3' t)) (\u03b3 c)\n         (\u03b7 t) (ap C A (\u03b3' t) c \u03b3 q)))\n#def fib-vertical-fibs-comm-square uses (\u03b2' \u03b3' \u03b7)\n( c : C)\n( bp : fib B A \u03b2 (\u03b3 c))\n  : U\n  := fib (fib T C \u03b3' c) (fib B A \u03b2 (\u03b3 c))\n     ( map-vertical-fibs-comm-square c)\n     ( bp)\n-- (t, q : \u03b3' t = c) , (\u03b2' t, concat (\u03b7 t) (ap \u03b3 q)) = (b, p : \u03b2 b = \u03b3 c)\n</code></pre> <p>Then we use a helper term to construct a comparison map from the total fibers to the fiber fibers.</p> <pre><code>-- We append the random suffix IkCK to terms\n-- that are only meant to be used locally in this section\n#def helper-IkCK uses (\u03b2' \u03b7)\n  ( ((b , c) , p) : relative-product A B \u03b2 C \u03b3)\n( t : T)\n  : U\n  := \u03a3 ( q : \u03b3' t = c) , map-vertical-fibs-comm-square c (t , q) = (b , p)\n#def fib-vertical-fibs-helper-IkCK uses (\u03b2' \u03b3' \u03b7)\n  ( ((b , c) , p) : relative-product A B \u03b2 C \u03b3)\n( t : T)\n  ( (q , e) : helper-IkCK ((b,c),p) t)\n  : fib-vertical-fibs-comm-square c (b,p)\n  := ((t , q) , e)\n#def fib-vertical-fibs-tot-fib-comm-square uses (\u03b7 \u03b2' \u03b3')\n  ( ((b,c),p) : relative-product A B \u03b2 C \u03b3)\n  ( (t , h) : tot-fib-comm-square ((b,c),p))\n  : fib-vertical-fibs-comm-square c (b,p)\n  :=\n    ( fib-vertical-fibs-helper-IkCK ((b,c),p) t)\n    ( ind-fib T (relative-product A B \u03b2 C \u03b3)\n      ( gap-map-comm-square)\n      ( \\ bcp' (t, h') \u2192 helper-IkCK bcp' t)\n      ( \\ t \u2192 (refl, refl))\n      ( ((b,c),p))\n      ( t , h))\n</code></pre> <p>We could have defined this comparison map without the helper by a direct fiber induction, but in this case it would not commute definitionally with the canonical projection to <code>T</code>.</p> <pre><code>#def compute-fib-vertical-fibs-tot-fib-comm-square uses (\u03b7 \u03b2' \u03b3')\n( bcp : relative-product A B \u03b2 C \u03b3)\n  ( (t , h) : tot-fib-comm-square bcp)\n  :\n  ( first (first (fib-vertical-fibs-tot-fib-comm-square bcp (t , h)))\n  = t)\n  := refl\n</code></pre> <p>Finally, we show that these comparison maps are equivalences by summing over all of them. Indeed, by applications of <code>is-equiv-domain-sum-of-fibers</code>, the total type on each side is just equivalent to <code>T</code>.</p> <pre><code>#def is-equiv-projection-fib-vertical-fibs-comm-square uses (\u03b7 \u03b2')\n  : is-equiv\n    ( \u03a3 (((b,c),p) : relative-product A B \u03b2 C \u03b3)\n      , fib-vertical-fibs-comm-square c (b,p))\n    ( T)\n    ( \\ (_ , ((t , _) , _)) \u2192 t)\n  :=\n    is-equiv-triple-comp\n    ( \u03a3 (((b,c),p) : relative-product A B \u03b2 C \u03b3)\n      , fib-vertical-fibs-comm-square c (b,p))\n( \u03a3 ( c : C)\n      , ( \u03a3 (bp : fib B A \u03b2 (\u03b3 c))\n          , fib-vertical-fibs-comm-square c bp))\n( \u03a3 (c : C) , fib T C \u03b3' c)\n    ( T)\n    ( \\ (((b , c) , p) , tqe) \u2192 (c , ((b , p) , tqe)))\n    ( ( \\ (c , ((b , p) , tqe)) \u2192 (((b , c) , p) , tqe) , \\ _ \u2192 refl)\n    , ( \\ (c , ((b , p) , tqe)) \u2192 (((b , c) , p) , tqe) , \\ _ \u2192 refl))\n    ( \\ (c , (_ , (tq , _))) \u2192 (c , tq))\n( is-equiv-total-is-equiv-fiberwise C\n      ( \\ c \u2192 \u03a3 (bp : fib B A \u03b2 (\u03b3 c)) , fib-vertical-fibs-comm-square c bp)\n      ( \\ c \u2192 fib T C \u03b3' c)\n      ( \\ c (_ , (tq , _)) \u2192 tq)\n      ( \\ c \u2192\n        is-equiv-domain-sum-of-fibers\n        ( fib T C \u03b3' c) (fib B A \u03b2 (\u03b3 c))\n        ( map-vertical-fibs-comm-square c)))\n    ( \\ (_ , (t , _)) \u2192 t)\n    ( is-equiv-domain-sum-of-fibers T C \u03b3')\n#def is-equiv-fib-vertical-fibs-tot-fib-comm-square uses (\u03b7 \u03b2' \u03b3')\n  : (((b,c),p) : relative-product A B \u03b2 C \u03b3)\n  \u2192 is-equiv\n    ( tot-fib-comm-square ((b,c),p))\n    ( fib-vertical-fibs-comm-square c (b,p))\n    ( fib-vertical-fibs-tot-fib-comm-square ((b,c),p))\n  :=\n    is-equiv-fiberwise-is-equiv-total\n    ( relative-product A B \u03b2 C \u03b3)\n    ( \\ bcp \u2192 tot-fib-comm-square bcp)\n    ( \\ ((b,c),p) \u2192 fib-vertical-fibs-comm-square c (b,p))\n    ( \\ bcp \u2192 fib-vertical-fibs-tot-fib-comm-square bcp)\n( is-equiv-right-factor\n      ( \u03a3 (bcp : relative-product A B \u03b2 C \u03b3)\n        , tot-fib-comm-square bcp)\n      ( \u03a3 (((b,c),p) : relative-product A B \u03b2 C \u03b3)\n        , fib-vertical-fibs-comm-square c (b,p))\n      ( T)\n      ( total-map\n        ( relative-product A B \u03b2 C \u03b3)\n        ( \\ bcp \u2192 tot-fib-comm-square bcp)\n        ( \\ ((b,c),p) \u2192 fib-vertical-fibs-comm-square c (b,p))\n        ( \\ bcp \u2192 fib-vertical-fibs-tot-fib-comm-square bcp))\n      ( \\ (_ , ((t , _) , _)) \u2192 t)\n      ( is-equiv-projection-fib-vertical-fibs-comm-square)\n      ( is-equiv-domain-sum-of-fibers\n        ( T) ( relative-product A B \u03b2 C \u03b3)\n        ( gap-map-comm-square)))\n</code></pre> <p>We summarize the result as the following equivalence:</p> <pre><code>#def equiv-fib-vertical-fibs-tot-fib-comm-square uses (A B C \u03b2 \u03b3 T \u03b2' \u03b3' \u03b7)\n( b : B)\n( c : C)\n( p : \u03b2 b = \u03b3 c)\n  : Equiv\n    ( tot-fib-comm-square ((b , c) , p))\n    ( fib-vertical-fibs-comm-square c (b , p))\n  :=\n    ( fib-vertical-fibs-tot-fib-comm-square ((b , c) , p)\n    , is-equiv-fib-vertical-fibs-tot-fib-comm-square ((b , c) , p))\n#end fibers-comm-square\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#functoriality-of-fibers","title":"Functoriality of fibers","text":"<p>We have an assignment that to each <code>\u03b1 : A' \u2192 A</code> and each <code>a : A</code> assigns the fiber <code>fib A' A \u03b1 a</code>. We now investigate the functoriality properties of this assignment.</p> <p>Every map of maps induces a map of fibers.</p> <pre><code>#section is-equiv-map-of-fibers-is-equiv-map-of-maps\n#variables A' A : U\n#variable \u03b1 : A' \u2192 A\n#variables B' B : U\n#variable \u03b2 : B' \u2192 B\n#variable map-of-maps-\u03b1-\u03b2 : map-of-maps A' A \u03b1 B' B \u03b2\n-- To avoid polluting the global namespace, we add a random suffix to\n-- identifiers that are only supposed to be used in this section.\n#def s'-c4XT uses (A \u03b1 B \u03b2) : A' \u2192 B' := first (first map-of-maps-\u03b1-\u03b2)\n#def s-c4XT uses (A' \u03b1 B' \u03b2) : A \u2192 B := second (first map-of-maps-\u03b1-\u03b2)\n#def map-of-fibers-map-of-maps\n( a : A)\n  ( (a', p) : fib A' A \u03b1 a)\n  : fib B' B \u03b2 (s-c4XT a)\n  :=\n  ( s'-c4XT a'\n  , ( concat B (\u03b2 (s'-c4XT a')) (s-c4XT (\u03b1 a')) (s-c4XT a))\n    ( second  map-of-maps-\u03b1-\u03b2 a')\n    ( ap A B (\u03b1 a') a s-c4XT p))\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#equivalences-induce-equivalences-on-fibers","title":"Equivalences induce equivalences on fibers","text":"<p>As an application of <code>is-homotopy-cartesian-is-horizontal-equiv</code>, we show that an equivalence of maps induces an equivalence of fibers at each base point.</p> <pre><code>#def map-of-sums-of-fibers-map-of-maps uses (map-of-maps-\u03b1-\u03b2)\n  ( (a, u) : \u03a3 (a : A), fib A' A \u03b1 a)\n  : \u03a3 (b : B), fib B' B \u03b2 b\n  := (s-c4XT a, map-of-fibers-map-of-maps a u)\n#def sums-of-fibers-to-domains-map-of-maps uses (map-of-maps-\u03b1-\u03b2)\n  : map-of-maps\n( \u03a3 (a : A), fib A' A \u03b1 a)\n( \u03a3 (b : B), fib B' B \u03b2 b)\n    ( map-of-sums-of-fibers-map-of-maps)\n    ( A')\n    ( B')\n    ( s'-c4XT)\n  :=\n  ((( \\ (_, (a', _)) \u2192 a'), ( \\ (_, (b', _)) \u2192 b')), \\ (a, u) \u2192 refl)\n#variable is-equiv-s' : is-equiv A' B' s'-c4XT\n#def is-equiv-map-of-sums-of-fibers-is-equiv-map-of-domains\nuses (map-of-maps-\u03b1-\u03b2 is-equiv-s')\n  : is-equiv\n( \u03a3 (a : A), fib A' A \u03b1 a)\n( \u03a3 (b : B), fib B' B \u03b2 b)\n    ( map-of-sums-of-fibers-map-of-maps)\n  :=\n  is-equiv-equiv-is-equiv\n( \u03a3 (a : A), fib A' A \u03b1 a)\n( \u03a3 (b : B), fib B' B \u03b2 b)\n  ( map-of-sums-of-fibers-map-of-maps)\n  ( A')\n  ( B')\n  ( s'-c4XT)\n  ( sums-of-fibers-to-domains-map-of-maps)\n( second\n    ( ( inv-equiv A' (\u03a3 (a : A), fib A' A \u03b1 a))\n      ( equiv-sum-of-fibers-domain A' A \u03b1)))\n( second\n    ( ( inv-equiv B' (\u03a3 (b : B), fib B' B \u03b2 b))\n      ( equiv-sum-of-fibers-domain B' B \u03b2)))\n  ( is-equiv-s')\n#variable is-equiv-s : is-equiv A B s-c4XT\n#def is-equiv-map-of-fibers-is-equiv-map-of-maps\nuses (map-of-maps-\u03b1-\u03b2  is-equiv-s is-equiv-s')\n  : (a : A)\n  \u2192 is-equiv\n    ( fib A' A \u03b1 a)\n    ( fib B' B \u03b2 (s-c4XT a))\n    ( map-of-fibers-map-of-maps a)\n  :=\n  is-homotopy-cartesian-is-horizontal-equiv\n  ( A)\n  ( fib A' A \u03b1)\n  ( B)\n  ( fib B' B \u03b2)\n  ( s-c4XT)\n  ( map-of-fibers-map-of-maps)\n  ( is-equiv-s)\n  ( is-equiv-map-of-sums-of-fibers-is-equiv-map-of-domains)\n#end is-equiv-map-of-fibers-is-equiv-map-of-maps\n#def Equiv-of-fibers-Equiv-of-maps\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( (((s', s), \u03b7), (is-equiv-s, is-equiv-s')) : Equiv-of-maps A' A \u03b1 B' B \u03b2)\n(a : A)\n  : Equiv (fib A' A \u03b1 a) (fib B' B \u03b2 (s a))\n  :=\n  ( map-of-fibers-map-of-maps A' A \u03b1 B' B \u03b2 ((s', s), \u03b7) a\n  , ( is-equiv-map-of-fibers-is-equiv-map-of-maps A' A \u03b1 B' B \u03b2 ((s', s), \u03b7))\n    ( is-equiv-s)\n    ( is-equiv-s')\n    ( a))\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#composition-induces-composition-on-fibers","title":"Composition induces composition on fibers","text":"<p>The map induced on fibers respects composition up to homotopy.</p> <pre><code>#def comp-map-of-maps\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n( C' C : U)\n( \u03b3 : C' \u2192 C)\n  ( ((t',t),\u03b7t) : map-of-maps B' B \u03b2 C' C \u03b3)\n  ( ((s',s),\u03b7s) : map-of-maps A' A \u03b1 B' B \u03b2)\n  : map-of-maps A' A \u03b1 C' C \u03b3\n  :=\n  ( ( comp A' B' C' t' s'\n    , comp A B C t s)\n  , ( \\ a' \u2192\n      concat C (\u03b3 (t' (s' a'))) (t (\u03b2 (s' a'))) (t (s (\u03b1 a')))\n      ( \u03b7t (s' a'))\n      ( ap B C (\u03b2 (s' a')) (s (\u03b1 a')) t (\u03b7s a'))))\n#def comp-map-of-fibers-comp-map-of-maps\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n( C' C : U)\n( \u03b3 : C' \u2192 C)\n  ( ((t',t),\u03b7t) : map-of-maps B' B \u03b2 C' C \u03b3)\n  ( ((s',s),\u03b7s) : map-of-maps A' A \u03b1 B' B \u03b2)\n  : ( a : A)\n  \u2192 homotopy (fib A' A \u03b1 a) (fib C' C \u03b3 (t (s a)))\n    ( comp ( fib A' A \u03b1 a) (fib B' B \u03b2 (s a)) (fib C' C \u03b3 (t (s a)))\n      ( map-of-fibers-map-of-maps B' B \u03b2 C' C \u03b3 ((t',t),\u03b7t) ( s a))\n      ( map-of-fibers-map-of-maps A' A \u03b1 B' B \u03b2 ((s',s),\u03b7s) ( a)))\n    ( map-of-fibers-map-of-maps A' A \u03b1 C' C \u03b3\n      ( comp-map-of-maps A' A \u03b1 B' B \u03b2 C' C \u03b3\n        ((t',t),\u03b7t) ((s',s),\u03b7s))\n      (a))\n  :=\n    ind-fib A' A \u03b1\n    ( \\ a a'p \u2192\n      ( ( map-of-fibers-map-of-maps B' B \u03b2 C' C \u03b3 ((t',t),\u03b7t) (s a))\n        ( map-of-fibers-map-of-maps A' A \u03b1 B' B \u03b2 ((s',s),\u03b7s) a\n          ( a'p))\n      =_{ fib C' C \u03b3 (t (s a))}\n        ( map-of-fibers-map-of-maps A' A \u03b1 C' C \u03b3\n          ( comp-map-of-maps A' A \u03b1 B' B \u03b2 C' C \u03b3\n            ((t',t),\u03b7t) ((s',s),\u03b7s))\n          ( a) (a'p))))\n    ( \\ a' \u2192 refl)\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#retracts-induce-retracts-on-fibers","title":"Retracts induce retracts on fibers","text":"<p>Every retract of types induces a retract on fibers.</p> <pre><code>#def is-section-retraction-pair-Map\n  ( ((A',A),\u03b1) : Map)\n  ( ((B',B),\u03b2) : Map)\n  ( ((C',C),\u03b3) : Map)\n  ( ((s',s),_) : map-Map ((A',A),\u03b1) ((B',B),\u03b2))\n  ( ((t',t),_) : map-Map ((B',B),\u03b2) ((C',C),\u03b3))\n  : U\n  :=\n    product\n    ( is-section-retraction-pair A' B' C' s' t')\n    ( is-section-retraction-pair A B C s t)\n#def has-external-retract-Map\n( \u03b1 \u03b2 : Map)\n( S : map-Map \u03b1 \u03b2)\n  : U\n  :=\n\u03a3 ((\u03b3 , T) : ( \u03a3 (\u03b3 : Map) , (map-Map \u03b2 \u03b3)))\n    , ( is-section-retraction-pair-Map \u03b1 \u03b2 \u03b3 S T)\n#def is-external-retract-of-Map\n( \u03b1 \u03b2 : Map)\n  : U\n  :=\n\u03a3 (S : map-Map \u03b1 \u03b2)\n    , has-external-retract-Map \u03b1 \u03b2 S\n#def is-retract-of-fibers-is-external-retract-of-Map\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( ( ((s',s),\u03b7s) , ( ( ((C',C),\u03b3) , ((r',r),\u03b7r)) , ( is-s-r' , is-s-r)))\n    : is-external-retract-of-Map ((A',A),\u03b1) ((B',B),\u03b2))\n( a : A)\n  : is-retract-of (fib A' A \u03b1 a) (fib B' B \u03b2 (s a))\n  :=\n    ( ( map-of-fibers-map-of-maps A' A \u03b1 B' B \u03b2 ((s',s),\u03b7s) a)\n    , ( has-retraction-internalize\n        ( fib A' A \u03b1 a) (fib B' B \u03b2 (s a))\n        ( map-of-fibers-map-of-maps A' A \u03b1 B' B \u03b2 ((s',s),\u03b7s) a)\n        ( ( fib C' C \u03b3 (r (s a))\n          , map-of-fibers-map-of-maps B' B \u03b2 C' C \u03b3 ((r',r),\u03b7r) (s a))\n        , ( is-equiv-homotopy (fib A' A \u03b1 a) (fib C' C \u03b3 (r (s a)))\n                ( comp ( fib A' A \u03b1 a) (fib B' B \u03b2 (s a)) (fib C' C \u03b3 (r (s a)))\n                  ( map-of-fibers-map-of-maps B' B \u03b2 C' C \u03b3 ((r',r),\u03b7r) ( s a))\n                  ( map-of-fibers-map-of-maps A' A \u03b1 B' B \u03b2 ((s',s),\u03b7s) ( a)))\n                ( map-of-fibers-map-of-maps A' A \u03b1 C' C \u03b3\n                  ( comp-map-of-maps A' A \u03b1 B' B \u03b2 C' C \u03b3\n                    ( (r',r),\u03b7r) ((s',s),\u03b7s))\n                  (a))\n            ( comp-map-of-fibers-comp-map-of-maps A' A \u03b1 B' B \u03b2 C' C \u03b3\n              ( (r',r),\u03b7r) ((s',s),\u03b7s)\n              ( a))\n            ( is-equiv-map-of-fibers-is-equiv-map-of-maps A' A \u03b1 C' C \u03b3\n              ( comp-map-of-maps A' A \u03b1 B' B \u03b2 C' C \u03b3 ((r',r),\u03b7r) ((s',s),\u03b7s))\n              ( is-s-r')\n              ( is-s-r)\n              ( a))))))\n</code></pre>"},{"location":"hott/11-homotopy-pullbacks.rzk/#equivalences-are-closed-under-retracts","title":"Equivalences are closed under retracts","text":"<p>As an immediate corollary we obtain that equivalences are closed under retracts.</p> <pre><code>#def is-equiv-is-retract-of-is-equiv\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( B' B : U)\n( \u03b2 : B' \u2192 B)\n  ( (((s',s),\u03b7s) , has-ext-retr-S)\n    : is-external-retract-of-Map ((A',A),\u03b1) ((B',B),\u03b2))\n( is-equiv-\u03b2 : is-equiv B' B \u03b2)\n  : is-equiv A' A \u03b1\n  :=\n  is-equiv-is-contr-map A' A \u03b1\n  ( \\ a \u2192\n    is-contr-is-retract-of-is-contr\n    ( fib A' A \u03b1 a) (fib B' B \u03b2 (s a))\n    ( is-retract-of-fibers-is-external-retract-of-Map A' A \u03b1 B' B \u03b2\n      ( ((s',s),\u03b7s) , has-ext-retr-S)\n      ( a))\n    ( is-contr-map-is-equiv B' B \u03b2 is-equiv-\u03b2 (s a)))\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/","title":"3. Simplicial Type Theory","text":"<p>These formalisations correspond in part to Section 3 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#simplices-and-their-subshapes","title":"Simplices and their subshapes","text":""},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#simplices","title":"Simplices","text":"The 1-simplex<pre><code>#def \u0394\u00b9 : 2 \u2192 TOPE\n  := \\ t \u2192 TOP\n</code></pre> The 2-simplex<pre><code>#def \u0394\u00b2 : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t , s) \u2192 s \u2264 t\n</code></pre> The 3-simplex<pre><code>#def \u0394\u00b3 : (2 \u00d7 2 \u00d7 2) \u2192 TOPE\n  := \\ ((t1 , t2) , t3) \u2192 t3 \u2264 t2 \u2227 t2 \u2264 t1\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#boundaries-of-simplices","title":"Boundaries of simplices","text":"The boundary of a 1-simplex<pre><code>#def \u2202\u0394\u00b9 : \u0394\u00b9 \u2192 TOPE\n  := \\ t \u2192 (t \u2261 0\u2082 \u2228 t \u2261 1\u2082)\n</code></pre> The boundary of a 2-simplex<pre><code>#def \u2202\u0394\u00b2 : \u0394\u00b2 \u2192 TOPE\n  :=\n    \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082 \u2228 s \u2261 t)\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#the-2-dimensional-inner-horn","title":"The 2 dimensional inner horn","text":"<pre><code>#def \u039b : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082)\n#def \u039b\u00b2\u2081 : \u0394\u00b2 \u2192 TOPE\n  := \\ (s,t) \u2192 \u039b (s,t)\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#the-3-dimensional-inner-horns","title":"The 3 dimensional inner horns","text":"<pre><code>#def \u039b\u00b3\u2081 : \u0394\u00b3 \u2192 TOPE\n  := \\ ((t1, t2), t3) \u2192 t3 \u2261 0\u2082 \u2228 t2 \u2261 t1 \u2228 t1 \u2261 1\u2082\n#def \u039b\u00b3\u2082 : \u0394\u00b3 \u2192 TOPE\n  := \\ ((t1, t2), t3) \u2192 t3 \u2261 0\u2082 \u2228 t3 \u2261 t2 \u2228 t1 \u2261 1\u2082\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#products","title":"Products","text":"<p>The product of topes defines the product of shapes.</p> <pre><code>#def shape-prod\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03c7 : J \u2192 TOPE)\n  : (I \u00d7 J) \u2192 TOPE\n  := \\ (t , s) \u2192 \u03c8 t \u2227 \u03c7 s\n</code></pre> The square as a product<pre><code>#def \u0394\u00b9\u00d7\u0394\u00b9 : (2 \u00d7 2) \u2192 TOPE\n  := shape-prod 2 2 \u0394\u00b9 \u0394\u00b9\n</code></pre> The total boundary of the square<pre><code>#def \u2202\u25a1 : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t ,s) \u2192 ((\u2202\u0394\u00b9 t) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (\u2202\u0394\u00b9 s))\n</code></pre> The vertical boundary of the square<pre><code>#def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (2 \u00d7 2) \u2192 TOPE\n  := shape-prod 2 2 \u2202\u0394\u00b9 \u0394\u00b9\n</code></pre> The horizontal boundary of the square<pre><code>#def \u0394\u00b9\u00d7\u2202\u0394\u00b9 : (2 \u00d7 2) \u2192 TOPE\n  := shape-prod 2 2 \u0394\u00b9 \u2202\u0394\u00b9\n</code></pre> The prism from a 2-simplex in an arrow type<pre><code>#def \u0394\u00b2\u00d7\u0394\u00b9 : (2 \u00d7 2 \u00d7 2) \u2192 TOPE\n  := shape-prod (2 \u00d7 2) 2 \u0394\u00b2 \u0394\u00b9\n</code></pre> <pre><code>#def \u0394\u00b3\u00d7\u0394\u00b2 : ((2 \u00d7 2 \u00d7 2) \u00d7 (2 \u00d7 2)) \u2192 TOPE\n  := shape-prod (2 \u00d7 2 \u00d7 2) (2 \u00d7 2) \u0394\u00b3 \u0394\u00b2\n</code></pre> <p>Maps out of \\(\u0394\u00b2\\) are a retract of maps out of \\(\u0394\u00b9\u00d7\u0394\u00b9\\).</p> RS17, Proposition 3.6<pre><code>#def \u0394\u00b2-is-retract-\u0394\u00b9\u00d7\u0394\u00b9\n(A : U)\n  : is-retract-of (\u0394\u00b2 \u2192 A) (\u0394\u00b9\u00d7\u0394\u00b9 \u2192 A)\n  :=\n    ( ( \\ f \u2192 \\ (t , s) \u2192\nrecOR\n          ( t &lt;= s |-&gt; f (t , t) ,\n            s &lt;= t |-&gt; f (t , s))) ,\n      ( ( \\ f \u2192 \\ ts \u2192 f ts ) , \\ _ \u2192 refl))\n</code></pre> <p>Maps out of \\(\u0394\u00b3\\) are a retract of maps out of \\(\u0394\u00b2\u00d7\u0394\u00b9\\).</p> RS17, Proposition 3.7<pre><code>#def \u0394\u00b3-is-retract-\u0394\u00b2\u00d7\u0394\u00b9-retraction\n(A : U)\n  : (\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A) \u2192 (\u0394\u00b3 \u2192 A)\n  := \\ f \u2192 \\ ((t1 , t2) , t3) \u2192 f ((t1 , t3) , t2)\n#def \u0394\u00b3-is-retract-\u0394\u00b2\u00d7\u0394\u00b9-section\n(A : U)\n  : (\u0394\u00b3 \u2192 A) \u2192 (\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A)\n  :=\n\\ f \u2192 \\ ((t1 , t2) , t3) \u2192\nrecOR\n      ( t3 &lt;= t2 |-&gt; f ((t1 , t2) , t2) ,\n        t2 &lt;= t3 |-&gt;\nrecOR\n            ( t3 &lt;= t1 |-&gt; f ((t1 , t3) , t2) ,\n              t1 &lt;= t3 |-&gt; f ((t1 , t1) , t2)))\n#def \u0394\u00b3-is-retract-\u0394\u00b2\u00d7\u0394\u00b9\n( A : U)\n  : is-retract-of (\u0394\u00b3 \u2192 A) (\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A)\n  :=\n    ( \u0394\u00b3-is-retract-\u0394\u00b2\u00d7\u0394\u00b9-section A ,\n      ( \u0394\u00b3-is-retract-\u0394\u00b2\u00d7\u0394\u00b9-retraction A , \\ _ \u2192 refl))\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#pushout-product","title":"Pushout product","text":"<p>Pushout product \u03a6\u00d7\u03b6 \u222a_{\u03a6\u00d7\u03c7} \u03c8\u00d7\u03c7 of \u03a6 \u21aa \u03c8 and \u03c7 \u21aa \u03b6, domain of the co-gap map.</p> <pre><code>#def shape-pushout-prod\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03a6 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n  : (shape-prod I J \u03c8 \u03b6) \u2192 TOPE\n  := \\ (t,s) \u2192 (\u03a6 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#intersections","title":"Intersections","text":"<p>The intersection of shapes is defined by conjunction on topes.</p> <pre><code>#def shape-intersection\n( I : CUBE)\n( \u03c8 \u03c7 : I \u2192 TOPE)\n  : I \u2192 TOPE\n  := \\ t \u2192 \u03c8 t \u2227 \u03c7 t\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#unions","title":"Unions","text":"<p>The union of shapes is defined by disjunction on topes.</p> <pre><code>#def shape-union\n( I : CUBE)\n( \u03c8 \u03c7 : I \u2192 TOPE)\n  : I \u2192 TOPE\n  := \\ t \u2192 \u03c8 t \u2228 \u03c7 t\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#connection-squares","title":"Connection squares","text":"<p> f f f f f f f \u2022 \u2022 \u2022 \u2022 </p> RS17 Proposition 3.5(a)<pre><code>#define join-square-arrow\n(A : U)\n(f : 2 \u2192 A)\n  : (2 \u00d7 2) \u2192 A\n  := \\ (t, s) \u2192 recOR ( t \u2264 s \u21a6 f s , s \u2264 t \u21a6 f t )\n</code></pre> <p> f f f f f \u2022 \u2022 \u2022 \u2022 </p> RS17 Proposition 3.5(b)<pre><code>#define meet-square-arrow\n(A : U)\n(f : 2 \u2192 A)\n  : (2 \u00d7 2) \u2192 A\n  := \\ (t, s) \u2192 recOR ( t \u2264 s \u21a6 f t , s \u2264 t \u21a6 f s )\n</code></pre> <p> <p></p>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#functorial-comparisons-of-shapes","title":"Functorial comparisons of shapes","text":""},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#functorial-retracts","title":"Functorial retracts","text":"<p>For a subshape <code>\u03d5 \u2282 \u03c8</code> we have an easy way of stating that it is a retract in a strict and functorial way. Intuitively this happens when there is a map from <code>\u03c8</code> to <code>\u03d5</code> that fixes the subshape <code>\u03c8</code>. But in the definition below we actually ask for a section of the family of extensions of a function <code>\u03d5 \u2192 A</code> to a function <code>\u03c8 \u2192 A</code> and we ask for this section to be natural in the type <code>A</code>.</p> <pre><code>#def is-functorial-shape-retract\n( I : CUBE )\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n  : U\n  :=\n( A' : U) \u2192 (A : U) \u2192 (\u03b1 : A' \u2192 A) \u2192\n    has-section-family-over-map\n      ( \u03d5 \u2192 A') (\\ f \u2192 (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 f t])\n      ( \u03d5 \u2192 A) (\\ f \u2192 (t : \u03c8) \u2192 A [\u03d5 t \u21a6 f t])\n      ( \\ f t \u2192 \u03b1 (f t))\n      ( \\ _ g t \u2192 \u03b1 (g t))\n</code></pre> <p>For example, this applies to <code>\u0394\u00b2 \u2282 \u0394\u00b9\u00d7\u0394\u00b9</code>.</p> <pre><code>#def is-functorial-retract-\u0394\u00b2-\u0394\u00b9\u00d7\u0394\u00b9\n  : is-functorial-shape-retract (2 \u00d7 2) (\u0394\u00b9\u00d7\u0394\u00b9) (\u0394\u00b2)\n  :=\n\\ A' A \u03b1 \u2192\n      ( ( first (\u0394\u00b2-is-retract-\u0394\u00b9\u00d7\u0394\u00b9 A'), first (\u0394\u00b2-is-retract-\u0394\u00b9\u00d7\u0394\u00b9 A) ) ,\n\\ a' \u2192 refl)\n</code></pre> <p>Every functorial shape retract automatically induces a section when restricting to diagrams extending a fixed diagram <code>\u03c3': \u03d5 \u2192 A'</code> (or, respectively, its image <code>\u03d5 \u2192 A</code> under \u03b1).</p> <pre><code>#def relativize-is-functorial-shape-retract\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03c7 : \u03c8 \u2192 TOPE)\n( is-fretract-\u03c8-\u03c7 : is-functorial-shape-retract I \u03c8 \u03c7)\n( \u03d5 : \u03c7 \u2192 TOPE)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( \u03c3' : \u03d5 \u2192 A')\n  : has-section-family-over-map\n( (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( \\ \u03c4' \u2192 (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t])\n( (t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n( \\ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t])\n      ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n      ( \\ _ \u03c5' t \u2192 \u03b1 (\u03c5' t))\n  :=\n    ( ( \\ \u03c4' \u2192 first (first (is-fretract-\u03c8-\u03c7 A' A \u03b1)) \u03c4'\n      , \\ \u03c4 \u2192 second (first (is-fretract-\u03c8-\u03c7 A' A \u03b1)) \u03c4\n      )\n    , \\ \u03c4' \u2192 second (is-fretract-\u03c8-\u03c7 A' A \u03b1) \u03c4'\n    )\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#isomorphisms-of-shape-inclusions","title":"Isomorphisms of shape inclusions","text":"<p>Consider two shape inclusions <code>\u03d5 \u2282 \u03c8</code> and <code>\u03b6 \u2282 \u03c7</code>. We want to express the fact that there is an isomorphism <code>\u03c8 \u2245 \u03c7</code> of shapes which restricts to an isomorphism <code>\u03d5 \u2245 \u03b6</code>. Since shapes are not types themselves, the best we can currently do is describe this isomorphism on representables.</p> <pre><code>#def isomorphism-shape-inclusions\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  : U\n  :=\n( \u03a3 ( f : (A : U) \u2192 Equiv (\u03b6 \u2192 A) (\u03d5 \u2192 A))\n      , ( ( A : U)\n        \u2192 ( \u03c3 : \u03b6 \u2192 A)\n        \u2192 ( Equiv\n            ( (t : \u03c7) \u2192 A [\u03b6 t \u21a6 \u03c3 t])\n( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 first (f A) \u03c3 t]))))\n#def functorial-isomorphism-shape-inclusions\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  : U\n  :=\n\u03a3 ( (f , F) : isomorphism-shape-inclusions I \u03c8 \u03d5 J \u03c7 \u03b6)\n  , ( \u03a3 ( e\n        : ( A' : U)\n        \u2192 ( A : U)\n        \u2192 ( \u03b1 : A' \u2192 A)\n        \u2192 ( \u03c3' : \u03b6 \u2192 A')\n        \u2192 ( ( \\ (t : I | \u03d5 t) \u2192 \u03b1 (first (f A') \u03c3' t))\n          = ( first (f A) (\\ t \u2192 \u03b1 (\u03c3' t)))))\n      , ( ( A' : U)\n        \u2192 ( A : U)\n        \u2192 ( \u03b1 : A' \u2192 A)\n        \u2192 ( \u03c3' : \u03b6 \u2192 A')\n        \u2192 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03b6 t \u21a6 \u03c3' t])\n        \u2192 ( ( transport (\u03d5 \u2192 A) (\\ \u03c3 \u2192 (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n( \\ (t : I | \u03d5 t) \u2192 \u03b1 (first (f A') \u03c3' t))\n              ( first (f A) (\\ t \u2192 \u03b1 (\u03c3' t)))\n              ( e A' A \u03b1 \u03c3')\n(\\ (t : \u03c8) \u2192 \u03b1 (first (F A' \u03c3') \u03c4' t)))\n            = ( first (F A (\\ (t : \u03b6) \u2192 \u03b1 (\u03c3' t))) (\\ (t : \u03c7) \u2192 \u03b1 (\u03c4' t))))))\n</code></pre> <p>In practice, the isomorphisms are usually given via an explicit formula, which would define a map <code>\u03c8 \u2192 \u03d5</code> if <code>\u03c8</code> and <code>\u03d5</code> were themselves types. In this case all the coherences are just <code>refl</code>, hence it is easy to produce a term of type <code>functorial-isomorphism-shape-inclusions I \u03c8 \u03d5 J \u03c7 \u03b6</code>.</p> <p>For example, consider the two shape inclusions <code>{0} \u2282 \u0394\u00b9</code> (subshapes of <code>2</code>) and <code>{1} \u2282 right-leg-of-\u039b</code> (subshapes of <code>2 \u00d7 2</code>), where</p> <pre><code>#def right-leg-of-\u039b : \u039b \u2192 TOPE\n  := \\ (t, s) \u2192 t \u2261 1\u2082\n</code></pre> <p>These two shape inclusions are canonically isomorphic via the formulas</p> <pre><code>-- not valid rzk code\n#def f : \u0394\u00b9 \u2192 right-leg-of-\u039b\n  \\ s \u2192 (1\u2082 , s)\n\n#def g : right-leg-of-\u039b \u2192 \u0394\u00b9\n  \\ (t , s) \u2192 s\n</code></pre> <p>We turn these formulas into a functorial shape inclusion as follows. Unfortunately we have to repeat the same formula multiple times, leading to some ugly boilerplate code.</p> <pre><code>#def isomorphism-0-\u0394\u00b9-1-right-leg-of-\u039b\n  : isomorphism-shape-inclusions\n    (2 \u00d7 2) (\\ ts \u2192 right-leg-of-\u039b ts) (\\ (t , s) \u2192 t \u2261 1\u2082 \u2227 s \u2261 0\u2082)\n2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082)\n  :=\n    ( \\ A \u2192\n      ( \\ \u03c4 (t,s) \u2192 \u03c4 s\n      , ( ( \\ \u03c5 s \u2192 \u03c5 (1\u2082, s) , \\ _ \u2192 refl)\n        , ( \\ \u03c5 s \u2192 \u03c5 (1\u2082, s) , \\ _ \u2192 refl)))\n    , \\ A _ \u2192\n      ( \\ \u03c4 (t,s) \u2192 \u03c4 s\n      , ( ( \\ \u03c5 s \u2192 \u03c5 (1\u2082, s) , \\ _ \u2192 refl)\n        , ( \\ \u03c5 s \u2192 \u03c5 (1\u2082, s) , \\ _ \u2192 refl))))\n#def functorial-isomorphism-0-\u0394\u00b9-1-right-leg-of-\u039b\n  : functorial-isomorphism-shape-inclusions\n    (2 \u00d7 2) (\\ ts \u2192 right-leg-of-\u039b ts) (\\ (t , s) \u2192 t \u2261 1\u2082 \u2227 s \u2261 0\u2082)\n2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082)\n  :=\n    ( isomorphism-0-\u0394\u00b9-1-right-leg-of-\u039b\n    , ( \\ _ _ _ _ \u2192 refl , \\ _ _ _ _ _ \u2192 refl))\n</code></pre>"},{"location":"simplicial-hott/02-simplicial-type-theory.rzk/#functorial-retracts-of-shape-inclusions","title":"Functorial retracts of shape inclusions","text":"<p>We want to express what it means for a shape inclusion <code>\u03b6 \u2282 \u03c7</code> to be a retract of another shape inclusion <code>\u03d5 \u2282 \u03c8</code>.</p> <p>If these shapes were types, we would require a commutative diagram</p> <pre><code>\u03b6 \u2282 \u03c7\n\u2193   \u2193\n\u03d5 \u2282 \u03c8\n\u2193   \u2193\n\u03b6 \u2282 \u03c7\n</code></pre> <p>such that the vertical composites are the identity. As before, we cannot say this directly; instead we express this property on representables. Since the upper vertical maps are necessarily monomorphisms, we may we may assume up to isomorphism (which we already dealt with) that <code>\u03b6 \u2282 \u03c7</code> are actual subshapes of <code>\u03d5 \u2282 \u03c8</code>.</p> <p>We observe that we must have <code>\u03b6 = \u03c7 \u2227 \u03d5</code>. Thus we have the following setting:</p> <pre><code>#section retracts-shape-inclusions\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variables \u03d5 \u03c7 : \u03c8 \u2192 TOPE\n-- \u03b6 := \u03c7 \u2227 \u03d5\n#def retract-shape-inclusion\n  : U\n  :=\n\u03a3 ( s\n    : ( A : U)\n    \u2192 ( \u03c3 : (t : I | \u03c7 t \u2227 \u03d5 t) \u2192 A)\n    \u2192 ( t : \u03d5)\n    \u2192 A [ \u03c7 t \u2227 \u03d5 t \u21a6 \u03c3 t])\n  , ( ( A : U)\n    \u2192 ( \u03c3 : (t : I | \u03c7 t \u2227 \u03d5 t) \u2192 A)\n    \u2192 ( \u03c4 : (t : \u03c7) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03c3 t])\n    \u2192 ( t : \u03c8)\n    \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 s A \u03c3 t])\n#def functorial-retract-shape-inclusion\n  : U\n  :=\n\u03a3 ( (s, S) : retract-shape-inclusion)\n  , \u03a3 ( h\n      : ( A' : U)\n      \u2192 ( A : U)\n      \u2192 ( \u03b1 : A' \u2192 A)\n      \u2192 ( \u03c3' : (t : I | \u03c7 t \u2227 \u03d5 t) \u2192 A')\n      \u2192 ( ( \\ (t : I | \u03d5 t) \u2192 \u03b1 (s A' \u03c3' t))\n        =_{ \u03d5 \u2192 A}\n          ( s A ( \\ t \u2192 \u03b1 (\u03c3' t)))))\n    , ( ( A' : U)\n      \u2192 ( A : U)\n      \u2192 ( \u03b1 : A' \u2192 A)\n      \u2192 ( \u03c3' : (t : I | \u03c7 t \u2227 \u03d5 t) \u2192 A')\n      \u2192 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03c7 t \u2227 \u03d5 t \u21a6 \u03c3' t])\n      \u2192 ( ( transport\n            ( (t : \u03d5) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n(\\ \u03c3 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03b1 (\u03c4' t) , \u03d5 t \u21a6 \u03c3 t])\n            ( \\ t \u2192 \u03b1 (s A' \u03c3' t))\n            ( \\ t \u2192 s A ( \\ t' \u2192 \u03b1 (\u03c3' t')) t)\n            ( h A' A \u03b1 \u03c3')\n            ( \\ t \u2192 \u03b1 ( S A' \u03c3' \u03c4' t)))\n        =_{ (t : \u03c8) \u2192 A [\u03d5 t \u21a6 s A (\\ t' \u2192 \u03b1 (\u03c4' t')) t]}\n          ( S A (\\ t \u2192 \u03b1 (\u03c3' t)) ( \\ t \u2192 \u03b1 (\u03c4' t)))))\n#end retracts-shape-inclusions\n</code></pre> <p>For example the pair <code>{00} \u2282 \u0394\u00b2</code> is a retract of <code>{0} \u00d7 \u0394\u00b9 \u2282 \u0394\u00b9 \u00d7 \u0394\u00b9</code>.</p> <pre><code>#def functorial-retract-00-\u0394\u00b2-0\u0394\u00b9-\u0394\u00b9\u00d7\u0394\u00b9\n  : functorial-retract-shape-inclusion (2 \u00d7 2)\n    ( \u0394\u00b9\u00d7\u0394\u00b9) ( \\ (t , _) \u2192 t \u2261 0\u2082)\n    ( \\ ts \u2192 \u0394\u00b2 ts)\n  :=\n  ( ( (\\ _ f (t , s) \u2192 recOR ( t \u2264 s \u21a6 f (t , t) , s \u2264 t \u21a6 f (t , s)))\n    , (\\ _ _ f (t , s) \u2192 recOR ( t \u2264 s \u21a6 f (t , t) , s \u2264 t \u21a6 f (t , s))))\n  , ( \\ _ _ _ _ \u2192 refl , \\ _ _ _ _ _ \u2192 refl))\n</code></pre> <p>For completeness we verify that the intesection <code>\u0394\u00b2 \u2227 {0}\u00d7\u0394\u00b9</code> is indeed <code>{00}</code>.</p> <pre><code>#def verify-functorial-retract-0-\u0394\u00b2-0\u0394\u00b9-\u0394\u00b9\u00d7\u0394\u00b9\n( A : U)\n  : ( ( shape-intersection (2 \u00d7 2) (\\ ts \u2192 \u0394\u00b2 ts) (\\ (t , _) \u2192 t \u2261 0\u2082) \u2192 A)\n    = ( ( (t, s) : 2 \u00d7 2 | t \u2261 0\u2082 \u2227 s \u2261 0\u2082) \u2192 A))\n  := refl\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/","title":"4. Equivalences involving extension types","text":"<p>These formalisations correspond to Section 3 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/4-equivalences.rzk</code> \u2014 contains the definitions of <code>Equiv</code> and   <code>comp-equiv</code></li> <li>the file <code>hott/4-equivalences.rzk</code> relies in turn on the previous files in   <code>hott/</code></li> </ul>"},{"location":"simplicial-hott/03-extension-types.rzk/#extension-up-to-homotopy","title":"Extension up to homotopy","text":"<p>For a shape inclusion <code>\u03d5 \u2282 \u03c8</code> and any type <code>A</code>, we have the inbuilt extension types <code>(t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3 t]</code> (for every <code>\u03c3 : \u03d5 \u2192 A</code>).</p> <p>We show that these extension types are equivalent to the fibers of the canonical restriction map <code>(\u03c8 \u2192 A) \u2192 (\u03d5 \u2192 A)</code>, which we can view as the types of \"extension up to homotopy\".</p> <pre><code>#section extensions-up-to-homotopy\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variable A : (t : \u03c8) \u2192 U\n#def extension-type\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : U\n  := ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03c3 t]\n#def homotopy-extension-type\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : U\n  := fib ((t : \u03c8) \u2192 A t) ((t : \u03d5) \u2192 A t) (\\ \u03c4 t \u2192 \u03c4 t) (\u03c3)\n#def extension-type-weakening-map\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : extension-type \u03c3 \u2192 homotopy-extension-type \u03c3\n  := \\ \u03c4 \u2192 ( \u03c4, refl)\n#def section-extension-type-weakening'\n  : ( \u03c3 : (t : \u03d5) \u2192 A t)\n  \u2192 ( th : homotopy-extension-type \u03c3)\n  \u2192 \u03a3 (\u03c4 : extension-type \u03c3), (( \u03c4, refl) =_{homotopy-extension-type \u03c3} th)\n  :=\n    ind-fib ((t : \u03c8) \u2192 A t) ((t : \u03d5) \u2192 A t) (\\ \u03c4 t \u2192 \u03c4 t)\n( \\ \u03c3 th \u2192\n          \u03a3 (\u03c4 : extension-type \u03c3),\n            ( \u03c4, refl) =_{homotopy-extension-type \u03c3} th)\n( \\ (\u03c4 : (t : \u03c8) \u2192 A t) \u2192 (\u03c4, refl))\n#def extension-strictification\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : (homotopy-extension-type \u03c3) \u2192 (extension-type \u03c3)\n  :=\n\\ th \u2192 first (section-extension-type-weakening' \u03c3 th)\n#def has-section-extension-type-weakening\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : has-section (extension-type \u03c3) (homotopy-extension-type \u03c3)\n      (extension-type-weakening-map \u03c3)\n  :=\n    ( extension-strictification \u03c3\n    , \\ th \u2192 ( second (section-extension-type-weakening' \u03c3 th)))\n#def is-equiv-extension-type-weakening\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : is-equiv (extension-type \u03c3) (homotopy-extension-type \u03c3)\n      (extension-type-weakening-map \u03c3)\n  :=\n    ( ( extension-strictification \u03c3, \\ _ \u2192 refl)\n    , has-section-extension-type-weakening \u03c3)\n#def extension-type-weakening\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : Equiv (extension-type \u03c3) (homotopy-extension-type \u03c3)\n  := ( extension-type-weakening-map \u03c3 , is-equiv-extension-type-weakening \u03c3)\n#end extensions-up-to-homotopy\n</code></pre> <p>This equivalence is functorial in the following sense:</p> <pre><code>#def extension-type-weakening-functorial\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A' A : (t : \u03c8) \u2192 U)\n( \u03b1 : (t : \u03c8) \u2192 A' t \u2192 A t)\n( \u03c3' : (t : \u03d5) \u2192 A' t)\n  : Equiv-of-maps\n    ( extension-type I \u03c8 \u03d5 A' \u03c3')\n    ( extension-type I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t)))\n    ( \\ \u03c4' t \u2192 \u03b1 t (\u03c4' t))\n    ( homotopy-extension-type I \u03c8 \u03d5 A' \u03c3')\n    ( homotopy-extension-type I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t)))\n    ( \\ (\u03c4', p) \u2192\n      ( \\ t \u2192 \u03b1 t (\u03c4' t)\n      , ap\n( (t : \u03d5) \u2192 A' t)\n( (t : \u03d5) \u2192 A t)\n( \\ (t : \u03d5) \u2192 \u03c4' t)\n( \\ (t : \u03d5) \u2192 \u03c3' t)\n        ( \\ \u03c3'' t \u2192 \u03b1 t (\u03c3'' t))\n        ( p)))\n  :=\n    ( ( ( extension-type-weakening-map I \u03c8 \u03d5 A' \u03c3'\n        , extension-type-weakening-map I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t)))\n      , ( \\ _ \u2192 refl))\n    , ( is-equiv-extension-type-weakening I \u03c8 \u03d5 A' \u03c3'\n      , is-equiv-extension-type-weakening I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t))))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#commutation-of-arguments-and-currying","title":"Commutation of arguments and currying","text":"RS17, Theorem 4.1<pre><code>#def flip-ext-fun\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : U)\n( Y : \u03c8 \u2192 X \u2192 U)\n( f : (t : \u03d5) \u2192 (x : X) \u2192 Y t x)\n  : Equiv\n( (t : \u03c8) \u2192 ((x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t])\n( (x : X) \u2192 (t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x])\n  :=\n    ( ( \\ g x t \u2192 g t x)\n    , ( ( \\ h t x \u2192 (h x) t , \\ g \u2192 refl)\n      , ( \\ h t x \u2192 (h x) t , \\ h \u2192 refl)))\n#def flip-ext-fun-inv\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : U)\n( Y : \u03c8 \u2192 X \u2192 U)\n( f : (t : \u03d5) \u2192 (x : X) \u2192 Y t x)\n  : Equiv\n( (x : X) \u2192 (t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x])\n( (t : \u03c8) \u2192 ((x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t])\n  :=\n    ( ( \\ h t x \u2192 (h x) t)\n    , ( ( \\ g x t \u2192 g t x , \\ h \u2192 refl)\n      , ( \\ g x t \u2192 g t x , \\ g \u2192 refl)))\n</code></pre> RS17, Theorem 4.2<pre><code>#def curry-uncurry\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n( X : \u03c8 \u2192 \u03b6 \u2192 U)\n( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s)\n  : Equiv\n( ( t : \u03c8)\n    \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)])\n      [ \u03d5 t \u21a6 \\ s \u2192 f (t , s)])\n    ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 ( X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]))\n  :=\n    ( ( \\ g (t , s) \u2192 (g t) s)\n    , ( ( \\ h t s \u2192 h (t , s) , \\ g \u2192 refl)\n      , ( \\ h t s \u2192 h (t , s) , \\ h \u2192 refl)))\n#def uncurry-opcurry\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n( X : \u03c8 \u2192 \u03b6 \u2192 U)\n( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s)\n  : Equiv\n    ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 ( X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]))\n( ( s : \u03b6)\n    \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)])\n      [ \u03c7 s \u21a6 \\ t \u2192 f (t , s)])\n  :=\n    ( ( \\ h s t \u2192 h (t , s))\n    , ( ( \\ g (t , s) \u2192 (g s) t , \\ h \u2192 refl)\n      , ( \\ g (t , s) \u2192 (g s) t , \\ g \u2192 refl)))\n#def fubini\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n( X : \u03c8 \u2192 \u03b6 \u2192 U)\n( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s)\n  : Equiv\n( ( t : \u03c8)\n    \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)])\n( ( s : \u03b6)\n    \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)])\n  :=\n    equiv-comp\n( ( t : \u03c8)\n      \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)])\n      ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n      \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)])\n( ( s : \u03b6)\n      \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)])\n      ( curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f)\n      ( uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f)\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#functorial-instances","title":"Functorial instances","text":"<p>For each of these we provide a corresponding functorial instance</p> <pre><code>#def flip-ext-fun-functorial\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : U)\n( A' A : \u03c8 \u2192 X \u2192 U)\n( \u03b1 : (t : \u03c8) \u2192 (x : X) \u2192 A' t x \u2192 A t x)\n( \u03c3' : (t : \u03d5) \u2192 (x : X) \u2192 A' t x)\n  : Equiv-of-maps\n( (t : \u03c8) \u2192 ((x : X) \u2192 A' t x) [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 ((x : X) \u2192 A t x) [\u03d5 t \u21a6 \\ x \u2192 \u03b1 t x (\u03c3' t x)])\n    ( \\ \u03c4 t x \u2192 \u03b1 t x (\u03c4 t x))\n( (x : X) \u2192 (t : \u03c8) \u2192 A' t x [\u03d5 t \u21a6 \u03c3' t x])\n( (x : X) \u2192 (t : \u03c8) \u2192 A t x [\u03d5 t \u21a6 \u03b1 t x (\u03c3' t x)])\n    ( \\ \u03c4 x t \u2192 \u03b1 t x (\u03c4 x t))\n  :=\n    ( ( ( first (flip-ext-fun I \u03c8 \u03d5 X A' \u03c3')\n        , first (flip-ext-fun I \u03c8 \u03d5 X A (\\ t x \u2192 \u03b1 t x (\u03c3' t x))))\n      , ( \\ _ \u2192 refl))\n    , ( second (flip-ext-fun I \u03c8 \u03d5 X A' \u03c3')\n      , second (flip-ext-fun I \u03c8 \u03d5 X A (\\ t x \u2192 \u03b1 t x (\u03c3' t x)))))\n#def curry-uncurry-functorial\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n( A' A : \u03c8 \u2192 \u03b6 \u2192 U)\n( \u03b1 : (t : \u03c8) \u2192 (s : \u03b6) \u2192 A' t s \u2192 A t s)\n( \u03c3' : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 A' t s)\n  : Equiv-of-maps\n( ( t : \u03c8)\n    \u2192 ( (s : \u03b6) \u2192 A' t s [\u03c7 s \u21a6 \u03c3' (t , s)])\n      [ \u03d5 t \u21a6 \\ s \u2192 \u03c3' (t , s)])\n( ( t : \u03c8)\n    \u2192 ( (s : \u03b6) \u2192 A t s [\u03c7 s \u21a6 \u03b1 t s (\u03c3' (t , s))])\n      [ \u03d5 t \u21a6 \\ s \u2192 \u03b1 t s (\u03c3' (t , s))])\n    ( \\ \u03c4' t s \u2192 \u03b1 t s (\u03c4' t s))\n    ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 ( A' t s) [ (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 \u03c3' (t , s)])\n    ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 ( A t s) [ (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 \u03b1 t s (\u03c3' (t , s))])\n    ( \\ u\u03c4' (t , s) \u2192 \u03b1 t s (u\u03c4' (t , s)))\n  :=\n  ( ( ( first (curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 A' \u03c3')\n      , first (curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 A ( \\ (t , s) \u2192 \u03b1 t s (\u03c3' (t , s)))))\n    , ( \\ _ \u2192 refl))\n  , ( second (curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 A' \u03c3')\n    , second (curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 A ( \\ (t , s) \u2192 \u03b1 t s (\u03c3' (t , s))))))\n#def uncurry-opcurry-functorial\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n( A' A : \u03c8 \u2192 \u03b6 \u2192 U)\n( \u03b1 : (t : \u03c8) \u2192 (s : \u03b6) \u2192 A' t s \u2192 A t s)\n( \u03c3' : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 A' t s)\n  : Equiv-of-maps\n    ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 ( A' t s) [ (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 \u03c3' (t , s)])\n    ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192  ( A t s) [ (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 \u03b1 t s (\u03c3' (t , s))])\n    ( \\ u\u03c4' (t , s) \u2192 \u03b1 t s (u\u03c4' (t , s)))\n( ( s : \u03b6)\n    \u2192 ( (t : \u03c8) \u2192 A' t s [\u03d5 t \u21a6 \u03c3' (t , s)])\n      [ \u03c7 s \u21a6 \\ t \u2192 \u03c3' (t , s)])\n( ( s : \u03b6)\n    \u2192 ( (t : \u03c8) \u2192 A t s [\u03d5 t \u21a6 \u03b1 t s ( \u03c3' (t , s))])\n      [ \u03c7 s \u21a6 \\ t \u2192 \u03b1 t s (\u03c3' (t , s))])\n    ( \\ \u03c4' s t \u2192 \u03b1 t s (\u03c4' s t))\n  :=\n  ( ( ( first (uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 A' \u03c3')\n      , first (uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 A ( \\ (t , s) \u2192 \u03b1 t s (\u03c3' (t , s)))))\n    , ( \\ _ \u2192 refl))\n  , ( second (uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 A' \u03c3')\n    , second (uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 A ( \\ (t , s) \u2192 \u03b1 t s (\u03c3' (t , s))))))\n#def fubini-functorial\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n( A' A : \u03c8 \u2192 \u03b6 \u2192 U)\n( \u03b1 : (t : \u03c8) \u2192 (s : \u03b6) \u2192 A' t s \u2192 A t s)\n( \u03c3' : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 A' t s)\n  : Equiv-of-maps\n( ( t : \u03c8)\n    \u2192 ( (s : \u03b6) \u2192 A' t s [\u03c7 s \u21a6 \u03c3' (t , s)])\n      [ \u03d5 t \u21a6 \\ s \u2192 \u03c3' (t , s)])\n( ( t : \u03c8)\n    \u2192 ( (s : \u03b6) \u2192 A t s [\u03c7 s \u21a6 \u03b1 t s (\u03c3' (t , s))])\n      [ \u03d5 t \u21a6 \\ s \u2192 \u03b1 t s (\u03c3' (t , s))])\n    ( \\ \u03c4' t s \u2192 \u03b1 t s (\u03c4' t s))\n( ( s : \u03b6)\n    \u2192 ( (t : \u03c8) \u2192 A' t s [\u03d5 t \u21a6 \u03c3' (t , s)])\n      [ \u03c7 s \u21a6 \\ t \u2192 \u03c3' (t , s)])\n( ( s : \u03b6)\n    \u2192 ( (t : \u03c8) \u2192 A t s [\u03d5 t \u21a6 \u03b1 t s( \u03c3' (t , s))])\n      [ \u03c7 s \u21a6 \\ t \u2192 \u03b1 t s (\u03c3' (t , s))])\n    ( \\ \u03c4' s t \u2192 \u03b1 t s (\u03c4' s t))\n  :=\n  ( ( ( first (fubini I J \u03c8 \u03d5 \u03b6 \u03c7 A' \u03c3')\n      , first (fubini I J \u03c8 \u03d5 \u03b6 \u03c7 A ( \\ (t , s) \u2192 \u03b1 t s (\u03c3' (t , s)))))\n    , ( \\ _ \u2192 refl))\n  , ( second (fubini I J \u03c8 \u03d5 \u03b6 \u03c7 A' \u03c3')\n    , second (fubini I J \u03c8 \u03d5 \u03b6 \u03c7 A ( \\ (t , s) \u2192 \u03b1 t s (\u03c3' (t , s))))))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#extending-into-types-the-non-axiom-of-choice","title":"Extending into \u03a3-types (the non-axiom of choice)","text":"RS17, Theorem 4.3<pre><code>#def axiom-choice\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : \u03c8 \u2192 U)\n( Y : (t : \u03c8) \u2192 (x : X t) \u2192 U)\n( a : (t : \u03d5) \u2192 X t)\n( b : (t : \u03d5) \u2192 Y t (a t))\n  : Equiv\n( (t : \u03c8) \u2192 (\u03a3 (x : X t) , Y t x) [\u03d5 t \u21a6 (a t , b t)])\n( \u03a3 ( f : ((t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]))\n      , ( (t : \u03c8) \u2192 Y t (f t) [\u03d5 t \u21a6 b t]))\n    :=\n      ( ( \\ g \u2192 (\\ t \u2192 (first (g t)) , \\ t \u2192 second (g t)))\n      , ( ( \\ (f , h) t \u2192 (f t , h t) , \\ _ \u2192 refl)\n        , ( \\ (f , h) t \u2192 (f t , h t) , \\ _ \u2192 refl)))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#composites-and-unions-of-cofibrations","title":"Composites and unions of cofibrations","text":"<p>The original form.</p> RS17, Theorem 4.4<pre><code>#def cofibration-composition\n( I : CUBE)\n( \u03c7 : I \u2192 TOPE)\n( \u03c8 : \u03c7 \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : \u03c7 \u2192 U)\n( a : (t : \u03d5) \u2192 X t)\n  : Equiv\n( (t : \u03c7) \u2192 X t [\u03d5 t \u21a6 a t])\n( \u03a3 ( f : (t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]) ,\n( (t : \u03c7) \u2192 X t [\u03c8 t \u21a6 f t]))\n  :=\n    ( ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t))\n    , ( ( \\ (_ , g) t \u2192 g t , \\ _ \u2192 refl)\n      , ( ( \\ (_ , g) t \u2192 g t , \\ _ \u2192 refl))))\n</code></pre> <p>A reformulated version via tope disjunction instead of inclusion (see https://github.com/rzk-lang/rzk/issues/8).</p> RS17, Theorem 4.4<pre><code>#def cofibration-composition'\n( I : CUBE)\n( \u03c7 \u03c8 \u03d5 : I \u2192 TOPE)\n( X : \u03c7 \u2192 U)\n( a : (t : I | \u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t) \u2192 X t)\n  : Equiv\n( (t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t])\n( \u03a3 ( f : (t : I | \u03c7 t \u2227 \u03c8 t) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t])\n        , ( (t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u21a6 f t]))\n  :=\n    ( ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t))\n    , ( ( \\ (_ , g) t \u2192 g t , \\ _ \u2192 refl)\n      , ( \\ (_ , g) t \u2192 g t , \\ _ \u2192 refl)))\n</code></pre> <p>Another variant is the following:</p> <pre><code>#def cofibration-composition''\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 \u03c7 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : I | \u03d5 t) \u2192 A t)\n  : Equiv\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( \u03a3 ( b : (t : I | \u03c7 t) \u2192 A t [\u03c7 t \u2227 \u03d5 t \u21a6 a t])\n      , (t : \u03c8) \u2192 A t [\u03c7 t \u21a6 b t , \u03d5 t \u21a6 a t])\n  :=\n  ( \\ c \u2192 (\\ t \u2192 c t , \\ t \u2192 c t)\n  , ( ( \\ (_ , c) t \u2192 c t\n      , \\ _ \u2192 refl)\n    , ( \\ (_ , c) t \u2192 c t\n      , \\ _ \u2192 refl)))\n</code></pre> RS17, Theorem 4.5<pre><code>#def cofibration-union\n( I : CUBE)\n( \u03d5 \u03c8 : I \u2192 TOPE)\n( X : (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 U)\n( a : (t : \u03c8) \u2192 X t)\n  : Equiv\n( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 X t [\u03c8 t \u21a6 a t])\n( (t : \u03d5) \u2192 X t [\u03d5 t \u2227 \u03c8 t \u21a6 a t])\n  :=\n    ( \\ h t \u2192 h t\n    , ( ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl)\n      , ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl)))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#functorial-instances_1","title":"Functorial instances","text":"<pre><code>#def cofibration-composition-functorial\n( I : CUBE)\n( \u03c7 : I \u2192 TOPE)\n( \u03c8 : \u03c7 \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A' A : \u03c7 \u2192 U)\n( \u03b1 : (t : \u03c7) \u2192 A' t \u2192 A t)\n( \u03c3' : (t : \u03d5) \u2192 A' t)\n  : Equiv-of-maps\n( (t : \u03c7) \u2192 A' t [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c7) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (\u03c3' t)])\n    ( \\ \u03c4' t \u2192 \u03b1 t (\u03c4' t))\n( \u03a3 ( \u03c4' : (t : \u03c8) \u2192 A' t [\u03d5 t \u21a6 \u03c3' t])\n      , ( (t : \u03c7) \u2192 A' t [\u03c8 t \u21a6 \u03c4' t]))\n( \u03a3 ( \u03c4 : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (\u03c3' t)])\n      , ( (t : \u03c7) \u2192 A t [\u03c8 t \u21a6 \u03c4 t]))\n    ( \\ (\u03c4', \u03c5') \u2192 ( \\ t \u2192 \u03b1 t (\u03c4' t), \\t \u2192 \u03b1 t (\u03c5' t)))\n  :=\n    ( ( ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t) , \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t))\n      , ( \\ _ \u2192 refl))\n    , ( ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)\n        , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)))\n      , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)\n        , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)))))\n#def cofibration-composition-functorial''\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 \u03c7 : \u03c8 \u2192 TOPE)\n( A' A : (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 U)\n( \u03b1 : (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 A' t \u2192 A t)\n( a' : (t : I | \u03d5 t) \u2192 A' t)\n  : Equiv-of-maps\n( (t : \u03c8) \u2192 A' t [\u03d5 t \u21a6 a' t])\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (a' t)])\n    ( \\ c t \u2192 \u03b1 t (c t))\n( \u03a3 ( b' : (t : I | \u03c7 t) \u2192 A' t [\u03c7 t \u2227 \u03d5 t \u21a6 a' t])\n      , (t : \u03c8) \u2192 A' t [\u03c7 t \u21a6 b' t , \u03d5 t \u21a6 a' t])\n( \u03a3 ( b : (t : I | \u03c7 t) \u2192 A t [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 t (a' t)])\n      , (t : \u03c8) \u2192 A t [\u03c7 t \u21a6 b t , \u03d5 t \u21a6 \u03b1 t (a' t)])\n    ( \\ (b , c) \u2192 (\\ t \u2192 \u03b1 t (b t) , \\ t \u2192 \u03b1 t (c t)))\n  :=\n  ( ( ( first (cofibration-composition'' I \u03c8 \u03d5 \u03c7 A' a')\n      , first (cofibration-composition'' I \u03c8 \u03d5 \u03c7 A (\\ t \u2192 \u03b1 t (a' t))))\n    , \\ _ \u2192 refl)\n  , ( second (cofibration-composition'' I \u03c8 \u03d5 \u03c7 A' a')\n    , second (cofibration-composition'' I \u03c8 \u03d5 \u03c7 A (\\ t \u2192 \u03b1 t (a' t)))))\n#def cofibration-union-functorial\n( I : CUBE)\n( \u03d5 \u03c8 : I \u2192 TOPE)\n( A' A : (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 U)\n( \u03b1 : (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 A' t \u2192 A t)\n( \u03c4' : (t : \u03c8) \u2192 A' t)\n  : Equiv-of-maps\n( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 A' t [\u03c8 t \u21a6 \u03c4' t])\n( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 A t [\u03c8 t \u21a6 \u03b1 t (\u03c4' t)])\n      ( \\ \u03c5' t \u2192 \u03b1 t (\u03c5' t))\n( (t : \u03d5) \u2192 A' t [\u03d5 t \u2227 \u03c8 t \u21a6 \u03c4' t])\n( (t : \u03d5) \u2192 A t [\u03d5 t \u2227 \u03c8 t \u21a6 \u03b1 t (\u03c4' t)])\n      ( \\ \u03bd' t \u2192 \u03b1 t (\u03bd' t))\n  :=\n     ( ( ( \\ \u03c5' t \u2192 \u03c5' t , \\ \u03c5 t \u2192 \u03c5 t)\n       , ( \\ _ \u2192 refl))\n     , ( ( second (cofibration-union I \u03d5 \u03c8 A' \u03c4'))\n       , ( second (cofibration-union I \u03d5 \u03c8 A ( \\ t \u2192 \u03b1 t (\u03c4' t))))))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#extension-extensionality","title":"Extension extensionality","text":"<p>There are various equivalent forms of the relative function extensionality axiom for extension types. One form corresponds to the standard weak function extensionality. As suggested by footnote 8, we refer to this as a \"weak extension extensionality\" axiom.</p> RS17, Axiom 4.6, Weak extension extensionality<pre><code>#define WeakExtExt\n  : U\n  := ( I : CUBE) \u2192 (\u03c8 : I \u2192 TOPE) \u2192 (\u03d5 : \u03c8 \u2192 TOPE) \u2192 (A : \u03c8 \u2192 U) \u2192\n( is-locally-contr-A : (t : \u03c8) \u2192 is-contr (A t)) \u2192\n( a : (t : \u03d5) \u2192 A t) \u2192 is-contr ((t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n</code></pre> <p>We refer to another form as an \"extension extensionality\" axiom.</p> <pre><code>#def ext-htpy-eq\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5) \u2192 A t)\n( f g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( p : f = g)\n  : (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl]\n  :=\n    ind-path\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n      ( f)\n( \\ g' p' \u2192 (t : \u03c8) \u2192 (f t = g' t) [\u03d5 t \u21a6 refl])\n      ( \\ _ \u2192 refl)\n      ( g)\n      ( p)\n</code></pre> RS17, Proposition 4.8(ii)<pre><code>#def ExtExt\n  : U\n  :=\n( ( I : CUBE)\n    \u2192 ( \u03c8 : I \u2192 TOPE)\n    \u2192 ( \u03d5 : \u03c8 \u2192 TOPE)\n    \u2192 ( A : \u03c8 \u2192 U)\n    \u2192 ( a : (t : \u03d5) \u2192 A t)\n    \u2192 ( f : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n    \u2192 ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n    \u2192 is-equiv\n      ( f = g)\n( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n      ( ext-htpy-eq I \u03c8 \u03d5 A a f g))\n</code></pre> The equivalence provided by extension extensionality<pre><code>#def equiv-ExtExt\n( extext : ExtExt)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5) \u2192 A t)\n( f g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  : Equiv (f = g) ((t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n  := (ext-htpy-eq I \u03c8 \u03d5 A a f g , extext I \u03c8 \u03d5 A a f g)\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#naive-extension-extensionality","title":"Naive extension extensionality","text":"<p>For readability of code, it is useful to the function that supplies an equality between terms of an extension type from a pointwise equality extending refl. In fact, sometimes only this weaker form of the axiom is needed.</p> <pre><code>#def NaiveExtExt\n  : U\n  :=\n( ( I : CUBE)\n  \u2192 ( \u03c8 : I \u2192 TOPE)\n  \u2192 ( \u03d5 : \u03c8 \u2192 TOPE)\n  \u2192 ( A : \u03c8 \u2192 U)\n  \u2192 ( a : (t : \u03d5) \u2192 A t)\n  \u2192 ( f : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  \u2192 ( g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  \u2192 ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n  \u2192 ( f = g))\n#def naiveextext-extext\n( extext : ExtExt)\n  : NaiveExtExt\n  := \\ I \u03c8 \u03d5 A a f g \u2192 ( first (first (extext I \u03c8 \u03d5 A a f g)))\n</code></pre> <p>We show that naive extension extensionality implies weak extension extensionality. On the way, we obtain another useful version of extension extensionality, stating that all extension types in a proposition are propositions.</p> <pre><code>#section weakextext-naiveextext\n#variable naiveextext : NaiveExtExt\n#def is-prop-shape-type-is-locally-prop uses (naiveextext)\n( I : CUBE)\n( \u03d5 : I \u2192 TOPE)\n( A : \u03d5 \u2192 U)\n( is-locally-prop-A : (t : \u03d5) \u2192 is-prop (A t))\n  : is-prop ((t : \u03d5) \u2192 A t)\n  :=\n    is-prop-all-elements-equal ((t : \u03d5) \u2192 A t)\n    ( \\ a a' \u2192\n      naiveextext I (\\ t \u2192 \u03d5 t) (\\ _ \u2192 \u22a5) (\\ t \u2192 A t) (\\ _ \u2192 recBOT) a a'\n      ( \\ t \u2192 first ( is-locally-prop-A t (a t) (a' t))))\n#def is-prop-extension-type-is-locally-prop uses (naiveextext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-locally-prop-A : (t : \u03c8) \u2192 is-prop (A t))\n  : ( a : (t : \u03d5) \u2192 A t) \u2192 is-prop ((t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  :=\n    is-fiberwise-prop-is-prop-total-type-is-prop-base\n( ( t : \u03d5) \u2192 A t)\n    ( is-prop-shape-type-is-locally-prop I (\\ t \u2192 \u03d5 t) (\\ t \u2192 A t)\n      ( \\ t \u2192 is-locally-prop-A t))\n( \\ a \u2192 (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( is-prop-Equiv-is-prop'\n      ( ( t : \u03c8) \u2192 A t)\n( \u03a3 (a : (t : \u03d5) \u2192 A t), (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n      ( cofibration-composition I \u03c8 \u03d5 (\\ _ \u2192 BOT) (\\ t \u2192 A t) (\\ _ \u2192 recBOT))\n      ( is-prop-shape-type-is-locally-prop I \u03c8 A is-locally-prop-A))\n</code></pre> <p>Still using <code>naiveextext</code>, in a fiberwise contractible family, every extension type is always inhabited.</p> <pre><code>#def is-inhabited-extension-type-is-locally-contr uses (naiveextext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-locally-contr-A : (t : \u03c8) \u2192 is-contr (A t))\n( a : (t : \u03d5) \u2192 A t)\n  : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]\n  :=\n    extension-strictification I \u03c8 \u03d5 A a\n( \\ (t : \u03c8) \u2192 first (is-locally-contr-A t)\n    , naiveextext I (\\ t \u2192 \u03d5 t) (\\ _ \u2192 BOT) (\\ t \u2192 A t) (\\ _ \u2192 recBOT)\n( \\ ( t : \u03d5) \u2192 first (is-locally-contr-A t) )\n( \\ ( t : \u03d5) \u2192 a t)\n( \\ ( t : \u03d5) \u2192 second (is-locally-contr-A t) (a t)))\n#end weakextext-naiveextext\n</code></pre> <p>We conclude that naive extension extensionality implies weak extension extensionality.</p> <pre><code>#def weakextext-naiveextext\n  : NaiveExtExt \u2192 WeakExtExt\n  :=\n\\ naiveextext I \u03c8 \u03d5 A is-locally-contr-A a \u2192\n( is-contr-is-inhabited-is-prop\n      ( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n      ( is-prop-extension-type-is-locally-prop naiveextext\n        ( I) ( \u03c8) ( \u03d5) (A)\n        ( \\ t \u2192 is-prop-is-contr (A t) ( is-locally-contr-A t))\n        ( a))\n      ( is-inhabited-extension-type-is-locally-contr naiveextext I \u03c8 \u03d5 A\n        ( is-locally-contr-A) ( a)))\n</code></pre> <p>For convenience we also provide the composite implication from extension extensionality to weak extension extensionality:</p> <pre><code>#def weakextext-extext\n  : ExtExt \u2192 WeakExtExt\n  :=\n    comp ExtExt NaiveExtExt WeakExtExt\n    ( weakextext-naiveextext) (naiveextext-extext)\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#weak-extension-extensionality-implies-extension-extensionality","title":"Weak extension extensionality implies extension extensionality","text":"<p>Weak extension extensionality implies extension extensionality; this is the context of RS17 Proposition 4.8 (i). We prove this in a series of lemmas. The <code>ext-projection-temp</code> function is a (hopefully temporary) helper that explicitly cases an extension type to a function type.</p> <pre><code>#section rs-4-8\n#variable  weakextext : WeakExtExt\n#variable  I : CUBE\n#variable  \u03c8 : I \u2192 TOPE\n#variable  \u03d5 : \u03c8 \u2192 TOPE\n#variable  A : \u03c8 \u2192 U\n#variable  a : (t : \u03d5 ) \u2192 A t\n#variable  f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t]\n#define ext-projection-temp uses (I \u03c8 \u03d5 A a f)\n  : ((t : \u03c8 ) \u2192 A t)\n  := f\n#define is-contr-ext-based-paths uses (weakextext f)\n  : is-contr\n( ( t : \u03c8 )\n    \u2192 ( \u03a3 (y : A t) , ((ext-projection-temp) t = y))\n      [ \u03d5 t \u21a6 (a t , refl)])\n  :=\n    weakextext I \u03c8 \u03d5\n( \\ t \u2192 (\u03a3 (y : A t) , ((ext-projection-temp) t = y)))\n    ( \\ t \u2192 is-contr-based-paths (A t ) ((ext-projection-temp) t))\n    ( \\ t \u2192 (a t , refl) )\n#define is-contr-ext-endpoint-based-paths uses (weakextext f)\n  : is-contr\n( ( t : \u03c8)\n    \u2192 ( \u03a3 (y : A t) , (y = ext-projection-temp t))\n      [ \u03d5 t \u21a6 (a t , refl)])\n  :=\n    weakextext I \u03c8 \u03d5\n( \\ t \u2192 (\u03a3 (y : A t) , y = ext-projection-temp t))\n    ( \\ t \u2192 is-contr-endpoint-based-paths (A t) (ext-projection-temp t))\n    ( \\ t \u2192 (a t , refl))\n#define is-contr-based-paths-ext uses (weakextext)\n  : is-contr\n( \u03a3 ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n      , ( (t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl]))\n  :=\n    is-contr-equiv-is-contr\n( (t : \u03c8 ) \u2192 (\u03a3 (y : A t),\n                     ((ext-projection-temp ) t = y)) [\u03d5 t \u21a6 (a t , refl)] )\n( \u03a3 (g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t]) ,\n(t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl] )\n    ( axiom-choice I \u03c8 \u03d5 A\n      ( \\ t y \u2192 (ext-projection-temp) t = y)\n      ( a )\n      ( \\t \u2192 refl ))\n    ( is-contr-ext-based-paths)\n#end rs-4-8\n</code></pre> <p>The map that defines extension extensionality</p> RS17 4.7<pre><code>#define extext-weakextext-map\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n( f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n  : ( ( \u03a3 ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t]), (f = g))\n    \u2192 ( \u03a3 ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n      , ( ( t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])))\n  :=\n    total-map\n( (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n    ( \\ g \u2192 (f = g))\n( \\ g \u2192 (t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n    ( ext-htpy-eq I \u03c8 \u03d5 A a f)\n</code></pre> <p>The total bundle version of extension extensionality</p> <pre><code>#define extext-weakextext-bundle-version\n( weakextext : WeakExtExt)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n( f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n  : is-equiv\n( ( \u03a3 ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t]), (f = g)))\n( \u03a3 ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n      , ( ( t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl]))\n    ( extext-weakextext-map I \u03c8 \u03d5 A a f)\n  :=\n    is-equiv-are-contr\n( \u03a3 ( g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]), (f = g))\n( \u03a3 ( g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n    , ( ( t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl]))\n( is-contr-based-paths ((t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) (f))\n    ( is-contr-based-paths-ext weakextext I \u03c8 \u03d5 A a f)\n    ( extext-weakextext-map I \u03c8 \u03d5 A a f)\n</code></pre> <p>Finally, using equivalences between families of equivalences and bundles of equivalences we have that weak extension extensionality implies extension extensionality. The following is statement the as proved in RS17.</p> RS17 Prop 4.8(i) as proved<pre><code>#define extext-weakextext'\n( weakextext : WeakExtExt)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n( f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n  : ( ( g : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n    \u2192 is-equiv\n        ( f = g)\n( (t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n        ( ext-htpy-eq I \u03c8 \u03d5 A a f g))\n  := is-equiv-fiberwise-is-equiv-total\n( (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t] )\n      ( \\ g \u2192 (f = g) )\n( \\ g \u2192 (t : \u03c8 ) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n      ( ext-htpy-eq I \u03c8 \u03d5 A a f)\n      ( extext-weakextext-bundle-version weakextext I \u03c8 \u03d5 A a f)\n</code></pre> <p>The following is the literal statement of weak extension extensionality implying extension extensionality that we get by extracting the fiberwise equivalence.</p> RS17 Proposition 4.8(i)<pre><code>#define extext-weakextext\n  : WeakExtExt \u2192 ExtExt\n  := extext-weakextext'\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#homotopy-extension-property","title":"Homotopy extension property","text":"<p>The homotopy extension property has the following signature. We state this separately since below we will will show that this follows from extension extensionality.</p> <pre><code>#def instance-HtpyExtProperty\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( b : (t : \u03c8) \u2192 A t)\n( a : (t : \u03d5) \u2192 A t)\n( e : (t : \u03d5) \u2192 a t = b t)\n  : U\n  :=\n\u03a3 (a' : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n    , ((t : \u03c8) \u2192 (a' t =_{ A t} b t) [\u03d5 t \u21a6 e t])\n#def HtpyExtProperty\n  : U\n  :=\n( ( I : CUBE)\n    \u2192 ( \u03c8 : I \u2192 TOPE)\n    \u2192 ( \u03d5 : \u03c8 \u2192 TOPE)\n    \u2192 ( A : \u03c8 \u2192 U)\n    \u2192 ( b : (t : \u03c8) \u2192 A t)\n    \u2192 ( a : (t : \u03d5) \u2192 A t)\n    \u2192 ( e : (t : \u03d5) \u2192 a t = b t)\n    \u2192 ( instance-HtpyExtProperty I \u03c8 \u03d5 A b a e))\n</code></pre> <p>If we assume weak extension extensionality, then then homotopy extension property follows from a straightforward application of the axiom of choice to the point of contraction for weak extension extensionality.</p> RS17 Proposition 4.10<pre><code>#define htpy-ext-prop-weakextext\n( weakextext : WeakExtExt)\n  : HtpyExtProperty\n  :=\n\\ I \u03c8 \u03d5 A b a e \u2192\nfirst\n    ( axiom-choice I \u03c8 \u03d5 A\n      ( \\ t y \u2192 y = b t)\n      ( a)\n      ( e))\n( first\n      ( weakextext I \u03c8 \u03d5\n        ( \\ t \u2192 (\u03a3 (y : A t) , y = b t))\n        ( \\ t \u2192 is-contr-endpoint-based-paths ( A t) ( b t))\n        ( \\ t \u2192 ( a t , e t) )))\n</code></pre> <p>For completeness, we give a short direct proof that extension extensionality also implies the homotopy extension property without passing through weak extension extensionality.</p> <pre><code>#def htpy-ext-prop-extext\n( extext : ExtExt)\n  : HtpyExtProperty\n  :=\n\\ I \u03c8 \u03d5 A b a \u2192\n  ind-has-section-equiv (a = (\\ (t : \u03d5) \u2192 b t)) ((t : \u03d5) \u2192 a t = b t)\n  ( equiv-ExtExt extext I (\\ t \u2192 \u03d5 t) (\\ _ \u2192 BOT) (\\ t \u2192 A t) (\\ _ \u2192 recBOT)\n    ( a) (\\ (t : \u03d5) \u2192 b t))\n  ( instance-HtpyExtProperty I \u03c8 \u03d5 A b a)\n( \\ e' \u2192\n    ind-rev-fib\n    ( (t : \u03c8) \u2192 A t) ((t : \u03d5) \u2192 A t) (\\ b' t \u2192 b' t)\n    ( \\ a' (b', p) \u2192\n      instance-HtpyExtProperty I \u03c8 \u03d5 A b' a'\n      ( ext-htpy-eq I (\\ t \u2192 \u03d5 t) (\\ _ \u2192 BOT) (\\ t \u2192 A t) (\\ _ \u2192 recBOT)\n        ( a') (\\ (t : \u03d5) \u2192 b' t) ( p)))\n    ( \\ b' \u2192 ( b' , \\ _ \u2192 refl))\n    ( a) (b , e'))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#homotopy-extension-property-and-naiveextext-imply-weakextext","title":"Homotopy extension property and NaiveExtExt imply WeakExtExt","text":"<p>This section contains the original proof of RS17, Proposition 4.11 stating that NaiveExtExt and HptyExtProperty jointly imply WeakExtExt. In light of <code>weakextext-naiveextext</code>, this is now redundant. We keep it around since some intermediate statements might still be useful.</p> <p>In an extension type of a dependent type that is pointwise contractible, then we have an inhabitant of the extension type witnessing the contraction, at every inhabitant of the base, of each point in the fiber to the center of the fiber. Both directions of this statement will be needed.</p> <pre><code>#def eq-ext-is-contr\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n( is-contr-fiberwise-A : (t : \u03c8 ) \u2192 is-contr ( A t))\n  : (t : \u03d5 ) \u2192 ((first (is-contr-fiberwise-A t)) = a t)\n  := \\ t \u2192 ( second (is-contr-fiberwise-A t) (a t))\n#def codomain-eq-ext-is-contr\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n( is-contr-fiberwise-A : (t : \u03c8 ) \u2192 is-contr ( A t))\n  : (t : \u03d5 ) \u2192 (a t = first (is-contr-fiberwise-A t))\n  :=\n\\ t \u2192\n      rev\n      ( A t )\n      ( first (is-contr-fiberwise-A t) )\n      ( a t)\n      ( second (is-contr-fiberwise-A t) (a t))\n</code></pre> <p>The below gives us the inhabitant \\((a', e') : \\sum_{\\left\\langle\\prod_{t : I|\\psi} A (t) \\biggr|^\\phi_a\\right\\rangle} \\left\\langle \\prod_{t: I |\\psi} a'(t) = b(t)\\biggr|^\\phi_e \\right\\rangle\\) from the first part of the proof of RS Prop 4.11. It amounts to the fact that parameterized contractibility, i.e. <code>A : \u03c8 \u2192 U</code> such that each <code>A t</code> is contractible, implies the hypotheses of the homotopy extension property are satisfied, and so assuming homotopy extension property, we are entitled to the conclusion.</p> <pre><code>#define htpy-ext-prop-is-fiberwise-contr\n(htpy-ext-property : HtpyExtProperty)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n(is-contr-fiberwise-A : (t : \u03c8 ) \u2192 is-contr (A t))\n  : \u03a3 ( a' : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n    , ( ( t : \u03c8 )\n      \u2192 ( ( a' t) =_{ A t} first (is-contr-fiberwise-A t))\n        [ \u03d5 t \u21a6 codomain-eq-ext-is-contr I \u03c8 \u03d5 A a is-contr-fiberwise-A t] )\n  :=\n    htpy-ext-property I \u03c8 \u03d5 A\n    (\\ t \u2192  first (is-contr-fiberwise-A t))\n    ( a)\n    ( codomain-eq-ext-is-contr I \u03c8 \u03d5 A a is-contr-fiberwise-A)\n</code></pre> <p>The expression below give us the inhabitant <code>c : (t : \u03c8) \u2192 f t = a' t</code> used in the proof of RS Proposition 4.11. It follows from a more general statement about the contractibility of identity types, but it is unclear if that generality is needed.</p> <pre><code>#define RS-4-11-c\n(htpy-ext-prop : HtpyExtProperty)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( a : (t : \u03d5 ) \u2192 A t)\n( f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n(is-contr-fiberwise-A : (t : \u03c8 ) \u2192 is-contr (A t))\n  : ( t : \u03c8 )\n  \u2192 ( f t\n    = first\n      ( htpy-ext-prop-is-fiberwise-contr\n        htpy-ext-prop\n        I \u03c8 \u03d5 A a\n        is-contr-fiberwise-A)\n      ( t))\n  :=\n\\ t \u2192\n    all-elements-equal-is-contr\n    ( A t)\n    ( is-contr-fiberwise-A t)\n    ( f t )\n    ( ( first\n        ( htpy-ext-prop-is-fiberwise-contr\n          htpy-ext-prop\n          I \u03c8 \u03d5 A a\n          is-contr-fiberwise-A))\n      ( t))\n</code></pre> <p>And below proves that <code>c(t) = refl</code>. Again, this is a consequence of a slightly more general statement.</p> <pre><code>#define RS-4-11-c-is-refl\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-fiberwise-contr : (t : \u03c8 ) \u2192 is-contr (A t))\n( a : (t : \u03d5 ) \u2192 A t)\n( f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n( a' : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n( c : (t : \u03c8 ) \u2192 (f t = a' t))\n  : (t : \u03d5 ) \u2192 (refl =_{f t = a' t} c t)\n  :=  \\ t \u2192\n    all-paths-equal-is-contr\n    (A t) ( is-fiberwise-contr t)\n    ( f t) ( a' t) ( refl ) ( c t )\n</code></pre> <p>Given the <code>a'</code> produced above, the following gives an inhabitant of \\(\\left \\langle_{t : I |\\psi} f(t) = a'(t) \\biggr|^\\phi_{\\lambda t.refl} \\right\\rangle\\)</p> <pre><code>#define is-fiberwise-contr-ext-is-fiberwise-contr\n(htpy-ext-prop : HtpyExtProperty)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-contr-fiberwise-A : (t : \u03c8 ) \u2192 is-contr (A t))\n( a : (t : \u03d5) \u2192 A t)\n( f : (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n  : (t : \u03c8 ) \u2192\n      (f t = (first\n              (htpy-ext-prop-is-fiberwise-contr\n                htpy-ext-prop I \u03c8 \u03d5 A a is-contr-fiberwise-A)) t)[\u03d5 t \u21a6 refl]\n  :=\nfirst(\n    htpy-ext-prop I \u03c8 \u03d5\n    ( \\ t \u2192\n      ( ( f t)\n      = first\n        ( htpy-ext-prop-is-fiberwise-contr\n          htpy-ext-prop\n          I \u03c8 \u03d5 A a\n          is-contr-fiberwise-A)\n        ( t)))\n    ( RS-4-11-c\n      htpy-ext-prop I \u03c8 \u03d5 A a f is-contr-fiberwise-A)\n    ( \\ t \u2192 refl )\n    ( RS-4-11-c-is-refl I \u03c8 \u03d5 A\n      ( is-contr-fiberwise-A)\n      ( a )\n      ( f )\n      ( first\n        ( htpy-ext-prop-is-fiberwise-contr\n          htpy-ext-prop\n          I \u03c8 \u03d5 A a\n          is-contr-fiberwise-A))\n      ( RS-4-11-c\n        ( htpy-ext-prop)\n        ( I) ( \u03c8) ( \u03d5) ( A) ( a) ( f)\n        ( is-contr-fiberwise-A ))))\n</code></pre> RS17, Proposition 4.11<pre><code>#define weak-extext-naiveextext-htpy-ext-property\n( naiveextext : NaiveExtExt)\n( htpy-ext-prop : HtpyExtProperty)\n : WeakExtExt\n  := \\ I \u03c8 \u03d5 A is-contr-fiberwise-A a \u2192\n    (first (htpy-ext-prop-is-fiberwise-contr htpy-ext-prop I \u03c8 \u03d5 A a is-contr-fiberwise-A),\n\\ f \u2192\n      rev\n( (t : \u03c8 ) \u2192 A t [\u03d5 t \u21a6 a t])\n      ( f )\n      ( first (htpy-ext-prop-is-fiberwise-contr\n                htpy-ext-prop I \u03c8 \u03d5 A a is-contr-fiberwise-A))\n      ( naiveextext I \u03c8 \u03d5 A a f\n      ( first (htpy-ext-prop-is-fiberwise-contr\n                htpy-ext-prop I \u03c8 \u03d5 A a is-contr-fiberwise-A))\n      ( is-fiberwise-contr-ext-is-fiberwise-contr\n        ( htpy-ext-prop)\n        ( I) ( \u03c8 ) ( \u03d5 ) ( A)\n        ( is-contr-fiberwise-A)\n        ( a)\n        ( f))))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#applications-of-extension-extensionality","title":"Applications of extension extensionality","text":"<p>We now assume extension extensionality and derive a few consequences.</p> <pre><code>#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#pointwise-homotopy-extension-types","title":"Pointwise homotopy extension types","text":"<p>Using <code>ExtExt</code> we can write the homotopy in the homotopy extension type pointwise.</p> <pre><code>#section pointwise-homotopy-extension-type\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variable A : \u03c8 \u2192 U\n#def pointwise-homotopy-extension-type\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : U\n  :=\n\u03a3 ( \u03c4 : (t : \u03c8) \u2192 A t)\n    , ( (t : \u03d5) \u2192 (\u03c4 t =_{ A t} \u03c3 t))\n#def equiv-pointwise-homotopy-extension-type uses (extext)\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : Equiv\n    ( homotopy-extension-type I \u03c8 \u03d5 A \u03c3)\n    ( pointwise-homotopy-extension-type \u03c3)\n  :=\n    total-equiv-family-of-equiv\n( (t : \u03c8) \u2192 A t)\n    ( \\ \u03c4 \u2192 (\\ t \u2192 \u03c4 t) =_{ (t : \u03d5) \u2192 A t} \u03c3)\n( \\ \u03c4 \u2192 (t : \u03d5) \u2192 (\u03c4 t = \u03c3 t))\n    ( \\ \u03c4 \u2192\n      equiv-ExtExt extext\n      ( I) (\\ t \u2192 \u03d5 t) (\\ _ \u2192 BOT) (\\ t \u2192 A t)\n      ( \\ _ \u2192 recBOT) (\\ t \u2192 \u03c4 t) \u03c3)\n#def extension-type-pointwise-weakening uses (extext)\n( \u03c3 : (t : \u03d5) \u2192 A t)\n  : Equiv\n    ( extension-type I \u03c8 \u03d5 A \u03c3)\n    ( pointwise-homotopy-extension-type \u03c3)\n  := equiv-comp\n    ( extension-type I \u03c8 \u03d5 A \u03c3)\n    ( homotopy-extension-type I \u03c8 \u03d5 A \u03c3)\n    ( pointwise-homotopy-extension-type \u03c3)\n    ( extension-type-weakening I \u03c8 \u03d5 A \u03c3)\n    ( equiv-pointwise-homotopy-extension-type \u03c3)\n#end pointwise-homotopy-extension-type\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#relative-extension-types","title":"Relative extension types","text":"<p>Given a map <code>\u03b1 : A' \u2192 A</code>, there is also a notion of relative extension types.</p> <pre><code>#section relative-extension-types\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variables A' A : \u03c8 \u2192 U\n#variable \u03b1 : (t : \u03c8) \u2192 A' t \u2192 A t\n#variable \u03c3' : (t : \u03d5) \u2192 A' t\n#variable \u03c4 : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (\u03c3' t)]\n#def relative-extension-type\n  : U\n  :=\n\u03a3 ( \u03c4' : (t : \u03c8) \u2192 A' t [\u03d5 t \u21a6 \u03c3' t])\n    , ( ( t : \u03c8) \u2192 (\u03b1 t (\u03c4' t) = \u03c4 t) [\u03d5 t \u21a6 refl])\n#def relative-extension-type'\n  : U\n  :=\n    fib\n( (t : \u03c8) \u2192 A' t [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (\u03c3' t)])\n    ( \\ \u03c4' t \u2192 \u03b1 t (\u03c4' t))\n    ( \u03c4)\n#def equiv-relative-extension-type-fib uses (extext)\n  : Equiv\n    ( relative-extension-type')\n    ( relative-extension-type)\n  :=\n    total-equiv-family-of-equiv\n( (t : \u03c8) \u2192 A' t [\u03d5 t \u21a6 \u03c3' t])\n    ( \\ \u03c4' \u2192 (\\ t \u2192 \u03b1 t (\u03c4' t)) =_{ (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (\u03c3' t)]} \u03c4)\n( \\ \u03c4' \u2192 (t : \u03c8) \u2192 (\u03b1 t (\u03c4' t) = \u03c4 t) [\u03d5 t \u21a6 refl])\n    ( \\ \u03c4' \u2192\n      equiv-ExtExt extext I \u03c8 \u03d5 A\n      ( \\ t \u2192 \u03b1 t (\u03c3' t))\n      ( \\ t \u2192 \u03b1 t (\u03c4' t)) ( \u03c4))\n#end relative-extension-types\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#generalized-relative-extension-types","title":"Generalized relative extension types","text":"<p>We will also need to allow more general relative extension types, where we start with a <code>\u03c4 : \u03c8 \u2192 A</code> that does not strictly restrict to <code>\\ t \u2192 \u03b1 (\u03c3' t)</code>.</p> <pre><code>#section general-extension-types\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variables A' A : \u03c8 \u2192 U\n#variable \u03b1 : (t : \u03c8) \u2192 A' t \u2192 A t\n#def general-relative-extension-type\n( \u03c3' : (t : \u03d5) \u2192 A' t)\n( \u03c4 : (t : \u03c8) \u2192 A t)\n( h : (t : \u03d5) \u2192 \u03b1 t (\u03c3' t) = \u03c4 t)\n  : U\n  :=\n\u03a3 ( \u03c4' : (t : \u03c8) \u2192 A' t [\u03d5 t \u21a6 \u03c3' t])\n    , ( t : \u03c8) \u2192 (\u03b1 t (\u03c4' t) = \u03c4 t) [\u03d5 t \u21a6 h t]\n</code></pre> <p>If all ordinary relative extension types are contractible, then all generalized extension types are also contractible.</p> <pre><code>#def has-contr-relative-extension-types\n  : U\n  :=\n( ( \u03c3' : (t : \u03d5) \u2192 A' t)\n    \u2192 ( \u03c4 : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 \u03b1 t (\u03c3' t)])\n    \u2192 ( is-contr (relative-extension-type I \u03c8 \u03d5 A' A \u03b1 \u03c3' \u03c4)))\n#def has-contr-general-relative-extension-types\n  : U\n  :=\n( ( \u03c3' : (t : \u03d5) \u2192 A' t)\n    \u2192 ( \u03c4 : (t : \u03c8) \u2192 A t)\n    \u2192 ( h : (t : \u03d5) \u2192 \u03b1 t (\u03c3' t) = \u03c4 t)\n    \u2192 ( is-contr ( general-relative-extension-type \u03c3' \u03c4 h)))\n#def has-contr-relative-extension-types-generalize' uses (extext)\n( has-contr-relext-\u03b1 : has-contr-relative-extension-types)\n( \u03c3' : (t : \u03d5) \u2192 A' t)\n( \u03c4 : (t : \u03c8) \u2192 A t)\n( h : (t : \u03d5) \u2192 \u03b1 t (\u03c3' t) = \u03c4 t)\n  : is-contr\n    ( general-relative-extension-type \u03c3' \u03c4\n      ( \\ t \u2192\n        rev (A t) (\u03c4 t) (\u03b1 t (\u03c3' t)) (rev (A t) (\u03b1 t (\u03c3' t)) (\u03c4 t) (h t))))\n  :=\n    ind-has-section-equiv\n    ( extension-type I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t)))\n    ( pointwise-homotopy-extension-type I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t)))\n    ( extension-type-pointwise-weakening I \u03c8 \u03d5 A (\\ t \u2192 \u03b1 t (\u03c3' t)))\n    ( \\ (\u03c4\u0302 , h\u0302) \u2192\n      is-contr\n      ( general-relative-extension-type \u03c3' \u03c4\u0302\n        ( \\ t \u2192 rev (A t) (\u03c4\u0302 t) (\u03b1 t (\u03c3' t)) (h\u0302 t))))\n    ( \\ \u03c4 \u2192 has-contr-relext-\u03b1 \u03c3' \u03c4)\n    ( \u03c4 , \\ t \u2192 (rev (A t) (\u03b1 t (\u03c3' t)) (\u03c4 t) (h t)))\n#def has-contr-relative-extension-types-generalize uses (extext)\n( has-contr-relext-\u03b1 : has-contr-relative-extension-types)\n  : has-contr-general-relative-extension-types\n  :=\n\\ \u03c3' \u03c4 h \u2192\n    transport\n( (t : \u03d5) \u2192 \u03b1 t (\u03c3' t) = \u03c4 t)\n    ( \\ h\u0302 \u2192 is-contr ( general-relative-extension-type \u03c3' \u03c4 h\u0302))\n    ( \\ t \u2192 rev (A t) (\u03c4 t) (\u03b1 t (\u03c3' t)) (rev (A t) (\u03b1 t (\u03c3' t)) (\u03c4 t) (h t)))\n    ( h)\n    ( naiveextext-extext extext\n      ( I) (\\ t \u2192 \u03d5 t) (\\ _ \u2192 BOT) (\\ t \u2192 \u03b1 t (\u03c3' t ) = \u03c4 t) (\\ _ \u2192 recBOT)\n      ( \\ t \u2192 rev (A t) (\u03c4 t) (\u03b1 t (\u03c3' t)) (rev (A t) (\u03b1 t (\u03c3' t)) (\u03c4 t) (h t)))\n      ( h)\n      ( \\ t \u2192 rev-rev (A t) (\u03b1 t (\u03c3' t)) (\u03c4 t) (h t)))\n    ( has-contr-relative-extension-types-generalize'\n         has-contr-relext-\u03b1 \u03c3' \u03c4 h)\n</code></pre> <p>The converse is of course trivial.</p> <pre><code>#def has-contr-relative-extension-types-specialize\n( has-contr-gen-relext-\u03b1 : has-contr-general-relative-extension-types)\n  : has-contr-relative-extension-types\n  := \\ \u03c3' \u03c4 \u2192 has-contr-gen-relext-\u03b1 \u03c3' \u03c4 (\\ _ \u2192 refl)\n#end general-extension-types\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#functoriality-of-extension-types","title":"Functoriality of extension types","text":"<p>We aim to show that special properties of a map of types <code>f : A \u2192 B</code>, such as being an equivalence or having a retraction carry over to the induced map on extension types.</p> <p>For each map <code>f : A \u2192 B</code> and each shape inclusion <code>\u03d5 \u2282 \u03c8</code>, we have a commutative square.</p> <pre><code>(\u03c8 \u2192 A') \u2192 (\u03c8 \u2192 A)\n\n   \u2193          \u2193\n\n(\u03d5 \u2192 A') \u2192 (\u03d5 \u2192 A)\n</code></pre> <p>We can view it as a map of maps either vertically or horizontally.</p> <pre><code>#def map-of-restriction-maps\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( f : (t : \u03c8) \u2192 A t \u2192 B t)\n  : map-of-maps\n( (t : \u03c8) \u2192 A t) ( (t : \u03d5) \u2192 A t)  (\\ a t \u2192 a t)\n( (t : \u03c8) \u2192 B t) ( (t : \u03d5) \u2192 B t)  (\\ b t \u2192 b t)\n  :=\n    ( ( ( \\ a t \u2192 f t (a t))\n      , ( \\ a t \u2192 f t (a t)))\n    , \\ _ \u2192 refl)\n#def map-of-map-extension-type\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( f : (t : \u03c8) \u2192 A t \u2192 B t)\n  : map-of-maps\n( (t : \u03c8) \u2192 A t) ( (t : \u03c8) \u2192 B t) (\\ a t \u2192 f t (a t))\n( (t : \u03d5) \u2192 A t) ( (t : \u03d5) \u2192 B t) (\\ a t \u2192 f t (a t))\n  :=\n    ( ( ( \\ a t \u2192 a t)\n      , ( \\ b t \u2192 b t))\n    , \\ _ \u2192 refl)\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#equivalences-induce-equivalences-of-extension-types","title":"Equivalences induce equivalences of extension types","text":"<p>We start by treating the case of extensions from the empty shape <code>BOT</code>.</p> <p>It follows from extension extensionality that if <code>f : A \u2192 B</code> is an equivalence, then so is the map of maps <code>map-of-restriction-maps</code>.</p> <pre><code>#def is-equiv-extensions-BOT-is-equiv uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( f : (t : \u03c8) \u2192 (A t) \u2192 (B t))\n( is-equiv-f : (t : \u03c8) \u2192 is-equiv (A t) (B t) (f t))\n  : is-equiv ((t : \u03c8) \u2192 A t) ((t : \u03c8) \u2192 B t) ( \\ a t \u2192 f t (a t))\n  :=  ( ( ( \\ b t \u2192 (first (first (is-equiv-f t))) (b t))\n        , ( \\ a \u2192\n            naiveextext-extext extext I \u03c8 ( \\ t \u2192 BOT)\n              ( A)\n              ( \\ u \u2192 recBOT)\n              ( \\ t \u2192 first (first (is-equiv-f t)) (f t (a t)))\n              ( a)\n              ( \\ t \u2192 second (first (is-equiv-f t)) (a t))))\n      , ( ( \\ b t \u2192 first (second (is-equiv-f t)) (b t))\n        , ( \\ b \u2192\n            naiveextext-extext extext I \u03c8 ( \\ t \u2192 BOT)\n              ( B)\n              ( \\ u \u2192 recBOT)\n              ( \\ t \u2192 f t (first (second (is-equiv-f t)) (b t)))\n              ( b)\n              ( \\ t \u2192 second (second (is-equiv-f t)) (b t)))))\n#def equiv-extensions-BOT-equiv uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( famequiv : (t : \u03c8) \u2192 (Equiv (A t) (B t)))\n  : Equiv ((t : \u03c8) \u2192 A t) ((t : \u03c8) \u2192 B t)\n  :=\n    ( ( \\ a t \u2192 first ( famequiv t) (a t))\n    , is-equiv-extensions-BOT-is-equiv I \u03c8 A B\n      ( \\ t \u2192 first (famequiv t))\n      ( \\ t \u2192 second (famequiv t)))\n#def equiv-of-restriction-maps-equiv uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( famequiv : (t : \u03c8) \u2192 (Equiv (A t) (B t)))\n  : Equiv-of-maps\n( (t : \u03c8) \u2192 A t) ( (t : \u03d5) \u2192 A t)  (\\ a t \u2192 a t)\n( (t : \u03c8) \u2192 B t) ( (t : \u03d5) \u2192 B t)  (\\ b t \u2192 b t)\n  :=\n    ( map-of-restriction-maps I \u03c8 \u03d5 A B (\\ t \u2192 first (famequiv t))\n    , ( second (equiv-extensions-BOT-equiv I \u03c8 A B famequiv)\n      , second ( equiv-extensions-BOT-equiv I\n                 (\\ t \u2192 \u03d5 t) (\\ t \u2192 A t) (\\ t \u2192 B t) (\\ t \u2192 famequiv t))))\n</code></pre> <p>Now we use the result for extensions of <code>BOT</code> to bootstrap to arbitrary extensions. We show that an equivalence <code>f : A \u2192 B</code> induces an equivalence of all extension types, not just those extended from <code>BOT</code>.</p> <pre><code>#def is-equiv-extensions-is-equiv uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( f : (t : \u03c8) \u2192 A t \u2192 B t)\n( is-equiv-f : (t : \u03c8) \u2192 is-equiv (A t) (B t) (f t))\n  : ( a : (t : \u03d5) \u2192 A t)\n  \u2192 is-equiv\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 f t (a t)])\n    ( \\ a' t \u2192 f t (a' t))\n  :=\n    is-homotopy-cartesian-is-horizontal-equiv\n( (t : \u03d5) \u2192 A t)\n( \\ a \u2192 (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03d5) \u2192 B t)\n( \\ b \u2192 (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 b t])\n    ( \\ a t \u2192 f t (a t))\n    ( \\ _ a' t \u2192 f t (a' t))\n    ( is-equiv-extensions-BOT-is-equiv\n      ( I) (\\ t \u2192 \u03d5 t) (\\ t \u2192 A t) (\\ t \u2192 B t) ( \\ t \u2192 f t)\n( \\ (t : \u03d5) \u2192 is-equiv-f t))\n( is-equiv-Equiv-is-equiv'\n        ( (t : \u03c8) \u2192 A t) ((t : \u03c8) \u2192 B t) (\\ a' t \u2192 f t (a' t))\n( \u03a3 (a : (t : \u03d5) \u2192 A t) , ((t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]))\n( \u03a3 (b : (t : \u03d5) \u2192 B t) , ((t : \u03c8) \u2192 B t [\u03d5 t \u21a6 b t]))\n        ( \\ (a , a') \u2192 ( \\ t \u2192 f t (a t) , \\ t \u2192 f t (a' t)))\n      ( cofibration-composition-functorial\n        I \u03c8 \u03d5 (\\ _ \u2192 BOT) A B f (\\ _ \u2192 recBOT))\n      ( is-equiv-extensions-BOT-is-equiv I \u03c8 A B f is-equiv-f))\n#def equiv-extensions-equiv uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( equivs-A-B : (t : \u03c8) \u2192 Equiv (A t) (B t))\n( a : (t : \u03d5) \u2192 A t)\n  : Equiv\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 first (equivs-A-B t) (a t)])\n  :=\n  ( ( \\ a' t \u2192 first (equivs-A-B t) (a' t))\n  , ( is-equiv-extensions-is-equiv I \u03c8 \u03d5 A B\n      ( \\ t \u2192 first (equivs-A-B t))\n      ( \\ t \u2192 second (equivs-A-B t))\n      ( a)))\n</code></pre>"},{"location":"simplicial-hott/03-extension-types.rzk/#retracts-induce-retracts-of-extension-types","title":"Retracts induce retracts of extension types","text":"<p>We show that if <code>f : A \u2192 B</code> has a retraction, then the same is true for the induced map on extension types. We reduce this to the case of equivalences by working with external retractions.</p> <pre><code>#section section-retraction-extensions\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variables A B : \u03c8 \u2192 U\n#variable s : (t : \u03c8) \u2192 A t \u2192 B t\n#variable r : (t : \u03c8) \u2192 B t \u2192 A t\n#variable \u03b7 : (t : \u03c8) \u2192 (a : A t) \u2192 r t (s t a) = a\n#def is-sec-rec-extensions-sec-rec uses (extext)\n( a : (t : \u03d5) \u2192 A t)\n  : is-section-retraction-pair\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 s t (a t)])\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 r t(s t(a t))])\n    ( \\ a' t \u2192 s t (a' t))\n    ( \\ b' t \u2192 r t (b' t))\n  :=\n    is-equiv-extensions-is-equiv I \u03c8 \u03d5 A A\n    ( \\ t a\u2080 \u2192 r t (s t (a\u2080)))\n    ( \\ t \u2192 is-equiv-retraction-section (A t) (B t) (s t) (r t) (\u03b7 t))\n    ( a)\n#def has-retraction-extensions-has-retraction' uses (extext \u03b7)\n( a : (t : \u03d5) \u2192 A t)\n  : has-retraction\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 s t (a t)])\n    ( \\ a' t \u2192 s t (a' t))\n  :=\n    has-retraction-internalize\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 s t (a t)])\n    ( \\ a' t \u2192 s t (a' t))\n( ( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 r t (s t (a t))]\n      , \\ b' t \u2192 r t (b' t))\n    , is-sec-rec-extensions-sec-rec a)\n#def has-section-extensions-has-section' uses (extext \u03b7)\n( a : (t : \u03d5) \u2192 A t)\n  : has-section\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 s t (a t)])\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 r t (s t (a t))])\n    ( \\ b t \u2192 r t (b t))\n  :=\n    has-section-internalize\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 s t (a t)])\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 r t (s t (a t))])\n    ( \\ b' t \u2192 r t (b' t))\n( ( ( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n      , ( \\ a' t \u2192 s t (a' t)))\n    , is-sec-rec-extensions-sec-rec a)\n#end section-retraction-extensions\n</code></pre> <p>It is convenient to have uncurried versions.</p> <pre><code>#def has-retraction-extensions-has-retraction uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( s : (t : \u03c8) \u2192 A t \u2192 B t)\n( has-retraction-s : (t : \u03c8) \u2192 has-retraction (A t) (B t) (s t))\n( a : (t : \u03d5) \u2192 A t)\n  : has-retraction\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 s t (a t)])\n    ( \\ a' t \u2192 s t (a' t))\n  :=\n    has-retraction-extensions-has-retraction' I \u03c8 \u03d5 A B s\n    ( \\ t \u2192 first (has-retraction-s t))\n    ( \\ t \u2192 second (has-retraction-s t))\n    ( a)\n#def has-section-extensions-has-section uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( B A : \u03c8 \u2192 U)\n( r : (t : \u03c8) \u2192 B t \u2192 A t)\n( has-section-r : (t : \u03c8) \u2192 has-section (B t) (A t) (r t))\n( a : (t : \u03d5) \u2192 A t)\n  : has-section\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 (first (has-section-r t)) (a t)])\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 r t (first (has-section-r t) (a t))])\n    ( \\ b t \u2192 r t (b t))\n  :=\n    has-section-extensions-has-section' I \u03c8 \u03d5 A B\n    ( \\ t \u2192 first (has-section-r t))\n    ( r)\n    ( \\ t \u2192 second (has-section-r t))\n    ( a)\n</code></pre> <p>We summarize by saying that retracts of types induce retracts of extension types.</p> <pre><code>#def is-retract-of-extensions-are-retract-of uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( are-retract-A-of-B : (t : \u03c8) \u2192 is-retract-of (A t) (B t))\n( a : (t : \u03d5) \u2192 A t)\n  : is-retract-of\n( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n( (t : \u03c8) \u2192 B t [\u03d5 t \u21a6 first (are-retract-A-of-B t) (a t)])\n  :=\n  ( ( \\ a' t \u2192 first (are-retract-A-of-B t) (a' t))\n  , ( has-retraction-extensions-has-retraction I \u03c8 \u03d5 A B\n      ( \\ t \u2192 first (are-retract-A-of-B t))\n      ( \\ t \u2192 second (are-retract-A-of-B t))\n      ( a)))\n</code></pre> <p>The following special case of extensions from <code>BOT</code> is also useful.</p> <pre><code>#def has-section-extensions-BOT-has-section uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( A B : \u03c8 \u2192 U)\n( f : ( t : \u03c8) \u2192 A t \u2192 B t)\n( has-section-f : (t : \u03c8) \u2192 has-section (A t) (B t) (f t))\n  : has-section ((t : \u03c8) \u2192 A t) ((t : \u03c8) \u2192 B t) ( \\ a t \u2192 f t (a t))\n  :=\n    ( ( \\ b t \u2192 first (has-section-f t) (b t))\n    , \\ b \u2192\n      ( naiveextext-extext extext I \u03c8 (\\ _ \u2192 BOT) B (\\ _ \u2192 recBOT)\n        ( \\ t \u2192 f t (first (has-section-f t) (b t)))\n        ( \\ t \u2192 b t)\n        ( \\ t \u2192 second (has-section-f t) (b t))))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/","title":"4a. Right orthogonal fibrations","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#prerequisites","title":"Prerequisites","text":"<p>Some of the definitions in this file rely on extension extensionality or function extensionality:</p> <pre><code>#assume extext : ExtExt\n#assume funext : FunExt\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#right-orthogonal-maps-with-respect-to-shapes","title":"Right orthogonal maps with respect to shapes","text":"<p>For every shape inclusion <code>\u03d5 \u2282 \u03c8</code>, we obtain a fibrancy condition for a map <code>\u03b1 : A' \u2192 A</code> in terms of unique extension along <code>\u03d5 \u2282 \u03c8</code>. This is a relative version of unique extension along <code>\u03d5 \u2282 \u03c8</code>.</p> <p>We say that <code>\u03b1 : A' \u2192 A</code> is right orthogonal to the shape inclusion <code>\u03d5 \u2282 \u03c8</code>, if the square</p> <pre><code>(\u03c8 \u2192 A') \u2192 (\u03c8 \u2192 A)\n\n   \u2193          \u2193\n\n(\u03d5 \u2192 A') \u2192 (\u03d5 \u2192 A)\n</code></pre> <p>is homotopy cartesian.</p> <p>Equivalently, we can interpret this orthogonality as a cofibrancy condition on the shape inclusion. We say that the shape inclusion <code>\u03d5 \u2282 \u03c8</code> is left orthogonal to the map <code>\u03b1</code>, if <code>\u03b1 : A' \u2192 A</code> is right orthogonal to <code>\u03d5 \u2282 \u03c8</code>.</p> BW23, Section 3<pre><code>#def is-right-orthogonal-to-shape\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n  : U\n  :=\n    is-homotopy-cartesian\n      ( \u03d5 \u2192 A' ) ( \\ \u03c3' \u2192 (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n      ( \u03d5 \u2192 A ) ( \\ \u03c3 \u2192 (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n      ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t)) ( \\ _ \u03c4' x \u2192 \u03b1 (\u03c4' x) )\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#contractible-relative-extension-types","title":"Contractible relative extension types","text":"<p>Using <code>ExtExt</code>, we can characterize right orthogonal maps in terms of the contractibility of relative extension types or, equivalently, generalized extension types.</p> <pre><code>#section has-contr-relative-extension-types-iff-is-right-orthogonal\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variables A' A : U\n#variable \u03b1 : A' \u2192 A\n#def is-right-orthogonal-to-shape-has-contr-relative-extension-types uses (extext)\n( are-contr-relext-\u03b1\n    : has-contr-relative-extension-types I \u03c8 \u03d5\n      ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1))\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n\\ \u03c3' \u2192\n    is-equiv-is-contr-map\n( (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n    ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n( \\ \u03c4 \u2192\n      is-contr-equiv-is-contr'\n      ( fib\n        ( (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n        ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n        ( \u03c4))\n      ( relative-extension-type I \u03c8 \u03d5\n        ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1) \u03c3' \u03c4)\n      ( equiv-relative-extension-type-fib extext I \u03c8 \u03d5\n        ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1) \u03c3' \u03c4)\n      ( are-contr-relext-\u03b1 \u03c3' \u03c4))\n#def has-contr-relative-extension-types-is-right-orthogonal-to-shape uses (extext)\n( is-orth-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : has-contr-relative-extension-types I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n  :=\n\\ \u03c3' \u03c4 \u2192\n      is-contr-equiv-is-contr\n( fib\n        ( (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n        ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n        ( \u03c4))\n      ( relative-extension-type I \u03c8 \u03d5\n        ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1) \u03c3' \u03c4)\n      ( equiv-relative-extension-type-fib extext I \u03c8 \u03d5\n        ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1) \u03c3' \u03c4)\n( is-contr-map-is-equiv\n        ( (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n        ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n        ( is-orth-\u03b1 \u03c3')\n        ( \u03c4))\n#def has-contr-general-relative-extension-types-is-right-orthogonal-to-shape\nuses (extext)\n( is-orth-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : has-contr-general-relative-extension-types I \u03c8 \u03d5\n      ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n  :=\n    has-contr-relative-extension-types-generalize extext I \u03c8 \u03d5\n      ( \\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n      ( has-contr-relative-extension-types-is-right-orthogonal-to-shape is-orth-\u03b1)\n#end has-contr-relative-extension-types-iff-is-right-orthogonal\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#stability-properties-of-left-orthogonal-shape-inclusions","title":"Stability properties of left orthogonal shape inclusions","text":"<p>We fix a map <code>\u03b1 : A' \u2192 A</code>.</p> <pre><code>#section left-orthogonal-calculus-1\n#variables A' A : U\n#variable \u03b1 : A' \u2192 A\n</code></pre> <p>Consider nested shapes <code>\u03d5 \u2282 \u03c7 \u2282 \u03c8</code> and the three possible right orthogonality conditions.</p> <pre><code>#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03c7 : \u03c8 \u2192 TOPE\n#variable \u03d5 : \u03c7 \u2192 TOPE\n#variable is-orth-\u03c8-\u03c7 : is-right-orthogonal-to-shape I \u03c8 \u03c7 A' A \u03b1\n#variable is-orth-\u03c7-\u03d5 : is-right-orthogonal-to-shape\n                          I ( \\ t \u2192 \u03c7 t) ( \\ t \u2192 \u03d5 t) A' A \u03b1\n#variable is-orth-\u03c8-\u03d5 : is-right-orthogonal-to-shape I \u03c8 ( \\ t \u2192 \u03d5 t) A' A \u03b1\n</code></pre> <p>Using the vertical pasting calculus for homotopy cartesian squares, it is not hard to deduce the corresponding composition and cancellation properties for left orthogonality of shape inclusion with respect to <code>\u03b1 : A' \u2192 A</code>.</p>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#over-an-intermediate-shape","title":"\u03a3 over an intermediate shape","text":"<p>The only fact that stops some of these laws from being a direct corollary is that the <code>\u03a3</code>-types appearing in the vertical pasting of the relevant squares (such as <code>\u03a3 (\\ \u03c3 : \u03d5 \u2192 A), ( (t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03c3 t])</code>) are not literally equal to the corresponding extension types (such as <code>\u03c7 \u2192 A</code>). Therefore we have to occasionally go back or forth along the functorial equivalence <code>cofibration-composition-functorial</code>.</p> <pre><code>#def is-homotopy-cartesian-\u03a3-is-right-orthogonal-to-shape uses (is-orth-\u03c8-\u03d5)\n  : is-homotopy-cartesian\n    ( \u03d5 \u2192 A')\n( \\ \u03c3' \u2192\n      \u03a3 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n      , ( t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t])\n    ( \u03d5 \u2192 A)\n( \\ \u03c3 \u2192\n      \u03a3 ( \u03c4 : (t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n      , ( t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t])\n    ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n    ( \\ _ (\u03c4', \u03c5') \u2192 ( \\ t \u2192 \u03b1 (\u03c4' t), \\ t \u2192 \u03b1 (\u03c5' t) ))\n  :=\n( \\ (\u03c3' : \u03d5 \u2192 A') \u2192\n    is-equiv-Equiv-is-equiv'\n( ( t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( ( t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n      ( \\ \u03c5' t \u2192 \u03b1 ( \u03c5' t))\n( \u03a3 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n        , ( ( t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t]))\n( \u03a3 ( \u03c4 : ( t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n        , ( ( t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t]))\n      ( \\ (\u03c4', \u03c5') \u2192 ( \\ t \u2192 \u03b1 (\u03c4' t), \\t \u2192 \u03b1 (\u03c5' t)))\n      ( cofibration-composition-functorial I \u03c8 \u03c7 \u03d5\n        ( \\ _ \u2192 A') ( \\ _ \u2192 A) ( \\ _ \u2192 \u03b1) \u03c3')\n      ( is-orth-\u03c8-\u03d5 \u03c3'))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#composition","title":"Composition","text":"<p>Left orthogonal shape inclusions are preserved under composition.</p> right-orthogonality for composition of shape inclusions<pre><code>#def is-right-orthogonal-to-shape-comp uses (is-orth-\u03c8-\u03c7 is-orth-\u03c7-\u03d5)\n  : is-right-orthogonal-to-shape I \u03c8 ( \\ t \u2192 \u03d5 t) A' A \u03b1\n  :=\n\\ \u03c3' \u2192\n      is-equiv-Equiv-is-equiv\n( ( t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( ( t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n        ( \\ \u03c5' t \u2192 \u03b1 ( \u03c5' t))\n( \u03a3 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n          , ( ( t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t]))\n( \u03a3 ( \u03c4 : ( t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n          , ( ( t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t]))\n        ( \\ (\u03c4', \u03c5') \u2192 ( \\ t \u2192 \u03b1 (\u03c4' t), \\t \u2192 \u03b1 (\u03c5' t)))\n        ( cofibration-composition-functorial I \u03c8 \u03c7 \u03d5\n          ( \\ _ \u2192 A') ( \\ _ \u2192 A) ( \\ _ \u2192 \u03b1) \u03c3')\n        ( is-homotopy-cartesian-vertical-pasting-from-fibers\n          ( \u03d5 \u2192 A' )\n( \\ \u03c3' \u2192 (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( \\ _ \u03c4' \u2192 (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t])\n          ( \u03d5 \u2192 A )\n( \\ \u03c3 \u2192 (t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n( \\ _ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t])\n          ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n          ( \\ _ \u03c4' x \u2192 \u03b1 (\u03c4' x) )\n          ( \\ _ _ \u03c5' x \u2192 \u03b1 (\u03c5' x) )\n          is-orth-\u03c7-\u03d5\n          ( \\ _ \u03c4' \u2192 is-orth-\u03c8-\u03c7 \u03c4')\n          \u03c3')\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#cancellation","title":"Cancellation","text":"<p>If <code>\u03d5 \u2282 \u03c7</code> and <code>\u03d5 \u2282 \u03c8</code> are left orthogonal to <code>\u03b1 : A' \u2192 A</code>, then so is <code>\u03c7 \u2282 \u03c8</code>.</p> <pre><code>#def is-right-orthogonal-to-shape-left-cancel uses (is-orth-\u03c7-\u03d5 is-orth-\u03c8-\u03d5)\n  : is-right-orthogonal-to-shape I \u03c8 \u03c7 A' A \u03b1\n  :=\n\\ \u03c4' \u2192\n        is-homotopy-cartesian-lower-cancel-to-fibers\n          ( \u03d5 \u2192 A' )\n( \\ \u03c3' \u2192 (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( \\ _ \u03c4' \u2192 (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t])\n          ( \u03d5 \u2192 A )\n( \\ \u03c3 \u2192 (t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n( \\ _ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t])\n          ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n          ( \\ _ \u03c4' x \u2192 \u03b1 (\u03c4' x) )\n          ( \\ _ _ \u03c5' x \u2192 \u03b1 (\u03c5' x) )\n          ( is-orth-\u03c7-\u03d5 )\n          (is-homotopy-cartesian-\u03a3-is-right-orthogonal-to-shape)\n( \\ ( t : \u03d5) \u2192 \u03c4' t)\n          ( \u03c4')\n</code></pre> <p>If <code>\u03d5 \u2282 \u03c8</code> is left orthogonal to <code>\u03b1 : A' \u2192 A</code> and <code>\u03c7 \u2282 \u03c8</code> is a (functorial) shape retract, then <code>\u03d5 \u2282 \u03c8</code> is left orthogonal to <code>\u03b1 : A' \u2192 A</code>.</p> <pre><code>#def is-right-orthogonal-to-shape-right-cancel-retract uses (is-orth-\u03c8-\u03d5)\n( is-fretract-\u03c8-\u03c7 : is-functorial-shape-retract I \u03c8 \u03c7)\n  : is-right-orthogonal-to-shape I ( \\ t \u2192 \u03c7 t) ( \\ t \u2192 \u03d5 t) A' A \u03b1\n  :=\n    is-homotopy-cartesian-upper-cancel-with-section\n      ( \u03d5 \u2192 A' )\n( \\ \u03c3' \u2192 (t : \u03c7) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( \\ _ \u03c4' \u2192 (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t])\n      ( \u03d5 \u2192 A )\n( \\ \u03c3 \u2192 (t : \u03c7) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n( \\ _ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t])\n      ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n      ( \\ _ \u03c4' x \u2192 \u03b1 (\u03c4' x) )\n      ( \\ _ _ \u03c5' x \u2192 \u03b1 (\u03c5' x) )\n      ( relativize-is-functorial-shape-retract I \u03c8 \u03c7 is-fretract-\u03c8-\u03c7 \u03d5 A' A \u03b1)\n      ( is-homotopy-cartesian-\u03a3-is-right-orthogonal-to-shape)\n#end left-orthogonal-calculus-1\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#transposition","title":"Transposition","text":"<p>Inside a product of cube <code>I \u00d7 J</code>, we can interchange the two factors without affecting left orthogonality.</p> <pre><code>#def is-right-orthogonal-to-shape-transpose\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I J : CUBE)\n( \u03c8 : (I \u00d7 J) \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( is-orth-\u03c8-\u03d5 : is-right-orthogonal-to-shape (I \u00d7 J)\n    ( \\ (s , t) \u2192 \u03c8 (s , t))\n    ( \\ (s , t) \u2192 \u03d5 (s , t))\n    ( A') ( A) ( \u03b1))\n  : is-right-orthogonal-to-shape (J \u00d7 I)\n    ( \\ (t , s) \u2192 \u03c8 (s , t))\n    ( \\ (t , s) \u2192 \u03d5 (s , t))\n    ( A') (A) (\u03b1)\n  :=\n\\ \u03c3' \u2192\n    is-equiv-Equiv-is-equiv\n    ( ( (t , s) : J \u00d7 I | \u03c8 (s , t)) \u2192 A' [\u03d5 (s , t) \u21a6 \u03c3' (t , s)])\n    ( ( (t , s) : J \u00d7 I | \u03c8 (s , t)) \u2192 A [\u03d5 (s , t) \u21a6 \u03b1 (\u03c3' (t , s))])\n    ( \\ \u03c4' ts \u2192 \u03b1 (\u03c4' ts))\n    ( ((s , t) : I \u00d7 J | \u03c8 (s , t)) \u2192 A' [\u03d5 (s , t) \u21a6 \u03c3' (t , s)])\n    ( ((s , t) : I \u00d7 J | \u03c8 (s , t)) \u2192 A [\u03d5 (s , t) \u21a6 \u03b1 (\u03c3' (t , s))])\n    ( \\ \u03c4' st \u2192 \u03b1 (\u03c4' st))\n    ( ( ( ( \\ v (x , y) \u2192 v (y , x))\n        , ( \\ v (x , y) \u2192 v (y , x))\n        )\n      , ( \\ _ \u2192 refl)\n      )\n    , ( ( ( ( \\ v (x , y) \u2192 v (y , x)) , ( \\ _ \u2192 refl))\n        , ( ( \\ v (x , y) \u2192 v (y , x)) , ( \\ _ \u2192 refl)))\n      , ( ( ( \\ v (x , y) \u2192 v (y , x)) , ( \\ _ \u2192 refl))\n        , ( ( \\ v (x , y) \u2192 v (y , x)) , ( \\ _ \u2192 refl)))))\n    ( is-orth-\u03c8-\u03d5 (\\ (s , t) \u2192 \u03c3' (t , s)))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#tensoring","title":"Tensoring","text":"<p>If <code>\u03d5 \u2282 \u03c8</code> is left orthogonal to <code>\u03b1 : A' \u2192 A</code> then so is <code>\u03c7 \u00d7 \u03d5 \u2282 \u03c7 \u00d7 \u03c8</code> for every other shape <code>\u03c7</code>.</p> <p>The following proof uses a lot of currying and uncurrying and relies extension extensionality.</p> <pre><code>#def is-right-orthogonal-to-shape-product uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( is-orth-\u03c8-\u03d5 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : is-right-orthogonal-to-shape\n      ( J \u00d7 I) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03d5 s) A' A \u03b1\n  :=\n    \\ ( \u03c3' : ( (t , s) : J \u00d7 I | \u03c7 t \u2227 \u03d5 s) \u2192 A') \u2192\n( ( \\ ( \u03c4 : ( (t , s) : J \u00d7 I | \u03c7 t \u2227 \u03c8 s) \u2192 A[\u03d5 s \u21a6 \u03b1 (\u03c3' (t , s))])\n            ( t, s) \u2192\n          ( first (first (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s'))))) ( \\ s' \u2192 \u03c4 (t, s')) s\n        , \\ ( \u03c4' : ( (t , s) : J \u00d7 I | \u03c7 t \u2227 \u03c8 s) \u2192 A' [\u03d5 s \u21a6 \u03c3' (t , s)]) \u2192\n            naiveextext-extext extext\n              ( J \u00d7 I) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03d5 s)\n              ( \\ _ \u2192 A')\n              ( \\ ( t,s) \u2192 \u03c3' (t , s))\n              ( \\ ( t,s) \u2192\n                ( first (first (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s')))))\n                  ( \\ s' \u2192 \u03b1 (\u03c4' (t, s'))) s)\n              ( \u03c4')\n              ( \\ ( t,s) \u2192\n                ext-htpy-eq I \u03c8 \u03d5 (\\ _ \u2192 A') ( \\ s' \u2192 \u03c3' (t, s'))\n                  ( ( first (first (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s')))))\n                    ( \\ s' \u2192 \u03b1 (\u03c4' (t, s'))))\n                  ( \\ s' \u2192 \u03c4' (t, s') )\n                  ( ( second (first (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s')))))\n                    ( \\ s' \u2192 \u03c4' (t, s')))\n                  ( s)))\n      , ( \\ ( \u03c4 : ( (t , s) : J \u00d7 I | \u03c7 t \u2227 \u03c8 s) \u2192 A [\u03d5 s \u21a6 \u03b1 (\u03c3' (t , s))])\n            ( t, s) \u2192\n          ( first (second (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s'))))) ( \\ s' \u2192 \u03c4 (t, s')) s\n        , \\ ( \u03c4 : ( (t , s) : J \u00d7 I | \u03c7 t \u2227 \u03c8 s) \u2192 A [\u03d5 s \u21a6 \u03b1 (\u03c3' (t , s))]) \u2192\n            naiveextext-extext extext\n              ( J \u00d7 I) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03d5 s)\n              ( \\ _ \u2192 A)\n              ( \\ (t , s) \u2192 \u03b1 (\u03c3' (t , s)))\n              ( \\ (t , s) \u2192\n                \u03b1 ( ( first ( second ( is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s')))))\n                      ( \\ s' \u2192 \u03c4 (t, s')) s))\n              ( \u03c4)\n              ( \\ ( t,s) \u2192\n                ext-htpy-eq I \u03c8 \u03d5 (\\ _ \u2192 A) ( \\ s' \u2192 \u03b1 (\u03c3' (t, s')))\n                  ( \\ s'' \u2192\n                      \u03b1 ( ( first (second (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s')))))\n                          ( \\ s' \u2192 \u03c4 (t, s'))\n                          ( s'')))\n                  ( \\ s' \u2192 \u03c4 (t, s') )\n                  ( ( second ( second (is-orth-\u03c8-\u03d5 (\\ s' \u2192 \u03c3' (t, s')))))\n                    ( \\ s' \u2192 \u03c4 (t, s')))\n                  ( s))))\n#def is-right-orthogonal-to-shape-product' uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( is-orth-\u03c8-\u03d5 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : is-right-orthogonal-to-shape\n      ( I \u00d7 J) ( \\ (s , t) \u2192 \u03c8 s \u2227 \u03c7 t) ( \\ (s , t) \u2192 \u03d5 s \u2227 \u03c7 t) A' A \u03b1\n  :=\n    is-right-orthogonal-to-shape-transpose A' A \u03b1 J I\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s)\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03d5 s)\n    ( is-right-orthogonal-to-shape-product A' A \u03b1 J \u03c7 I \u03c8 \u03d5 is-orth-\u03c8-\u03d5)\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#exact-pushouts","title":"Exact pushouts","text":"<p>For any two shapes <code>\u03d5, \u03c8 \u2282 I</code>, if <code>\u03d5 \u2229 \u03c8 \u2282 \u03d5</code> is left orthogonal to <code>\u03b1 : A' \u2192 A</code>, then so is <code>\u03c8 \u2282 \u03d5 \u222a \u03c8</code>.</p> <pre><code>#def is-right-orthogonal-to-shape-pushout\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I : CUBE)\n( \u03d5 \u03c8 : I \u2192 TOPE)\n( is-orth-\u03d5-\u03c8\u2227\u03d5 : is-right-orthogonal-to-shape I \u03d5 ( \\ t \u2192 \u03d5 t \u2227 \u03c8 t) A' A \u03b1)\n  : is-right-orthogonal-to-shape I ( \\ t \u2192 \u03d5 t \u2228 \u03c8 t) ( \\ t \u2192 \u03c8 t) A' A \u03b1\n  := \\ ( \u03c4' : \u03c8 \u2192 A') \u2192\n       is-equiv-Equiv-is-equiv\n( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 A' [\u03c8 t \u21a6 \u03c4' t])\n( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 A [\u03c8 t \u21a6 \u03b1 (\u03c4' t)])\n         ( \\ \u03c5' t \u2192 \u03b1 (\u03c5' t))\n( (t : \u03d5) \u2192 A' [\u03d5 t \u2227 \u03c8 t \u21a6 \u03c4' t])\n( (t : \u03d5) \u2192 A [\u03d5 t \u2227 \u03c8 t \u21a6 \u03b1 (\u03c4' t)])\n         ( \\ \u03bd' t \u2192 \u03b1 (\u03bd' t))\n         ( cofibration-union-functorial I \u03d5 \u03c8 (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1) \u03c4')\n         ( is-orth-\u03d5-\u03c8\u2227\u03d5 ( \\ t \u2192 \u03c4' t))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#pushout-products","title":"Pushout products","text":"<p>Combining the stability under pushouts and crossing with a shape, we get stability under pushout products.</p> <pre><code>#def is-right-orthogonal-to-shape-pushout-product uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( is-orth-\u03c8-\u03d5 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : is-right-orthogonal-to-shape (J \u00d7 I)\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s)\n    ( \\ (t , s) \u2192 (\u03b6 t \u2227 \u03c8 s) \u2228 (\u03c7 t \u2227 \u03d5 s))\n    ( A') ( A) ( \u03b1)\n  :=\n    is-right-orthogonal-to-shape-left-cancel A' A \u03b1 (J \u00d7 I)\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s)\n    ( \\ (t , s) \u2192 (\u03b6 t \u2227 \u03c8 s) \u2228 (\u03c7 t \u2227 \u03d5 s))\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03d5 s)\n    ( is-right-orthogonal-to-shape-pushout A' A \u03b1 (J \u00d7 I)\n      ( \\ (t , s) \u2192 \u03b6 t \u2227 \u03c8 s)\n      ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03d5 s)\n      ( is-right-orthogonal-to-shape-product A' A \u03b1 J ( \\ t \u2192 \u03b6 t) I \u03c8 \u03d5\n        (is-orth-\u03c8-\u03d5)))\n    ( is-right-orthogonal-to-shape-product A' A \u03b1 J \u03c7 I \u03c8 \u03d5\n      ( is-orth-\u03c8-\u03d5))\n#def is-right-orthogonal-to-shape-pushout-product' uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n( is-orth-\u03c8-\u03d5 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : is-right-orthogonal-to-shape (I \u00d7 J)\n    ( \\ (s , t) \u2192 \u03c8 s \u2227 \u03c7 t)\n    ( \\ (s , t) \u2192 (\u03d5 s \u2227 \u03c7 t) \u2228 (\u03c8 s \u2227 \u03b6 t))\n    ( A') ( A) ( \u03b1)\n  :=\n    is-right-orthogonal-to-shape-transpose A' A \u03b1 J I\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s)\n    ( \\ (t , s) \u2192 (\u03b6 t \u2227 \u03c8 s) \u2228 (\u03c7 t \u2227 \u03d5 s))\n    ( is-right-orthogonal-to-shape-pushout-product A' A \u03b1 J \u03c7 \u03b6 I \u03c8 \u03d5\n      ( is-orth-\u03c8-\u03d5))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#functorial-isomorphisms","title":"Functorial isomorphisms","text":"<p>If two pairs of shape inclusions <code>\u03d5 \u2282 \u03c8</code> and <code>\u03b6 \u2282 \u03c7</code> are (functorially) isomorphic, then <code>\u03d5 \u2282 \u03c8</code> is left orthogonal if and only if <code>\u03b6 \u2282 \u03c7</code> is left orthogonal.</p> <pre><code>#def is-right-orthogonal-to-shape-isomorphism'\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  ( ((f , F) , (e , E)) : functorial-isomorphism-shape-inclusions I \u03c8 \u03d5 J \u03c7 \u03b6)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  \u2192  is-right-orthogonal-to-shape J \u03c7 \u03b6 A' A \u03b1\n  :=\n  is-homotopy-cartesian-in-cube\n  ( \u03b6 \u2192 A') (\\ \u03c3' \u2192 (t : \u03c7) \u2192 A' [\u03b6 t \u21a6 \u03c3' t])\n  ( \u03b6 \u2192 A) (\\ \u03c3' \u2192 (t : \u03c7) \u2192 A [\u03b6 t \u21a6 \u03c3' t])\n  ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n  ( \\ _ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n  ( \u03d5 \u2192 A') (\\ \u03c3' \u2192 (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n  ( \u03d5 \u2192 A) (\\ \u03c3' \u2192 (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3' t])\n  ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n  ( \\ _ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n  ( first (f A')) ( first (f A))\n  ( e A' A \u03b1)\n  ( \\ \u03c3' \u2192 first (F A' \u03c3')) (\\ \u03c3 \u2192 first (F A \u03c3))\n  ( E A' A \u03b1)\n  ( \\ \u03c3' \u2192 second (F A' \u03c3')) (\\ \u03c3 \u2192 second (F A \u03c3))\n#def is-right-orthogonal-to-shape-isomorphism\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  ( ((f , F) , (e , E)) : functorial-isomorphism-shape-inclusions I \u03c8 \u03d5 J \u03c7 \u03b6)\n  : is-right-orthogonal-to-shape J \u03c7 \u03b6 A' A \u03b1\n  \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n  is-homotopy-cartesian-in-cube'\n  ( \u03b6 \u2192 A') (\\ \u03c3' \u2192 (t : \u03c7) \u2192 A' [\u03b6 t \u21a6 \u03c3' t])\n  ( \u03b6 \u2192 A) (\\ \u03c3' \u2192 (t : \u03c7) \u2192 A [\u03b6 t \u21a6 \u03c3' t])\n  ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n  ( \\ _ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n  ( \u03d5 \u2192 A') (\\ \u03c3' \u2192 (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n  ( \u03d5 \u2192 A) (\\ \u03c3' \u2192 (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3' t])\n  ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n  ( \\ _ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n  ( first (f A')) ( first (f A))\n  ( e A' A \u03b1)\n  ( \\ \u03c3' \u2192 first (F A' \u03c3')) (\\ \u03c3 \u2192 first (F A \u03c3))\n  ( E A' A \u03b1)\n  ( \\ \u03c3' \u2192 second (F A' \u03c3')) (\\ \u03c3 \u2192 second (F A \u03c3))\n  ( second (second (f A')))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#functorial-retracts","title":"Functorial retracts","text":"<p>If <code>\u03d5 \u2282 \u03c8</code> is a left orthogonal shape inclusion and <code>\u03b6 \u2282 \u03c7</code> is a (functorial) retract of it, then <code>\u03b6 \u2282 \u03c7</code> is also left orthogonal.</p> <pre><code>#def is-right-orthogonal-to-shape-retract\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 \u03c7 : \u03c8 \u2192 TOPE)\n-- \u03b6 := \u03c7 \u2227 \u03d5\n  ( ((s , S) , (h , H)) : functorial-retract-shape-inclusion I \u03c8 \u03d5 \u03c7)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  \u2192 is-right-orthogonal-to-shape I (\\ t \u2192 \u03c7 t) (\\ t \u2192 \u03c7 t \u2227 \u03d5 t) A' A \u03b1\n  :=\n\\ is-orth-\u03c8-\u03d5 (\u03c3' : (t : I | \u03c7 t \u2227 \u03d5 t) \u2192 A') \u2192\n    push-down-equiv-with-section\n( (t : \u03c7) \u2192 A' [\u03c7 t \u2227 \u03d5 t \u21a6 \u03c3' t])\n( \\ \u03c4' \u2192 (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t , \u03d5 t \u21a6 s A' \u03c3' t])\n( (t : \u03c7) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n( \\ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 s A (\\ t' \u2192 \u03b1 (\u03c3' t')) t])\n    ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n( \\ \u03c4' \u03c5 \u2192\n      ( transport\n        ( (t : \u03d5) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n( \\ \u03c3 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03b1 (\u03c4' t) , \u03d5 t \u21a6 \u03c3 t])\n        ( \\ t \u2192 \u03b1 (s A' \u03c3' t))\n        ( s A ( \\ t \u2192 \u03b1 (\u03c3' t)))\n        ( h A' A \u03b1 \u03c3')\n        ( \\ t \u2192 \u03b1 ( \u03c5 t))))\n    ( ( S A' \u03c3' , S A (\\ t \u2192 \u03b1 (\u03c3' t)))\n    , H A' A \u03b1 \u03c3')\n( second\n      ( equiv-comp\n      ( \u03a3 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03c7 t \u2227 \u03d5 t \u21a6 \u03c3' t])\n      , (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t , \u03d5 t \u21a6 s A' \u03c3' t])\n( \u03a3 ( \u03c4 : (t : \u03c7) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n          , (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 \u03b1 (s A' \u03c3' t)])\n( \u03a3 ( \u03c4 : (t : \u03c7) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n          , (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 s A (\\ t' \u2192 \u03b1 (\u03c3' t')) t])\n        ( ( \\ (\u03c4' , \u03c5') \u2192\n            ( (\\ t \u2192 \u03b1 (\u03c4' t))\n            , (\\ t \u2192 \u03b1 (\u03c5' t))))\n        , ( is-equiv-Equiv-is-equiv'\n            ( (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 s A' \u03c3' t])\n( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (s A' \u03c3' t)])\n            ( \\ \u03c5' t \u2192 \u03b1 (\u03c5' t))\n( \u03a3 ( \u03c4' : (t : \u03c7) \u2192 A' [\u03c7 t \u2227 \u03d5 t \u21a6 \u03c3' t])\n              , (t : \u03c8) \u2192 A' [\u03c7 t \u21a6 \u03c4' t , \u03d5 t \u21a6 s A' \u03c3' t])\n( \u03a3 ( \u03c4 : (t : \u03c7) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n              , (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 \u03b1 (s A' \u03c3' t)])\n              ( \\ (\u03c4' , \u03c5') \u2192 ( (\\ t \u2192 \u03b1 (\u03c4' t)) , (\\ t \u2192 \u03b1 (\u03c5' t))))\n              ( cofibration-composition-functorial'' I \u03c8 \u03d5 \u03c7\n                (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1) (s A' \u03c3'))\n            ( is-orth-\u03c8-\u03d5 (s A' \u03c3'))))\n( total-equiv-family-of-equiv\n          ( (t : \u03c7) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n( \\ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 \u03b1 (s A' \u03c3' t)])\n( \\ \u03c4 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 s A (\\ t' \u2192 \u03b1 (\u03c3' t')) t])\n( \\ \u03c4 \u2192\n            equiv-transport\n            ( (t : \u03d5) \u2192 A [\u03c7 t \u2227 \u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n( \\ \u03c3 \u2192 (t : \u03c8) \u2192 A [\u03c7 t \u21a6 \u03c4 t , \u03d5 t \u21a6 \u03c3 t])\n            ( \\ t \u2192 \u03b1 (s A' \u03c3' t))\n            ( s A (\\ t \u2192 \u03b1 (\u03c3' t)))\n            ( h A' A \u03b1 \u03c3')))))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#stability-properties-of-right-orthogonal-maps","title":"Stability properties of right orthogonal maps","text":"<p>Now we change perspective. We fix a shape inclusion <code>\u03d5 \u2282 \u03c8</code> and investigate stability properties of maps right orthogonal to it.</p> <pre><code>#section right-orthogonal-calculus\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#equivalences-are-right-orthogonal","title":"Equivalences are right orthogonal","text":"<p>Every equivalence <code>\u03b1 : A' \u2192 A</code> is right orthogonal to <code>\u03d5 \u2282 \u03c8</code>.</p> <pre><code>#def is-right-orthogonal-is-equiv-to-shape uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( is-equiv-\u03b1 : is-equiv A' A \u03b1)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n    is-equiv-extensions-is-equiv extext I \u03c8 \u03d5\n    ( \\ _ \u2192 A') ( \\  _ \u2192 A) ( \\ _ \u2192 \u03b1) ( \\ _ \u2192 is-equiv-\u03b1)\n</code></pre> <p>Right orthogonality is closed under homotopy.</p> <pre><code>#def is-right-orthogonal-homotopy-to-shape uses (funext)\n( A' A : U)\n( \u03b1 \u03b2 : A' \u2192 A)\n( h : homotopy A' A \u03b1 \u03b2)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b2\n  :=\n    transport (A' \u2192 A) ( is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A) \u03b1 \u03b2\n    ( first (first (funext A' (\\ _ \u2192 A) \u03b1 \u03b2)) h)\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#composition_1","title":"Composition","text":"<pre><code>#variables A'' A' A : U\n#variable \u03b1' : A'' \u2192 A'\n#variable \u03b1 : A' \u2192 A\n#variable is-orth-\u03c8-\u03d5-\u03b1' : is-right-orthogonal-to-shape I \u03c8 \u03d5 A'' A' \u03b1'\n#variable is-orth-\u03c8-\u03d5-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n#variable is-orth-\u03c8-\u03d5-\u03b1\u03b1' : is-right-orthogonal-to-shape I \u03c8 \u03d5 A'' A\n                            ( comp A'' A' A \u03b1 \u03b1')\n#def is-right-orthogonal-comp-to-shape\nuses (is-orth-\u03c8-\u03d5-\u03b1' is-orth-\u03c8-\u03d5-\u03b1)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A'' A (comp A'' A' A \u03b1 \u03b1')\n  :=\n\\ \u03c3'' \u2192\n      is-equiv-comp\n      ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A'') \u03c3'')\n      ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ t \u2192 \u03b1' (\u03c3'' t)))\n      ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A) (\\ t \u2192 \u03b1 (\u03b1' (\u03c3'' t))))\n      ( \\ \u03c4'' t \u2192 \u03b1' (\u03c4'' t))\n      ( is-orth-\u03c8-\u03d5-\u03b1' \u03c3'')\n      ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n      ( is-orth-\u03c8-\u03d5-\u03b1 (\\ t \u2192 \u03b1' (\u03c3'' t)))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#right-cancellation","title":"Right cancellation","text":"<p>One can always cancel right orthogonal maps from the right.</p> <pre><code>#def is-right-orthogonal-right-cancel-to-shape\nuses (is-orth-\u03c8-\u03d5-\u03b1 is-orth-\u03c8-\u03d5-\u03b1\u03b1')\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A'' A' \u03b1'\n  :=\n\\ \u03c3'' \u2192\n    is-equiv-right-factor\n     ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A'') \u03c3'')\n     ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ t \u2192 \u03b1' (\u03c3'' t)))\n     ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A) (\\ t \u2192 \u03b1 (\u03b1' (\u03c3'' t))))\n     ( \\ \u03c4'' t \u2192 \u03b1' (\u03c4'' t))\n     ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t))\n     ( is-orth-\u03c8-\u03d5-\u03b1 (\\ t \u2192 \u03b1' (\u03c3'' t)))\n     ( is-orth-\u03c8-\u03d5-\u03b1\u03b1' \u03c3'')\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#left-cancellation-with-section","title":"Left cancellation with section","text":"<p>If the map <code>\u03b1' : A'' \u2192 A'</code> has a section, then we can also cancel it from the right (whether it is right orthogonal or not.)</p> <pre><code>#def is-right-orthogonal-left-cancel-with-section-to-shape\nuses (extext is-orth-\u03c8-\u03d5-\u03b1\u03b1')\n( has-section-\u03b1' : has-section A'' A' \u03b1')\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n    is-homotopy-cartesian-left-cancel-with-section'\n        ( \u03d5 \u2192 A'' ) ( \\ \u03c3'' \u2192 (t : \u03c8) \u2192 A'' [\u03d5 t \u21a6 \u03c3'' t])\n        ( \u03d5 \u2192 A' ) ( \\ \u03c3' \u2192 (t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n        ( \u03d5 \u2192 A ) ( \\ \u03c3 \u2192 (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n        ( \\ \u03c3'' t \u2192 \u03b1' (\u03c3'' t)) ( \\ _ \u03c4'' x \u2192 \u03b1' (\u03c4'' x) )\n        ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t)) ( \\ _ \u03c4' x \u2192 \u03b1 (\u03c4' x) )\n    ( has-section-extensions-BOT-has-section extext I (\\ t \u2192 \u03d5 t)\n          ( \\ _ \u2192 A'') (\\ _ \u2192 A') (\\ _ \u2192 \u03b1')\n      ( \\ _ \u2192 has-section-\u03b1'))\n    ( has-section-extensions-has-section extext I \u03c8 \u03d5\n          ( \\ _ \u2192 A'') (\\ _ \u2192 A') (\\ _ \u2192 \u03b1')\n      ( \\ _ \u2192 has-section-\u03b1'))\n    ( is-orth-\u03c8-\u03d5-\u03b1\u03b1')\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#pullback","title":"Pullback","text":"<p>Right orthogonal maps are stable under pullback. More precisely: If <code>\u03b1 : A' \u2192 A</code> is right orthogonal, then so is the second projection <code>relative-product A A' \u03b1 B f \u2192 B</code> for every <code>f : B \u2192 A</code>.</p> <p>To prove this, we first show that each relative extension type of <code>relative-product A A' \u03b1 B f \u2192 B</code>, is a retract of a generalized extension type for <code>A' \u2192 A</code>. Since the latter are all contractible by assumption, the same follows for the former.</p> <pre><code>#variable B : U\n#variable f : B \u2192 A\n#def relative-extension-type-pullback-general-relative-extension-type\n( \u03c3B' : \u03d5 \u2192 relative-product A A' \u03b1 B f)\n( \u03c4B : (t : \u03c8) \u2192 B [\u03d5 t \u21a6 second-relative-product A A' \u03b1 B f (\u03c3B' t)])\n  ( (\u03c4A', hA)\n    : general-relative-extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n      ( \\ t \u2192 first-relative-product A A' \u03b1 B f (\u03c3B' t))\n      ( \\ t \u2192 f (\u03c4B t))\n      ( \\ t \u2192 homotopy-relative-product A A' \u03b1 B f (\u03c3B' t)))\n  : relative-extension-type I \u03c8 \u03d5\n    ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n    ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n    ( \u03c3B') ( \u03c4B)\n  :=\n    ( \\ t \u2192 ( (\u03c4A' t, \u03c4B t) , hA t)\n    , \\ t \u2192 refl)\n#def general-relative-extension-type-relative-extension-type-pullback\n( \u03c3B' : \u03d5 \u2192 relative-product A A' \u03b1 B f)\n( \u03c4B : (t : \u03c8) \u2192 B [\u03d5 t \u21a6 second-relative-product A A' \u03b1 B f (\u03c3B' t)])\n  ( (\u03c4B', hB)\n    : relative-extension-type I \u03c8 \u03d5\n      ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n      ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n      ( \u03c3B') ( \u03c4B))\n  : general-relative-extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n    ( \\ t \u2192 first-relative-product A A' \u03b1 B f (\u03c3B' t))\n    ( \\ t \u2192 f (\u03c4B t))\n    ( \\ t \u2192 homotopy-relative-product A A' \u03b1 B f (\u03c3B' t))\n  :=\n    ( \\ t \u2192 first-relative-product A A' \u03b1 B f (\u03c4B' t)\n    , \\ t \u2192\n      concat A\n      ( \u03b1 (first-relative-product A A' \u03b1 B f (\u03c4B' t)))\n      ( f (second-relative-product A A' \u03b1 B f (\u03c4B' t)))\n      ( f (\u03c4B t))\n      ( homotopy-relative-product A A' \u03b1 B f (\u03c4B' t))\n      ( ap B A\n        ( second-relative-product A A' \u03b1 B f (\u03c4B' t))\n        ( \u03c4B t)\n        ( f) ( hB t)))\n#def is-id-rel-ext-type-pb-gen-rel-ext-type-rel-ext-type-pb uses (extext)\n( \u03c3B' : \u03d5 \u2192 relative-product A A' \u03b1 B f)\n( \u03c4B : (t : \u03c8) \u2192 B [\u03d5 t \u21a6 second-relative-product A A' \u03b1 B f (\u03c3B' t)])\n  : ( \u03c4hB\n      : relative-extension-type I \u03c8 \u03d5\n        ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n        ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n        ( \u03c3B') ( \u03c4B))\n  \u2192 ( relative-extension-type-pullback-general-relative-extension-type \u03c3B' \u03c4B\n      ( general-relative-extension-type-relative-extension-type-pullback \u03c3B' \u03c4B \u03c4hB)\n    = \u03c4hB)\n  :=\n    ind-has-section-equiv\n    ( relative-extension-type' I \u03c8 \u03d5\n      ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n      ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n      ( \u03c3B') ( \u03c4B))\n    ( relative-extension-type I \u03c8 \u03d5\n      ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n      ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n      ( \u03c3B') ( \u03c4B))\n    ( equiv-relative-extension-type-fib extext I \u03c8 \u03d5\n      ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n      ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n      ( \u03c3B') ( \u03c4B))\n    ( \\ \u03c4hB \u2192\n      ( relative-extension-type-pullback-general-relative-extension-type \u03c3B' \u03c4B\n        ( general-relative-extension-type-relative-extension-type-pullback \u03c3B' \u03c4B \u03c4hB)\n      = \u03c4hB))\n( ind-fib\n      ( (t : \u03c8) \u2192 relative-product A A' \u03b1 B f [\u03d5 t \u21a6 \u03c3B' t])\n( (t : \u03c8) \u2192 B [\u03d5 t \u21a6 second-relative-product A A' \u03b1 B f (\u03c3B' t)])\n      ( \\ \u03c4B' t \u2192 second-relative-product A A' \u03b1 B f (\u03c4B' t))\n      ( \\ \u03c4B\u2081 (\u03c4B'\u2081, h\u2081) \u2192\n        ( relative-extension-type-pullback-general-relative-extension-type \u03c3B' \u03c4B\u2081\n          ( general-relative-extension-type-relative-extension-type-pullback \u03c3B' \u03c4B\u2081\n            ( \u03c4B'\u2081\n            , ext-htpy-eq I \u03c8 \u03d5 (\\ _ \u2192 B)\n              ( \\ t \u2192 second-relative-product A A' \u03b1 B f (\u03c3B' t))\n              ( \\ t \u2192 second-relative-product A A' \u03b1 B f (\u03c4B'\u2081 t))\n              ( \u03c4B\u2081) ( h\u2081)))\n        = ( \u03c4B'\u2081\n          , ext-htpy-eq I \u03c8 \u03d5 (\\ _ \u2192 B)\n            ( \\ t \u2192 second-relative-product A A' \u03b1 B f (\u03c3B' t))\n            ( \\ t \u2192 second-relative-product A A' \u03b1 B f (\u03c4B'\u2081 t))\n            ( \u03c4B\u2081) ( h\u2081))))\n      ( \\ \u03c4B' \u2192 refl)\n      ( \u03c4B))\n#def is-retract-of-rel-ext-type-pb-gen-rel-ext-type uses (extext)\n( \u03c3B' : \u03d5 \u2192 relative-product A A' \u03b1 B f)\n( \u03c4B : (t : \u03c8) \u2192 B [\u03d5 t \u21a6 second-relative-product A A' \u03b1 B f (\u03c3B' t)])\n  : is-retract-of\n    ( relative-extension-type I \u03c8 \u03d5\n      ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n      ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n      ( \u03c3B') ( \u03c4B))\n    ( general-relative-extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n      ( \\ t \u2192 first-relative-product A A' \u03b1 B f (\u03c3B' t))\n      ( \\ t \u2192 f (\u03c4B t))\n      ( \\ t \u2192 homotopy-relative-product A A' \u03b1 B f (\u03c3B' t)))\n  :=\n    ( general-relative-extension-type-relative-extension-type-pullback \u03c3B' \u03c4B\n    , ( relative-extension-type-pullback-general-relative-extension-type \u03c3B' \u03c4B\n      , is-id-rel-ext-type-pb-gen-rel-ext-type-rel-ext-type-pb \u03c3B' \u03c4B))\n</code></pre> <p>Then we can deduce that right orthogonal maps are preserved under pullback:</p> <pre><code>#def is-right-orthogonal-pullback-to-shape uses (extext is-orth-\u03c8-\u03d5-\u03b1 B f)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5\n    ( relative-product A A' \u03b1 B f) ( B)\n    ( second-relative-product A A' \u03b1 B f)\n  :=\n    is-right-orthogonal-to-shape-has-contr-relative-extension-types I \u03c8 \u03d5\n    ( relative-product A A' \u03b1 B f) ( B)\n    ( second-relative-product A A' \u03b1 B f)\n    ( \\ \u03c3B' \u03c4B \u2192\n      is-contr-is-retract-of-is-contr\n      ( relative-extension-type I \u03c8 \u03d5\n        ( \\ _ \u2192 relative-product A A' \u03b1 B f) ( \\ _ \u2192 B)\n        ( \\ _ \u2192 second-relative-product A A' \u03b1 B f)\n        ( \u03c3B') ( \u03c4B))\n      ( general-relative-extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n        ( \\ t \u2192 first-relative-product A A' \u03b1 B f (\u03c3B' t))\n        ( \\ t \u2192 f (\u03c4B t))\n        ( \\ t \u2192 homotopy-relative-product A A' \u03b1 B f (\u03c3B' t)))\n      ( is-retract-of-rel-ext-type-pb-gen-rel-ext-type \u03c3B' \u03c4B)\n      ( has-contr-general-relative-extension-types-is-right-orthogonal-to-shape\n        I \u03c8 \u03d5 A' A \u03b1\n        ( is-orth-\u03c8-\u03d5-\u03b1)\n        ( \\ t \u2192 first-relative-product A A' \u03b1 B f (\u03c3B' t))\n        ( \\ t \u2192 f (\u03c4B t))\n        ( \\ t \u2192 homotopy-relative-product A A' \u03b1 B f (\u03c3B' t))))\n#end right-orthogonal-calculus\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#stability-under-equivalence","title":"Stability under equivalence","text":"<p>If two maps <code>\u03b1 : A' \u2192 A</code> and <code>\u03b2 : B' \u2192 B</code> are equivalent, then if one is right orthogonal to <code>\u03d5 \u2282 \u03c8</code>, then so is the other.</p> <pre><code>#section is-right-orthogonal-equiv-to-shape\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variables A' A : U\n#variable \u03b1 : A' \u2192 A\n#variables B' B : U\n#variable \u03b2 : B' \u2192 B\n#def is-right-orthogonal-equiv-to-shape uses (funext extext)\n  ( (((s', s), \u03b7), (is-equiv-s', is-equiv-s)) : Equiv-of-maps A' A \u03b1 B' B \u03b2)\n( is-orth-\u03c8-\u03d5-\u03b2 : is-right-orthogonal-to-shape I \u03c8 \u03d5 B' B \u03b2)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n    is-right-orthogonal-right-cancel-to-shape I \u03c8 \u03d5 A' A B \u03b1 s\n    ( is-right-orthogonal-is-equiv-to-shape I \u03c8 \u03d5 A B s is-equiv-s)\n    ( is-right-orthogonal-homotopy-to-shape I \u03c8 \u03d5 A' B\n      ( \\ a' \u2192 \u03b2 (s' a')) ( \\ a' \u2192 s (\u03b1 a')) ( \u03b7)\n      ( is-right-orthogonal-comp-to-shape I \u03c8 \u03d5 A' B' B s' \u03b2\n        ( is-right-orthogonal-is-equiv-to-shape I \u03c8 \u03d5 A' B' s' is-equiv-s')\n        ( is-orth-\u03c8-\u03d5-\u03b2)))\n#def is-right-orthogonal-equiv-to-shape'\nuses (funext extext)\n  ( (((s', s), \u03b7), (is-equiv-s', is-equiv-s)) : Equiv-of-maps A' A \u03b1 B' B \u03b2)\n( is-orth-\u03c8-\u03d5-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 B' B \u03b2\n  :=\n    is-right-orthogonal-left-cancel-with-section-to-shape\n          I \u03c8 \u03d5 A' B' B s' \u03b2\n    ( is-right-orthogonal-homotopy-to-shape I \u03c8 \u03d5 A' B\n      ( \\ a' \u2192 s (\u03b1 a')) ( \\ a' \u2192 \u03b2 (s' a'))\n      ( rev-homotopy A' B ( \\ a' \u2192 \u03b2 (s' a')) ( \\ a' \u2192 s (\u03b1 a')) ( \u03b7))\n      ( is-right-orthogonal-comp-to-shape I \u03c8 \u03d5 A' A B \u03b1 s\n        ( is-orth-\u03c8-\u03d5-\u03b1)\n        ( is-right-orthogonal-is-equiv-to-shape I \u03c8 \u03d5 A B s is-equiv-s)))\n    ( second is-equiv-s')\n#end is-right-orthogonal-equiv-to-shape\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#exponentiation-product-types","title":"Exponentiation / product types","text":"<p>Let <code>\u03b1 : A' \u2192 A</code> be right orthogonal to <code>\u03d5 \u2282 \u03c8</code>. Then the same is true for the induced map <code>(X \u2192 A') \u2192 (X \u2192 A)</code> for any type <code>X</code>. More generally, if <code>\u03b1 x : A' x \u2192 A x</code> is a right orthogonal map for each <code>x : X</code>, then so is the map on dependent products <code>\u03a0 \u03b1 : \u03a0 A' \u2192 \u03a0 A</code>.</p> <pre><code>#def is-right-orthogonal-\u03a0-to-shape uses (funext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : U)\n( A' A : X \u2192 U)\n( \u03b1 : (x : X) \u2192 (A' x) \u2192 (A x))\n( are-right-orth-\u03c8-\u03d5-\u03b1\n    : (x : X) \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 (A' x) (A x) (\u03b1 x))\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5\n( (x : X) \u2192 A' x)\n( (x : X) \u2192 A x)\n    ( \\ a' x \u2192 \u03b1 x (a' x))\n  :=\n\\ \u03c3' \u2192\n    is-equiv-Equiv-is-equiv\n( (t : \u03c8) \u2192 ((x : X) \u2192 A' x) [\u03d5 t \u21a6 \u03c3' t])\n( (t : \u03c8) \u2192 ((x : X) \u2192 A x) [\u03d5 t \u21a6 \\ x \u2192 \u03b1 x (\u03c3' t x)])\n    ( \\ \u03c4' t x \u2192 \u03b1 x (\u03c4' t x))\n( (x : X) \u2192 (t : \u03c8) \u2192 A' x [\u03d5 t \u21a6 \u03c3' t x])\n( (x : X) \u2192 (t : \u03c8) \u2192 A x [\u03d5 t \u21a6 \u03b1 x (\u03c3' t x)])\n    ( \\ \u03c4' x t \u2192 \u03b1 x (\u03c4' x t))\n    ( flip-ext-fun-functorial I \u03c8 \u03d5 X\n      (\\ _ \u2192 A') (\\ _ \u2192 A) (\\ _ \u2192 \u03b1)\n      ( \u03c3'))\n( is-equiv-function-is-equiv-family funext X\n      ( \\ x \u2192 (t : \u03c8) \u2192 A' x [\u03d5 t \u21a6 \u03c3' t x])\n( \\ x \u2192 (t : \u03c8) \u2192 A x [\u03d5 t \u21a6 \u03b1 x (\u03c3' t x)])\n      ( \\ x \u03c4' t \u2192 \u03b1 x (\u03c4' t))\n      ( \\ x \u2192 are-right-orth-\u03c8-\u03d5-\u03b1 x ( \\ t \u2192 \u03c3' t x)))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#sigma-types","title":"Sigma types","text":"<p>Warning: It is not true that right orthogonal maps are preserved under dependent sums.</p> <p>Indeed, every map <code>f: A \u2192 B</code> can be written as <code>\u03a3 (b : B) , fib f b \u2192 \u03a3 (b : B) , Unit</code>; and it is not true that <code>f</code> is right orthogonal if and only if each <code>fib f b \u2192 Unit</code> is right orthogonal. For example, the map <code>{0} \u2192 \u0394\u00b9</code> is not a left fibration even though its fibers are all left fibrant (i.e. discrete).</p>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#types-with-unique-extension","title":"Types with unique extension","text":"<p>We say that an type <code>A</code> has unique extensions for a shape inclusion <code>\u03d5 \u2282 \u03c8</code>, if for each <code>\u03c3 : \u03d5 \u2192 A</code> the type of <code>\u03c8</code>-extensions is contractible.</p> <pre><code>#section has-unique-extensions\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variable A : U\n#def has-unique-extensions\n  : U\n  := ( \u03c3 : \u03d5 \u2192 A) \u2192 is-contr ( (t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3 t])\n</code></pre> <p>There are other equivalent characterizations which we shall prove below:</p> <p>We can ask that the canonical restriction map <code>(\u03c8 \u2192 A) \u2192 (\u03d5 \u2192 A)</code> is an equivalence.</p> <pre><code>#def is-local-type\n  : U\n  := is-equiv (\u03c8 \u2192 A) (\u03d5 \u2192 A) ( \\ \u03c4 t \u2192 \u03c4 t)\n</code></pre> <p>We can ask that the terminal map <code>A \u2192 Unit</code> is right orthogonal to <code>\u03d5 \u2282 \u03c8</code>.</p> <pre><code>#def is-right-orthogonal-terminal-map\n  : U\n  := is-right-orthogonal-to-shape I \u03c8 \u03d5 A Unit (terminal-map A)\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#unique-extensions-types-are-local-types","title":"Unique extensions types are local types","text":"<p>The equivalence between <code>is-local-type</code> and <code>has-unique-extensions</code> follows straightforwardly from the fact that for every <code>\u03c3 : \u03d5 \u2192 A</code> we have an equivalence between the extension type <code>(t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03c3 t]</code> and the fiber of the restriction map <code>(\u03c8 \u2192 A) \u2192 (\u03d5 \u2192 A)</code>.</p> <pre><code>#def is-local-type-has-unique-extensions\n( has-ue-\u03c8-\u03d5-A : has-unique-extensions)\n  : is-local-type\n  :=\n    is-equiv-is-contr-map (\u03c8 \u2192 A) (\u03d5 \u2192 A) ( \\ \u03c4 t \u2192 \u03c4 t)\n( \\ ( \u03c3 : \u03d5 \u2192 A) \u2192\n        is-contr-equiv-is-contr\n          ( extension-type I \u03c8 \u03d5 ( \\ t \u2192 A) \u03c3)\n          ( homotopy-extension-type I \u03c8 \u03d5 ( \\ t \u2192 A) \u03c3)\n          ( extension-type-weakening I \u03c8 \u03d5 ( \\ t \u2192 A) \u03c3)\n          ( has-ue-\u03c8-\u03d5-A \u03c3))\n#def has-unique-extensions-is-local-type\n( is-lt-\u03c8-\u03d5-A : is-local-type)\n  : has-unique-extensions\n  :=\n\\ \u03c3 \u2192\n      is-contr-equiv-is-contr'\n        ( extension-type I \u03c8 \u03d5 ( \\ t \u2192 A) \u03c3)\n        ( homotopy-extension-type I \u03c8 \u03d5 ( \\ t \u2192 A) \u03c3)\n        ( extension-type-weakening I \u03c8 \u03d5 ( \\ t \u2192 A) \u03c3)\n        ( is-contr-map-is-equiv\n            ( \u03c8 \u2192 A) (\u03d5 \u2192 A) ( \\ \u03c4 t \u2192 \u03c4 t)\n            ( is-lt-\u03c8-\u03d5-A)\n            ( \u03c3))\n#end has-unique-extensions\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#properties-of-local-types-unique-extension-types","title":"Properties of local types / unique extension types","text":"<p>We fix a shape inclusion <code>\u03d5 \u2282 \u03c8</code>.</p> <pre><code>#section stability-properties-local-types\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n</code></pre> <p>Every map between types with unique extensions / local types is right orthogonal.</p> <pre><code>#def is-right-orthogonal-have-unique-extensions\n( A' A : U)\n( has-ue-\u03c8-\u03d5-A' : has-unique-extensions I \u03c8 \u03d5 A')\n( has-ue-\u03c8-\u03d5-A : has-unique-extensions I \u03c8 \u03d5 A)\n( \u03b1 : A' \u2192 A)\n  : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n\\ \u03c3 \u2192\n      is-equiv-are-contr\n      ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A') (\u03c3))\n      ( extension-type I \u03c8 \u03d5 (\\ _ \u2192 A) (\\ t \u2192 \u03b1 (\u03c3 t)))\n      ( has-ue-\u03c8-\u03d5-A' \u03c3)\n      ( has-ue-\u03c8-\u03d5-A (\\ t \u2192 \u03b1 (\u03c3 t)))\n      ( \\ \u03c4 t \u2192 \u03b1 (\u03c4 t))\n#def is-right-orthogonal-are-local-types\n( A' A : U)\n( is-lt-\u03c8-\u03d5-A' : is-local-type I \u03c8 \u03d5 A')\n( is-lt-\u03c8-\u03d5-A : is-local-type I \u03c8 \u03d5 A)\n  : ( \u03b1 : A' \u2192 A)\n  \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n  :=\n    is-right-orthogonal-have-unique-extensions A' A\n    ( has-unique-extensions-is-local-type I \u03c8 \u03d5 A' is-lt-\u03c8-\u03d5-A')\n    ( has-unique-extensions-is-local-type I \u03c8 \u03d5 A is-lt-\u03c8-\u03d5-A)\n</code></pre> <p>Conversely, the property of having unique extension can be pulled back along any right orthogonal map.</p> <pre><code>#def has-unique-extensions-right-orthogonal-has-unique-extensions\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( is-orth-\u03c8-\u03d5-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  : has-unique-extensions I \u03c8 \u03d5 A \u2192 has-unique-extensions I \u03c8 \u03d5 A'\n  :=\n\\ has-ue-A ( \u03c3' : \u03d5 \u2192 A') \u2192\n      is-contr-equiv-is-contr'\n( ( t : \u03c8) \u2192 A' [\u03d5 t \u21a6 \u03c3' t])\n( ( t : \u03c8) \u2192 A [\u03d5 t \u21a6 \u03b1 (\u03c3' t)])\n        ( \\ \u03c4' t \u2192 \u03b1 (\u03c4' t) , is-orth-\u03c8-\u03d5-\u03b1 \u03c3')\n        ( has-ue-A (\\ t \u2192 \u03b1 (\u03c3' t)))\n#def is-local-type-right-orthogonal-is-local-type\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( is-orth-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n( is-local-A : is-local-type I \u03c8 \u03d5 A)\n  : is-local-type I \u03c8 \u03d5 A'\n  :=\n    is-local-type-has-unique-extensions I \u03c8 \u03d5 A'\n      ( has-unique-extensions-right-orthogonal-has-unique-extensions\n          ( A') ( A) ( \u03b1) ( is-orth-\u03b1)\n          ( has-unique-extensions-is-local-type I \u03c8 \u03d5 A is-local-A))\n</code></pre> <p>Weak extension extensionality says that every contractible type has unique extensions for every shape inclusion <code>\u03d5 \u2282 \u03c8</code>.</p> <pre><code>#def has-unique-extensions-is-contr uses (extext)\n( C : U)\n( is-contr-C : is-contr C)\n  : has-unique-extensions I \u03c8 \u03d5 C\n  :=\n    weakextext-extext extext I \u03c8 \u03d5\n    ( \\ _ \u2192 C) ( \\ _ \u2192 is-contr-C)\n#def is-local-type-is-contr uses (extext)\n( C : U)\n( is-contr-C : is-contr C)\n  : is-local-type I \u03c8 \u03d5 C\n  :=\n    is-local-type-has-unique-extensions I \u03c8 \u03d5 C\n    ( has-unique-extensions-is-contr C is-contr-C)\n#def has-unique-extensions-Unit uses (extext)\n  : has-unique-extensions I \u03c8 \u03d5 Unit\n  := has-unique-extensions-is-contr Unit is-contr-Unit\n</code></pre> <p>Unique extension types are closed under equivalence.</p> <pre><code>#def is-local-type-equiv-is-local-type uses (extext)\n( A' A : U)\n( A'\u2243A : Equiv A' A)\n  : is-local-type I \u03c8 \u03d5 A \u2192 is-local-type I \u03c8 \u03d5 A'\n  :=\n    is-equiv-Equiv-is-equiv\n      ( \u03c8 \u2192 A') ( \u03d5 \u2192 A') ( \\ \u03c4' t \u2192 \u03c4' t)\n      ( \u03c8 \u2192 A)  ( \u03d5 \u2192 A)  ( \\ \u03c4 t \u2192 \u03c4 t)\n      ( equiv-of-restriction-maps-equiv extext I \u03c8 \u03d5\n        ( \\ _ \u2192 A') ( \\ _ \u2192 A) ( \\ _ \u2192 A'\u2243A))\n#def has-unique-extensions-equiv-has-unique-extensions uses (extext)\n( A' A : U)\n  ( (\u03b1 , is-equiv-\u03b1) : Equiv A' A)\n  : has-unique-extensions I \u03c8 \u03d5 A \u2192 has-unique-extensions I \u03c8 \u03d5 A'\n  :=\n    has-unique-extensions-right-orthogonal-has-unique-extensions A' A \u03b1\n    ( is-right-orthogonal-is-equiv-to-shape I \u03c8 \u03d5 A' A \u03b1 is-equiv-\u03b1)\n#end stability-properties-local-types\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#unique-extension-types-are-types-with-right-orthogonal-terminal-map","title":"Unique extension types are types with right orthogonal terminal map","text":"<p>Next we prove the logical equivalence between <code>has-unique-extensions</code> and <code>is-right-orthogonal-terminal-map</code>. This follows directly from the fact that <code>Unit</code> has unique extensions (using <code>extext</code>).</p> <pre><code>#section is-right-orthogonal-terminal-map\n#variable I : CUBE\n#variable \u03c8 : I \u2192 TOPE\n#variable \u03d5 : \u03c8 \u2192 TOPE\n#variable A : U\n#def has-unique-extensions-is-right-orthogonal-terminal-map\nuses (extext)\n( is-orth-\u03c8-\u03d5-tm-A : is-right-orthogonal-terminal-map I \u03c8 \u03d5 A)\n  : has-unique-extensions I \u03c8 \u03d5 A\n  :=\n    has-unique-extensions-right-orthogonal-has-unique-extensions\n      I \u03c8 \u03d5 A Unit (terminal-map A)\n    ( is-orth-\u03c8-\u03d5-tm-A)\n    ( has-unique-extensions-Unit I \u03c8 \u03d5)\n#def has-unique-extensions-is-right-orthogonal-a-terminal-map\nuses (extext)\n( tm : A \u2192 Unit)\n( is-orth-\u03c8-\u03d5-tm : is-right-orthogonal-to-shape I \u03c8 \u03d5 A Unit tm)\n  : has-unique-extensions I \u03c8 \u03d5 A\n  :=\n    has-unique-extensions-right-orthogonal-has-unique-extensions\n      I \u03c8 \u03d5 A Unit tm\n    ( is-orth-\u03c8-\u03d5-tm)\n    ( has-unique-extensions-Unit I \u03c8 \u03d5)\n#def is-right-orthogonal-terminal-map-has-unique-extensions\nuses (extext)\n( has-ue-\u03c8-\u03d5-A : has-unique-extensions I \u03c8 \u03d5 A)\n  : is-right-orthogonal-terminal-map I \u03c8 \u03d5 A\n  :=\n    is-right-orthogonal-have-unique-extensions I \u03c8 \u03d5 A Unit\n    ( has-ue-\u03c8-\u03d5-A) ( has-unique-extensions-Unit I \u03c8 \u03d5)\n    ( terminal-map A)\n#def is-right-orthogonal-terminal-map-is-local-type\nuses (extext)\n( is-lt-\u03c8-\u03d5-A : is-local-type I \u03c8 \u03d5 A)\n  : is-right-orthogonal-terminal-map I \u03c8 \u03d5 A\n  :=\n    is-right-orthogonal-terminal-map-has-unique-extensions\n    ( has-unique-extensions-is-local-type I \u03c8 \u03d5 A is-lt-\u03c8-\u03d5-A)\n#def is-local-type-is-right-orthogonal-terminal-map\nuses (extext)\n( is-orth-\u03c8-\u03d5-tm-A : is-right-orthogonal-terminal-map I \u03c8 \u03d5 A)\n  : is-local-type I \u03c8 \u03d5 A\n  :=\n    is-local-type-has-unique-extensions I \u03c8 \u03d5 A\n    ( has-unique-extensions-is-right-orthogonal-terminal-map\n      ( is-orth-\u03c8-\u03d5-tm-A))\n#end is-right-orthogonal-terminal-map\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#fibers-of-right-orthogonal-maps","title":"Fibers of right orthogonal maps","text":"<p>Let <code>\u03b1 : A' \u2192 A</code> be right orthogonal to <code>\u03d5 \u2282 \u03c8</code>. Then every fiber of <code>\u03b1</code> has unique extensions along <code>\u03d5 \u2282 \u03c8</code>. This follows immediately since the fibers of <code>\u03b1</code> are just the relative products of <code>\u03b1 : A' \u2192 A</code> with the maps <code>a : Unit \u2192 A</code> from the unit type.</p> <pre><code>#def has-fiberwise-unique-extensions-is-right-orthogonal-to-shape\nuses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( is-orth-\u03c8-\u03d5-\u03b1 : is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n( a : A)\n  : has-unique-extensions I \u03c8 \u03d5 (fib A' A \u03b1 a)\n  :=\n    has-unique-extensions-equiv-has-unique-extensions I \u03c8 \u03d5\n    ( fib A' A \u03b1 a)\n    ( relative-product A A' \u03b1 Unit (\\ unit \u2192 a))\n    ( compute-pullback-to-Unit A' A \u03b1 a)\n    ( has-unique-extensions-is-right-orthogonal-terminal-map I \u03c8 \u03d5\n      ( relative-product A A' \u03b1 Unit (\\ unit \u2192 a))\n      ( is-right-orthogonal-pullback-to-shape I \u03c8 \u03d5 A' A \u03b1\n        ( is-orth-\u03c8-\u03d5-\u03b1) ( Unit) (\\ unit \u2192 a)))\n</code></pre> <p>Corollary: Given two types <code>A'</code> and <code>A</code> with unique extensions w.r.t. <code>\u03d5 \u2282 \u03c8</code>, every fiber of every map <code>\u03b1 : A' \u2192 A</code> also has unique extensions.</p> <pre><code>#def has-fiberwise-unique-extensions-have-unique-extensions\nuses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( has-ue-\u03c8-\u03d5-A' : has-unique-extensions I \u03c8 \u03d5 A')\n( has-ue-\u03c8-\u03d5-A : has-unique-extensions I \u03c8 \u03d5 A)\n  : (a : A) \u2192 has-unique-extensions I \u03c8 \u03d5 (fib A' A \u03b1 a)\n  :=\n    has-fiberwise-unique-extensions-is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n    ( is-right-orthogonal-have-unique-extensions I \u03c8 \u03d5 A' A\n      ( has-ue-\u03c8-\u03d5-A') ( has-ue-\u03c8-\u03d5-A) ( \u03b1))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#anodyne-shape-inclusions","title":"Anodyne shape inclusions","text":"<p>Fix a shape inclusion <code>\u03d5 \u2282 \u03c8</code>. We say that another shape inclusion <code>\u03c7 \u2282 \u03b6</code> is anodyne for <code>\u03d5 \u2282 \u03c8</code>, is every map that is right orthogonal to <code>\u03d5 \u2282 \u03c8</code> is also right orthogonal to <code>\u03c7 \u2282 \u03b6</code>.</p> <pre><code>#section anodyne\n#variable I\u2080 : CUBE\n#variable \u03c8\u2080 : I\u2080 \u2192 TOPE\n#variable \u03d5\u2080 : \u03c8\u2080 \u2192 TOPE\n#def is-anodyne-for-shape\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n  : U\n  :=\n( ( A' : U) \u2192 (A : U) \u2192 (\u03b1 : A' \u2192 A)\n    \u2192 is-right-orthogonal-to-shape I\u2080 \u03c8\u2080 \u03d5\u2080 A' A \u03b1\n    \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n</code></pre> <p>Of course every shape inclusion is anodyne for itself.</p> <pre><code>#def is-anodyne-for-self\n  : is-anodyne-for-shape I\u2080 \u03c8\u2080 \u03d5\u2080\n  := \\ _ _ _ is-orth\u2080 \u2192 is-orth\u2080\n</code></pre> <p>All the stability properties above can be seen as implications between conditions of being anodyne.</p> <pre><code>#def is-anodyne-comp-for-shape\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03c7 : \u03c8 \u2192 TOPE)\n( \u03d5 : \u03c7 \u2192 TOPE)\n  : is-anodyne-for-shape I \u03c8 \u03c7\n  \u2192 is-anodyne-for-shape I (\\ t \u2192 \u03c7 t) (\\ t \u2192 \u03d5 t)\n  \u2192 is-anodyne-for-shape I \u03c8 (\\ t \u2192 \u03d5 t)\n  :=\n\\ f g A' A \u03b1 is-orth\u2080 \u2192\n    ( is-right-orthogonal-to-shape-comp A' A \u03b1 I \u03c8 \u03c7 \u03d5\n      ( f A' A \u03b1 is-orth\u2080)\n      ( g A' A \u03b1 is-orth\u2080))\n#def is-anodyne-left-cancel-for-shape\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03c7 : \u03c8 \u2192 TOPE)\n( \u03d5 : \u03c7 \u2192 TOPE)\n  : is-anodyne-for-shape I (\\ t \u2192 \u03c7 t) (\\ t \u2192 \u03d5 t)\n  \u2192 is-anodyne-for-shape I \u03c8 (\\ t \u2192 \u03d5 t)\n  \u2192 is-anodyne-for-shape I \u03c8 \u03c7\n  :=\n\\ f g A' A \u03b1 is-orth\u2080 \u2192\n    ( is-right-orthogonal-to-shape-left-cancel A' A \u03b1 I \u03c8 \u03c7 \u03d5\n      ( f A' A \u03b1 is-orth\u2080)\n      ( g A' A \u03b1 is-orth\u2080))\n#def is-anodyne-right-cancel-retract-for-shape\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03c7 : \u03c8 \u2192 TOPE)\n( \u03d5 : \u03c7 \u2192 TOPE)\n  : is-functorial-shape-retract I \u03c8 \u03c7\n  \u2192 is-anodyne-for-shape I \u03c8 (\\ t \u2192 \u03d5 t)\n  \u2192 is-anodyne-for-shape I (\\ t \u2192 \u03c7 t) (\\ t \u2192 \u03d5 t)\n  :=\n\\ r f A' A \u03b1 is-orth\u2080 \u2192\n    ( is-right-orthogonal-to-shape-right-cancel-retract A' A \u03b1 I \u03c8 \u03c7 \u03d5\n      ( f A' A \u03b1 is-orth\u2080) ( r))\n#def is-anodyne-pushout-product-for-shape uses (extext)\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n  : is-anodyne-for-shape I \u03c8 \u03d5\n  \u2192 is-anodyne-for-shape (J \u00d7 I)\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s)\n    ( \\ (t , s) \u2192 (\u03b6 t \u2227 \u03c8 s) \u2228 (\u03c7 t \u2227 \u03d5 s))\n  :=\n\\ f A' A \u03b1 is-orth\u2080 \u2192\n    ( is-right-orthogonal-to-shape-pushout-product A' A \u03b1 J \u03c7 \u03b6 I \u03c8 \u03d5\n      ( f A' A \u03b1 is-orth\u2080))\n#def is-anodyne-pushout-product-for-shape' uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  : is-anodyne-for-shape I \u03c8 \u03d5\n  \u2192 is-anodyne-for-shape (I \u00d7 J)\n    ( \\ (s , t) \u2192 \u03c8 s \u2227 \u03c7 t)\n    ( \\ (s , t) \u2192 (\u03d5 s \u2227 \u03c7 t) \u2228 (\u03c8 s \u2227 \u03b6 t))\n  :=\n\\ f A' A \u03b1 is-orth\u2080 \u2192\n    ( is-right-orthogonal-to-shape-pushout-product' A' A \u03b1 I \u03c8 \u03d5 J \u03c7 \u03b6\n      ( f A' A \u03b1 is-orth\u2080))\n</code></pre>"},{"location":"simplicial-hott/04-right-orthogonal.rzk/#weak-anodyne-shape-inclusions","title":"Weak anodyne shape inclusions","text":"<p>Instead of an implication with respect to right orthogonality, we ask for a mere implication with respect to types with unique extensions.</p> <pre><code>#def is-weak-anodyne-for-shape\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n  : U\n  :=\n( (A : U)\n    \u2192 has-unique-extensions I\u2080 \u03c8\u2080 \u03d5\u2080 A\n    \u2192 has-unique-extensions I \u03c8 \u03d5 A)\n</code></pre> <p>Every anodyne shape inclusion is weak anodyne.</p> <pre><code>#def is-weak-anodyne-is-anodyne-for-shape uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n  : is-anodyne-for-shape I \u03c8 \u03d5\n  \u2192 is-weak-anodyne-for-shape I \u03c8 \u03d5\n  :=\n\\ f A has-ue\u2080 \u2192\n    ( has-unique-extensions-is-right-orthogonal-terminal-map I \u03c8 \u03d5 A\n      ( f A Unit (terminal-map A)\n        ( is-right-orthogonal-terminal-map-has-unique-extensions I\u2080 \u03c8\u2080 \u03d5\u2080 A\n          has-ue\u2080)))\n</code></pre> <p>The inference rules that we saw above for anodyne shape inclusions all have an analog fo weak anodyne shape inclusions.</p> <pre><code>-- add them as you use them\n#def is-weak-anodyne-for-self\n  : is-weak-anodyne-for-shape I\u2080 \u03c8\u2080 \u03d5\u2080\n  := \\ _ has-ue\u2080 \u2192 has-ue\u2080\n#def implication-has-unique-extension-implication-right-orthogonal\nuses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n( impl\n    : (A' : U) \u2192 (A : U) \u2192 (\u03b1 : A' \u2192 A)\n    \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1\n    \u2192 is-right-orthogonal-to-shape J \u03c7 \u03b6 A' A \u03b1)\n( A : U)\n  : has-unique-extensions I \u03c8 \u03d5 A\n  \u2192 has-unique-extensions J \u03c7 \u03b6 A\n  :=\n\\ has-ue-\u03c8-\u03d5 \u2192\n    has-unique-extensions-is-right-orthogonal-terminal-map J \u03c7 \u03b6 A\n    ( impl A Unit (terminal-map A)\n      ( is-right-orthogonal-terminal-map-has-unique-extensions I \u03c8 \u03d5 A\n        has-ue-\u03c8-\u03d5))\n#def is-weak-anodyne-pushout-product-for-shape uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  : is-weak-anodyne-for-shape I \u03c8 \u03d5\n  \u2192 is-weak-anodyne-for-shape (J \u00d7 I)\n    ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s)\n    ( \\ (t , s) \u2192 (\u03b6 t \u2227 \u03c8 s) \u2228 (\u03c7 t \u2227 \u03d5 s))\n  :=\n\\ f A has-ue\u2080 \u2192\n    implication-has-unique-extension-implication-right-orthogonal I \u03c8 \u03d5\n    ( J \u00d7 I) ( \\ (t , s) \u2192 \u03c7 t \u2227 \u03c8 s) ( \\ (t , s) \u2192 (\u03b6 t \u2227 \u03c8 s) \u2228 (\u03c7 t \u2227 \u03d5 s))\n    ( \\ A'\u2081 A\u2081 \u03b1\u2081 \u2192\n      is-right-orthogonal-to-shape-pushout-product A'\u2081 A\u2081 \u03b1\u2081 J \u03c7 \u03b6 I \u03c8 \u03d5)\n    ( A) (f A has-ue\u2080)\n#def is-weak-anodyne-pushout-product-for-shape' uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE )\n( \u03d5 : \u03c8 \u2192 TOPE )\n( J : CUBE)\n( \u03c7 : J \u2192 TOPE)\n( \u03b6 : \u03c7 \u2192 TOPE)\n  : is-weak-anodyne-for-shape I \u03c8 \u03d5\n  \u2192 is-weak-anodyne-for-shape (I \u00d7 J)\n    ( \\ (s , t) \u2192 \u03c8 s \u2227 \u03c7 t)\n    ( \\ (s , t) \u2192 (\u03d5 s \u2227 \u03c7 t) \u2228 (\u03c8 s \u2227 \u03b6 t))\n  :=\n\\ f A has-ue\u2080 \u2192\n    implication-has-unique-extension-implication-right-orthogonal I \u03c8 \u03d5\n    ( I \u00d7 J) ( \\ (s , t) \u2192 \u03c8 s \u2227 \u03c7 t) ( \\ (s , t) \u2192 (\u03d5 s \u2227 \u03c7 t) \u2228 (\u03c8 s \u2227 \u03b6 t))\n    ( \\ A'\u2081 A\u2081 \u03b1\u2081 \u2192\n      is-right-orthogonal-to-shape-pushout-product' A'\u2081 A\u2081 \u03b1\u2081 I \u03c8 \u03d5 J \u03c7 \u03b6)\n    ( A) (f A has-ue\u2080)\n#end anodyne\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/","title":"Segal Types","text":"<p>These formalisations correspond to Section 5 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/01-paths.rzk.md</code> - We require basic path algebra.</li> <li><code>hott/02-contractible.rzk.md</code> - We require the notion of contractible types   and their data.</li> <li><code>hott/total-space.md</code> \u2014 We rely on   <code>is-equiv-projection-contractible-fibers</code> and   <code>projection-total-type</code> in the proof of Theorem 5.5.</li> <li><code>02-simplicial-type-theory.rzk.md</code> \u2014 We rely on definitions of simplicies and   their subshapes.</li> <li><code>03-extension-types.rzk.md</code> \u2014 We use the fubini theorem and extension   extensionality.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume weakextext : WeakExtExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#hom-types","title":"Hom types","text":"<p>Extension types are used to define the type of arrows between fixed terms:</p> <p> x y </p> RS17, Definition 5.1<pre><code>#def hom\n( A : U)\n( x y : A)\n  : U\n  :=\n( t : \u0394\u00b9) \u2192\n    A [ t \u2261 0\u2082 \u21a6 x ,  -- the left endpoint is exactly x\n        t \u2261 1\u2082 \u21a6 y]   -- the right endpoint is exactly y\n</code></pre> <p>For each <code>a : A</code>, the total types of the representables <code>\\ z \u2192 hom A a z</code> and <code>\\ z \u2192 hom A z a</code> are called the coslice and slice, respectively.</p> <pre><code>#def coslice\n( A : U)\n( a : A)\n  : U\n  := \u03a3 ( z : A) , (hom A a z)\n#def slice\n( A : U)\n( a : A)\n  : U\n  := \u03a3 (z : A) , (hom A z a)\n</code></pre> <p>The types <code>coslice A a</code> and <code>slice A a</code> are functorial in <code>A</code> in the following sense:</p> <pre><code>#def coslice-fun\n(A B : U)\n(f : A \u2192 B)\n(a : A)\n  : coslice A a \u2192 coslice B (f a)\n  :=\n    \\ (a', g) \u2192 (f a', \\ t \u2192 f (g t))\n#def slice-fun\n(A B : U)\n(f : A \u2192 B)\n(a : A)\n  : slice A a \u2192 slice B (f a)\n  :=\n    \\ (a', g) \u2192 (f a', \\ t \u2192 f (g t))\n</code></pre> <p>Slices and coslices can also be defined directly as extension types:</p> <pre><code>#section coslice-as-extension-type\n#variable A : U\n#variable a : A\n#def coslice'\n  : U\n  := ( t : \u0394\u00b9) \u2192 A [t \u2261 0\u2082 \u21a6 a]\n#def coslice'-coslice\n  : coslice A a \u2192 coslice'\n  := \\ (_, f) \u2192 f\n#def coslice-coslice'\n  : coslice' \u2192 coslice A a\n  := \\ f \u2192 ( f 1\u2082 , \\ t \u2192 f t) -- does not typecheck after \u03b7-reduction\n#def is-id-coslice-coslice'-coslice\n  ( (a', f) : coslice A a)\n  : ( coslice-coslice' ( coslice'-coslice (a', f)) = (a', f))\n  :=\n    eq-pair A (hom A a)\n      ( coslice-coslice' ( coslice'-coslice (a', f))) (a', f)\n      (refl, refl)\n#def is-id-coslice'-coslice-coslice'\n( f : coslice')\n  : ( coslice'-coslice ( coslice-coslice' f) = f)\n  :=\nrefl\n#def is-equiv-coslice'-coslice\n  : is-equiv (coslice A a) coslice' coslice'-coslice\n  :=\n    ( ( coslice-coslice', is-id-coslice-coslice'-coslice),\n      ( coslice-coslice', is-id-coslice'-coslice-coslice')\n    )\n#def is-equiv-coslice-coslice'\n  : is-equiv coslice' (coslice A a)  coslice-coslice'\n  :=\n    ( ( coslice'-coslice, is-id-coslice'-coslice-coslice'),\n      ( coslice'-coslice, is-id-coslice-coslice'-coslice)\n    )\n#end coslice-as-extension-type\n#section slice-as-extension-type\n#variable A : U\n#variable a : A\n#def slice'\n  : U\n  := ( t : \u0394\u00b9) \u2192 A[t \u2261 1\u2082 \u21a6 a]\n#def slice'-slice\n  : slice A a \u2192 slice'\n  := \\ (_, f) \u2192 f\n#def slice-slice'\n  : slice' \u2192 slice A a\n  := \\ f \u2192 ( f 0\u2082 , \\ t \u2192 f t) -- does not typecheck after \u03b7-reduction\n#def is-id-slice-slice'-slice\n  ( (a', f) : slice A a)\n  : ( slice-slice' ( slice'-slice (a', f)) = (a', f))\n  :=\n    eq-pair A (\\ a' \u2192 hom A a' a)\n      ( slice-slice' ( slice'-slice (a', f))) (a', f)\n      (refl, refl)\n#def is-id-slice'-slice-slice'\n( f : slice')\n  : ( slice'-slice ( slice-slice' f) = f)\n  :=\nrefl\n#def is-equiv-slice'-slice\n  : is-equiv (slice A a) slice' slice'-slice\n  :=\n    ( ( slice-slice', is-id-slice-slice'-slice),\n      ( slice-slice', is-id-slice'-slice-slice')\n    )\n#def is-equiv-slice-slice'\n  : is-equiv slice' (slice A a)  slice-slice'\n  :=\n    ( ( slice'-slice, is-id-slice'-slice-slice'),\n      ( slice'-slice, is-id-slice-slice'-slice)\n    )\n#end slice-as-extension-type\n</code></pre> <p>Extension types are also used to define the type of commutative triangles:</p> <p> x y z f g h </p> RS17, Definition 5.2<pre><code>#def hom2\n( A : U)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n( h : hom A x z)\n  : U\n  :=\n    ( (t\u2081 , t\u2082) : \u0394\u00b2) \u2192\n    A [ t\u2082 \u2261 0\u2082 \u21a6 f t\u2081 ,  -- the top edge is exactly `f`,\n        t\u2081 \u2261 1\u2082 \u21a6 g t\u2082 ,  -- the right edge is exactly `g`, and\n        t\u2082 \u2261 t\u2081 \u21a6 h t\u2082]   -- the diagonal is exactly `h`\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#arrow-types","title":"Arrow types","text":"<p>We define the arrow type:</p> <pre><code>#def arr\n( A : U)\n  : U\n  := \u0394\u00b9 \u2192 A\n</code></pre> <p>For later convenience we give an alternative characterizations of the arrow type.</p> <pre><code>#def fibered-arr\n( A : U)\n  : U\n  := \u03a3 (x : A) , (\u03a3 (y : A) , hom A x y)\n#def fibered-arr-free-arr\n( A : U)\n  : arr A \u2192 fibered-arr A\n  := \\ k \u2192 (k 0\u2082 , (k 1\u2082 , k))\n#def is-equiv-fibered-arr-free-arr\n( A : U)\n  : is-equiv (arr A) (fibered-arr A) (fibered-arr-free-arr A)\n  :=\n    ( ( (\\ (_ , (_ , f)) \u2192 f) , (\\ _ \u2192 refl))\n    , ( (\\ (_ , (_ , f)) \u2192 f) , (\\ _ \u2192 refl)))\n#def equiv-fibered-arr-free-arr\n( A : U)\n  : Equiv (arr A) (fibered-arr A)\n  := (fibered-arr-free-arr A , is-equiv-fibered-arr-free-arr A)\n</code></pre> <p>And the corresponding uncurried version.</p> <pre><code>#def fibered-arr'\n( A : U)\n  : U\n  :=\n\u03a3 ((a,b) : product A A), hom A a b\n#def fibered-arr-free-arr'\n( A : U)\n  : arr A \u2192 fibered-arr' A\n  := \\ \u03c3 \u2192 ((\u03c3 0\u2082 , \u03c3 1\u2082) , \u03c3)\n#def is-equiv-fibered-arr-free-arr'\n( A : U)\n  : is-equiv (arr A) (fibered-arr' A) (fibered-arr-free-arr' A)\n  :=\n    ( ( (\\ ((_ , _) , \u03c3) \u2192 \u03c3) , (\\ _ \u2192 refl))\n    , ( (\\ ((_ , _) , \u03c3) \u2192 \u03c3) , (\\ _ \u2192 refl)))\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#the-segal-condition","title":"The Segal condition","text":"<p>A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites.</p> RS17, Definition 5.3<pre><code>#def is-segal\n( A : U)\n  : U\n  :=\n(x : A) \u2192 (y : A) \u2192 (z : A) \u2192\n(f : hom A x y) \u2192 (g : hom A y z) \u2192\n    is-contr (\u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n</code></pre> <p>Segal types have a composition functor and witnesses to the composition relation. Composition is written in diagrammatic order to match the order of arguments in <code>is-segal</code>.</p> <pre><code>#def comp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : hom A x z\n  := first (first (is-segal-A x y z f g))\n#def witness-comp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : hom2 A x y z f g (comp-is-segal A is-segal-A x y z f g)\n  := second (first (is-segal-A x y z f g))\n</code></pre> <p>Composition in a Segal type is unique in the following sense. If there is a witness that an arrow \\(h\\) is a composite of \\(f\\) and \\(g\\), then the specified composite equals \\(h\\).</p> <p> x y z f g h \u03b1 = x y z f g comp-is-segal witness-comp-is-segal </p> <pre><code>#def uniqueness-comp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n( h : hom A x z)\n( alpha : hom2 A x y z f g h)\n  : ( comp-is-segal A is-segal-A x y z f g) = h\n  :=\n    first-path-\u03a3\n      ( hom A x z)\n      ( hom2 A x y z f g)\n      ( comp-is-segal A is-segal-A x y z f g ,\n        witness-comp-is-segal A is-segal-A x y z f g)\n      ( h , alpha)\n( homotopy-contraction\n        ( \u03a3 (k : hom A x z) , (hom2 A x y z f g k))\n        ( is-segal-A x y z f g)\n        ( h , alpha))\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#characterizing-segal-types","title":"Characterizing Segal types","text":"<p>Our aim is to prove that a type is Segal if and only if the <code>horn-restriction</code> map, defined below, is an equivalence.</p> <p> x y z f g </p> <p>A pair of composable arrows form a horn.</p> <pre><code>#def horn\n( A : U)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : \u039b \u2192 A\n  :=\n    \\ (t , s) \u2192\nrecOR\n      ( s \u2261 0\u2082 \u21a6 f t ,\n        t \u2261 1\u2082 \u21a6 g s)\n</code></pre> <p>The underlying horn of a simplex:</p> <pre><code>#def horn-restriction\n( A : U)\n  : (\u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A)\n  := \\ f t \u2192 f t\n</code></pre> <p>This provides an alternate definition of Segal types as types which are local for the inclusion <code>\u039b \u2282 \u0394\u00b9</code>.</p> <pre><code>#def is-local-horn-inclusion\n  : U \u2192 U\n  := is-local-type (2 \u00d7 2) \u0394\u00b2 (\\ t \u2192 \u039b t)\n#def unpack-is-local-horn-inclusion\n( A : U)\n  : is-local-horn-inclusion A = is-equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A) (horn-restriction A)\n  := refl\n</code></pre> <p>Now we prove this definition is equivalent to the original one. Here, we prove the equivalence used in [RS17, Theorem 5.5]. However, we do this by constructing the equivalence directly, instead of using a composition of equivalences, as it is easier to write down and it computes better (we can use refl for the witnesses of the equivalence).</p> <pre><code>#def compositions-are-horn-fillings\n( A : U)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : Equiv\n( \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n( (t : \u0394\u00b2) \u2192 A [\u039b t \u21a6 horn A x y z f g t])\n  :=\n    ( \\ hh t \u2192 (second hh) t ,\n      ( ( \\ k \u2192 (\\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s)) ,\n\\ hh \u2192 refl) ,\n        ( \\ k \u2192 (\\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s)) ,\n\\ hh \u2192 refl)))\n#def equiv-horn-restriction\n( A : U)\n  : Equiv\n    ( \u0394\u00b2 \u2192 A)\n( \u03a3 ( k : \u039b \u2192 A) ,\n( \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n            ( hom2 A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n              ( h))))\n  :=\n    ( \\ k \u2192\n      ( ( \\ t \u2192 k t) ,\n        ( \\ t \u2192 k (t , t) , \\ t \u2192 k t)) ,\n      ( ( \\ khh t \u2192 (second (second khh)) t , \\ k \u2192 refl) ,\n        ( \\ khh t \u2192 (second (second khh)) t , \\ k \u2192 refl)))\n</code></pre> RS17, Theorem 5.5 (the hard direction)<pre><code>#def equiv-horn-restriction-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n  : Equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A)\n  :=\n    equiv-comp\n      ( \u0394\u00b2 \u2192 A)\n( \u03a3 ( k : \u039b \u2192 A) ,\n( \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n              ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n                ( h))))\n      ( \u039b \u2192 A)\n      ( equiv-horn-restriction A)\n      ( projection-total-type\n        ( \u039b \u2192 A)\n( \\ k \u2192\n          \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n            ( hom2 A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n              ( h))) ,\n      ( is-equiv-projection-contractible-fibers\n          ( \u039b \u2192 A)\n( \\ k \u2192\n            \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n              ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n                ( h)))\n          ( \\ k \u2192\n            is-segal-A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t)))))\n</code></pre> <p>We verify that the mapping in <code>Segal-equiv-horn-restriction A is-segal-A</code> is exactly <code>horn-restriction A</code>.</p> <pre><code>#def test-equiv-horn-restriction-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n  : (first (equiv-horn-restriction-is-segal A is-segal-A)) = (horn-restriction A)\n  := refl\n</code></pre> Segal types are types that are local at the horn inclusion<pre><code>#def is-local-horn-inclusion-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n  : is-local-horn-inclusion A\n  := second (equiv-horn-restriction-is-segal A is-segal-A)\n</code></pre> Types that are local at the horn inclusion are Segal types<pre><code>#def is-segal-is-local-horn-inclusion\n( A : U)\n( is-local-horn-inclusion-A : is-local-horn-inclusion A)\n  : is-segal A\n  :=\n\\ x y z f g \u2192\n    contractible-fibers-is-equiv-projection\n      ( \u039b \u2192 A)\n( \\ k \u2192\n        \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n          ( hom2 A\n            ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n            ( \\ t \u2192 k (t , 0\u2082))\n            ( \\ t \u2192 k (1\u2082 , t))\n            ( h)))\n( second\n        ( equiv-comp\n          ( \u03a3 ( k : \u039b \u2192 A) ,\n\u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n              ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082))\n                ( \\ t \u2192 k (1\u2082 , t))\n                ( h)))\n          ( \u0394\u00b2 \u2192 A)\n          ( \u039b  \u2192 A)\n          ( inv-equiv\n            ( \u0394\u00b2 \u2192 A)\n( \u03a3 ( k : \u039b \u2192 A) ,\n\u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n                ( hom2 A\n                  ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                  ( \\ t \u2192 k (t , 0\u2082))\n                  ( \\ t \u2192 k (1\u2082 , t))\n                  ( h)))\n            ( equiv-horn-restriction A))\n          ( horn-restriction A , is-local-horn-inclusion-A)))\n      ( horn A x y z f g)\n</code></pre> <p>We have now proven that both notions of Segal types are logically equivalent.</p> RS17, Theorem 5.5<pre><code>#def is-segal-iff-is-local-horn-inclusion\n( A : U)\n  : iff (is-segal A) (is-local-horn-inclusion A)\n  := (is-local-horn-inclusion-is-segal A , is-segal-is-local-horn-inclusion A)\n</code></pre> <p>Similarly, Segal types are characterized by having unique extensions along <code>\u039b \u2282 \u0394\u00b2</code>.</p> <pre><code>#def is-segal-has-unique-inner-extensions\n( A : U)\n( has-inner-ue-A : has-unique-extensions (2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t) A)\n  : is-segal A\n  :=\n    is-segal-is-local-horn-inclusion A\n    ( is-local-type-has-unique-extensions (2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t) A\n      has-inner-ue-A)\n#def has-unique-inner-extensions-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n  : has-unique-extensions (2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t) A\n  :=\n    has-unique-extensions-is-local-type (2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t) A\n    ( is-local-horn-inclusion-is-segal A is-segal-A)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#segal-function-and-extension-types","title":"Segal function and extension types","text":"<p>Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. For instance if \\(X\\) is a type and \\(A : X \u2192 U\\) is such that \\(A x\\) is a Segal type for all \\(x\\) then \\((x : X) \u2192 A x\\) is a Segal type.</p> RS17, Corollary 5.6(i)<pre><code>#def is-local-horn-inclusion-function-type uses (funext)\n( X : U)\n( A : X \u2192 U)\n( fiberwise-is-segal-A : (x : X) \u2192 is-local-horn-inclusion (A x))\n  : is-local-horn-inclusion ((x : X) \u2192 A x)\n  :=\n    is-equiv-triple-comp\n( \u0394\u00b2 \u2192 ((x : X) \u2192 A x))\n( (x : X) \u2192 \u0394\u00b2 \u2192 A x)\n( (x : X) \u2192 \u039b \u2192 A x)\n( \u039b \u2192 ((x : X) \u2192 A x))\n      ( \\ g x t \u2192 g t x) -- first equivalence\n      ( second (flip-ext-fun\n        ( 2 \u00d7 2)\n        ( \u0394\u00b2)\n        ( \\ t \u2192 BOT)\n        ( X)\n        ( \\ t \u2192 A)\n        ( \\ t \u2192 recBOT)))\n      ( \\ h x t \u2192 h x t) -- second equivalence\n      ( second (equiv-function-equiv-family\n        ( funext)\n        ( X)\n        ( \\ x \u2192 (\u0394\u00b2 \u2192 A x))\n        ( \\ x \u2192 (\u039b \u2192 A x))\n        ( \\ x \u2192 (horn-restriction (A x) , fiberwise-is-segal-A x))))\n      ( \\ h t x \u2192 (h x) t) -- third equivalence\n      ( second (flip-ext-fun-inv\n        ( 2 \u00d7 2)\n        ( \u039b)\n        ( \\ t \u2192 BOT)\n        ( X)\n        ( \\ t \u2192 A)\n        ( \\ t \u2192 recBOT)))\n#def is-segal-function-type uses (funext)\n( X : U)\n( A : X \u2192 U)\n( fiberwise-is-segal-A : (x : X) \u2192 is-segal (A x))\n  : is-segal ((x : X) \u2192 A x)\n  :=\n    is-segal-is-local-horn-inclusion\n( (x : X) \u2192 A x)\n      ( is-local-horn-inclusion-function-type\n        ( X) (A)\n        ( \\ x \u2192 is-local-horn-inclusion-is-segal (A x)(fiberwise-is-segal-A x)))\n</code></pre> <p>If \\(X\\) is a shape and \\(A : X \u2192 U\\) is such that \\(A x\\) is a Segal type for all \\(x\\) then \\((x : X) \u2192 A x\\) is a Segal type.</p> RS17, Corollary 5.6(ii)<pre><code>#def is-local-horn-inclusion-extension-type uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( fiberwise-is-segal-A : (s : \u03c8) \u2192 is-local-horn-inclusion (A s))\n  : is-local-horn-inclusion ((s : \u03c8) \u2192 A s)\n  :=\n    is-equiv-triple-comp\n( \u0394\u00b2 \u2192 (s : \u03c8) \u2192 A s)\n( (s : \u03c8) \u2192 \u0394\u00b2 \u2192 A s)\n( (s : \u03c8) \u2192 \u039b \u2192 A s)\n( \u039b \u2192 (s : \u03c8) \u2192 A s)\n      ( \\ g s t \u2192 g t s)  -- first equivalence\n      ( second\n        ( fubini\n          ( 2 \u00d7 2)\n          ( I)\n          ( \u0394\u00b2)\n          ( \\ t \u2192 BOT)\n          ( \u03c8)\n          ( \\ s \u2192 BOT)\n          ( \\ t s \u2192 A s)\n          ( \\ u \u2192 recBOT)))\n      ( \\ h s t \u2192 h s t) -- second equivalence\n      ( second (equiv-extensions-BOT-equiv extext I \u03c8\n        ( \\ s \u2192 \u0394\u00b2 \u2192 A s)\n        ( \\ s \u2192 \u039b \u2192 A s)\n        ( \\ s \u2192 (horn-restriction (A s) , fiberwise-is-segal-A s))))\n      ( \\ h t s \u2192 (h s) t) -- third equivalence\n      ( second\n        ( fubini\n          ( I)\n          ( 2 \u00d7 2)\n          ( \u03c8)\n          ( \\ s \u2192 BOT)\n          ( \u039b)\n          ( \\ t \u2192 BOT)\n          ( \\ s t \u2192 A s)\n          ( \\ u \u2192 recBOT)))\n#def is-segal-extension-type uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( fiberwise-is-segal-A : (s : \u03c8) \u2192 is-segal (A s))\n  : is-segal ((s : \u03c8) \u2192 A s)\n  :=\n    is-segal-is-local-horn-inclusion\n( (s : \u03c8) \u2192 A s)\n      ( is-local-horn-inclusion-extension-type\n        ( I) (\u03c8) (A)\n        ( \\ s \u2192 is-local-horn-inclusion-is-segal (A s)(fiberwise-is-segal-A s)))\n</code></pre> <p>In particular, the arrow type of a Segal type is Segal.</p> RS17, Corollary 5.6(ii), special case for locality at the horn inclusion<pre><code>#def is-local-horn-inclusion-arr uses (extext)\n( A : U)\n( is-segal-A : is-local-horn-inclusion A)\n  : is-local-horn-inclusion (arr A)\n  :=\n    is-local-horn-inclusion-extension-type\n      ( 2)\n      ( \u0394\u00b9)\n      ( \\ _ \u2192 A)\n      ( \\ _ \u2192 is-segal-A)\n</code></pre> RS17, Corollary 5.6(ii), special case for the Segal condition<pre><code>#def is-segal-arr uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n  : is-segal (arr A)\n  :=\n    is-segal-extension-type\n      ( 2)\n      ( \u0394\u00b9)\n      ( \\ _ \u2192 A)\n      ( \\ _ \u2192 is-segal-A)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#identity","title":"Identity","text":"<p>All types have identity arrows and witnesses to the identity composition law.</p> <p> x x x </p> RS17, Definition 5.7<pre><code>#def id-hom\n( A : U)\n( x : A)\n  : hom A x x\n  := \\ t \u2192 x\n</code></pre> <p>Witness for the right identity law:</p> <p> x y y f y f f </p> RS17, Proposition 5.8a<pre><code>#def comp-id-witness\n( A : U)\n( x y : A)\n( f : hom A x y)\n  : hom2 A x y y f (id-hom A y) f\n  := \\ (t , s) \u2192 f t\n</code></pre> <p>Witness for the left identity law:</p> <p> x x y x f f f </p> RS17, Proposition 5.8b<pre><code>#def id-comp-witness\n( A : U)\n( x y : A)\n( f : hom A x y)\n  : hom2 A x x y (id-hom A x) f f\n  := \\ (t , s) \u2192 f s\n</code></pre> <p>In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types.</p> If A is Segal then the right unit law holds<pre><code>#def comp-id-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : ( comp-is-segal A is-segal-A x y y f (id-hom A y)) = f\n  :=\n    uniqueness-comp-is-segal\n      ( A)\n      ( is-segal-A)\n      ( x) (y) (y)\n      ( f)\n      ( id-hom A y)\n      ( f)\n      ( comp-id-witness A x y f)\n</code></pre> If A is Segal then the left unit law holds<pre><code>#def id-comp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : (comp-is-segal A is-segal-A x x y (id-hom A x) f) =_{hom A x y} f\n  :=\n    uniqueness-comp-is-segal\n      ( A)\n      ( is-segal-A)\n      ( x) (x) (y)\n      ( id-hom A x)\n      ( f)\n      ( f)\n      ( id-comp-witness A x y f)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#associativity","title":"Associativity","text":"<p>We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type.</p> <p> \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#def unfolding-square\n( A : U)\n( triangle : \u0394\u00b2 \u2192 A)\n  : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A\n  :=\n    \\ (t , s) \u2192\nrecOR\n      ( t \u2264 s \u21a6 triangle (s , t) ,\n        s \u2264 t \u21a6 triangle (t , s))\n</code></pre> <p>For use in the proof of associativity:</p> <p> x y z y f g comp-is-segal g f </p> <pre><code>#def witness-square-comp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A\n  := unfolding-square A (witness-comp-is-segal A is-segal-A x y z f g)\n</code></pre> <p>The <code>witness-square-comp-is-segal</code> as an arrow in the arrow type:</p> <p> x y z y f g </p> <pre><code>#def arr-in-arr-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : hom (arr A) f g\n  := \\ t s \u2192 witness-square-comp-is-segal A is-segal-A x y z f g (t , s)\n</code></pre> <p> w x x y y z f g h </p> <pre><code>#def witness-asociative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : hom2 (arr A) f g h\n      ( arr-in-arr-is-segal A is-segal-A w x y f g)\n      ( arr-in-arr-is-segal A is-segal-A x y z g h)\n      ( comp-is-segal (arr A) (is-segal-arr A is-segal-A) f g h\n        ( arr-in-arr-is-segal A is-segal-A w x y f g)\n        ( arr-in-arr-is-segal A is-segal-A x y z g h))\n  :=\n    witness-comp-is-segal\n      ( arr A)\n      ( is-segal-arr A is-segal-A)\n      ( f) ( g) ( h)\n      ( arr-in-arr-is-segal A is-segal-A w x y f g)\n      ( arr-in-arr-is-segal A is-segal-A x y z g h)\n</code></pre> <p> w x y z g f h </p> <p>The <code>witness-associative-is-segal</code> curries to define a diagram \\(\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A\\). The <code>tetrahedron-associative-is-segal</code> is extracted via the middle-simplex map \\(((t , s) , r) \u21a6 ((t , r) , s)\\) from \\(\u0394\u00b3\\) to \\(\u0394\u00b2\u00d7\u0394\u00b9\\).</p> <pre><code>#def tetrahedron-associative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : \u0394\u00b3 \u2192 A\n  :=\n    \\ ((t , s) , r) \u2192\n    (witness-asociative-is-segal A is-segal-A w x y z f g h) (t , r) s\n</code></pre> <p> w x y z g f h </p> <p>The diagonal composite of three arrows extracted from the <code>tetrahedron-associative-is-segal</code>.</p> <pre><code>#def triple-comp-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : hom A w z\n  :=\n\\ t \u2192\n    tetrahedron-associative-is-segal A is-segal-A w x y z f g h\n      ( (t , t) , t)\n</code></pre> <p> w x y z g f h </p> <pre><code>#def left-witness-asociative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : hom2 A w y z\n    (comp-is-segal A is-segal-A w x y f g)\n    h\n    (triple-comp-is-segal A is-segal-A w x y z f g h)\n  :=\n    \\ (t , s) \u2192\n    tetrahedron-associative-is-segal A is-segal-A w x y z f g h\n      ( (t , t) , s)\n</code></pre> <p>The front face:</p> <p> w x y z g f h </p> <pre><code>#def right-witness-asociative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : hom2 A w x z\n    ( f)\n    ( comp-is-segal A is-segal-A x y z g h)\n    ( triple-comp-is-segal A is-segal-A w x y z f g h)\n  :=\n    \\ (t , s) \u2192\n    tetrahedron-associative-is-segal A is-segal-A w x y z f g h\n      ( (t , s) , s)\n</code></pre> <pre><code>#def left-associative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) =\n    ( triple-comp-is-segal A is-segal-A w x y z f g h)\n  :=\n    uniqueness-comp-is-segal\n      A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h\n      ( triple-comp-is-segal A is-segal-A w x y z f g h)\n      ( left-witness-asociative-is-segal A is-segal-A w x y z f g h)\n#def right-associative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) =\n    ( triple-comp-is-segal A is-segal-A w x y z f g h)\n  :=\n    uniqueness-comp-is-segal\n      ( A) (is-segal-A) (w) (x) (z) (f) (comp-is-segal A is-segal-A x y z g h)\n      ( triple-comp-is-segal A is-segal-A w x y z f g h)\n      ( right-witness-asociative-is-segal A is-segal-A w x y z f g h)\n</code></pre> <p>We conclude that Segal composition is associative.</p> RS17, Proposition 5.9<pre><code>#def associative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) =\n    ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h))\n  :=\n    zig-zag-concat\n    ( hom A w z)\n    ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h)\n    ( triple-comp-is-segal A is-segal-A w x y z f g h)\n    ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h))\n    ( left-associative-is-segal A is-segal-A w x y z f g h)\n    ( right-associative-is-segal A is-segal-A w x y z f g h)\n#def rev-associative-is-segal uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( w x y z : A)\n( f : hom A w x)\n( g : hom A x y)\n( h : hom A y z)\n  : ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) =\n    ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h)\n  :=\n    rev (hom A w z)\n    ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h)\n    ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h))\n    ( associative-is-segal A is-segal-A w x y z f g h)\n#def postcomp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : (z : A) \u2192 (hom A z x) \u2192 (hom A z y)\n  := \\ z g \u2192 comp-is-segal A is-segal-A z x y g f\n#def precomp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : (z : A) \u2192 (hom A y z) \u2192 (hom A x z)\n  := \\ z \u2192 comp-is-segal A is-segal-A x y z f\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#homotopies","title":"Homotopies","text":"<p>We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow.</p> <pre><code>#def map-hom2-homotopy\n( A : U)\n( x y : A)\n( f g : hom A x y)\n  : (f = g) \u2192 (hom2 A x x y (id-hom A x) f g)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192 (hom2 A x x y (id-hom A x) f g'))\n      ( id-comp-witness A x y f)\n      ( g)\n#def map-total-hom2-homotopy\n( A : U)\n( x y : A)\n( f : hom A x y)\n  : ( \u03a3 (g : hom A x y) , (f = g)) \u2192\n( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g))\n  := \\ (g , p) \u2192 (g , map-hom2-homotopy A x y f g p)\n#def is-equiv-map-total-hom2-homotopy-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : is-equiv\n( \u03a3 (g : hom A x y) , f = g)\n( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g))\n      ( map-total-hom2-homotopy A x y f)\n  :=\n    is-equiv-are-contr\n( \u03a3 (g : hom A x y) , (f = g))\n( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g))\n      ( is-contr-based-paths (hom A x y) f)\n      ( is-segal-A x x y (id-hom A x) f)\n      ( map-total-hom2-homotopy A x y f)\n</code></pre> RS17, Proposition 5.10<pre><code>#def equiv-homotopy-hom2-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f h : hom A x y)\n  : Equiv (f = h) (hom2 A x x y (id-hom A x) f h)\n  :=\n    ( ( map-hom2-homotopy A x y f h) ,\n      ( is-equiv-fiberwise-is-equiv-total\n        ( hom A x y)\n        ( \\ k \u2192 (f = k))\n        ( \\ k \u2192 (hom2 A x x y (id-hom A x) f k))\n        ( map-hom2-homotopy A x y f)\n        ( is-equiv-map-total-hom2-homotopy-is-segal A is-segal-A x y f)\n        ( h)))\n</code></pre> <p>A dual notion of homotopy can be defined similarly.</p> <pre><code>#def map-hom2-homotopy'\n( A : U)\n( x y : A)\n( f g : hom A x y)\n( p : f = g)\n  : (hom2 A x y y f (id-hom A y) g)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192 (hom2 A x y y f (id-hom A y) g'))\n      ( comp-id-witness A x y f)\n      ( g)\n      ( p)\n#def map-total-hom2-homotopy'\n( A : U)\n( x y : A)\n( f : hom A x y)\n  : ( \u03a3 (g : hom A x y) , (f = g)) \u2192\n( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g))\n  := \\ (g , p) \u2192 (g , map-hom2-homotopy' A x y f g p)\n#def is-equiv-map-total-hom2-homotopy'-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : is-equiv\n( \u03a3 (g : hom A x y) , f = g)\n( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g))\n      ( map-total-hom2-homotopy' A x y f)\n  :=\n    is-equiv-are-contr\n( \u03a3 (g : hom A x y) , (f = g))\n( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g))\n      ( is-contr-based-paths (hom A x y) f)\n      ( is-segal-A x y y f (id-hom A y))\n      ( map-total-hom2-homotopy' A x y f)\n</code></pre> RS17, Proposition 5.10<pre><code>#def equiv-homotopy-hom2'-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f h : hom A x y)\n  : Equiv (f = h) (hom2 A x y y f (id-hom A y) h)\n  :=\n    ( ( map-hom2-homotopy' A x y f h) ,\n      ( is-equiv-fiberwise-is-equiv-total\n        ( hom A x y)\n        ( \\ k \u2192 (f = k))\n        ( \\ k \u2192 (hom2 A x y y f (id-hom A y) k))\n        ( map-hom2-homotopy' A x y f)\n        ( is-equiv-map-total-hom2-homotopy'-is-segal A is-segal-A x y f)\n        ( h)))\n</code></pre> <p>More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary.</p> <pre><code>#def map-hom2-eq-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n( h : hom A x z)\n( p : (comp-is-segal A is-segal-A x y z f g) = h)\n  : ( hom2 A x y z f g h)\n  :=\n    ind-path\n      ( hom A x z)\n      ( comp-is-segal A is-segal-A x y z f g)\n      ( \\ h' p' \u2192 hom2 A x y z f g h')\n      ( witness-comp-is-segal A is-segal-A x y z f g)\n      ( h)\n      ( p)\n#def map-total-hom2-eq-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) \u2192\n( \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n  := \\ (h , p) \u2192 (h , map-hom2-eq-is-segal A is-segal-A x y z f g h p)\n#def is-equiv-map-total-hom2-eq-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : is-equiv\n( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h)\n( \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n      ( map-total-hom2-eq-is-segal A is-segal-A x y z f g)\n  :=\n    is-equiv-are-contr\n( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h)\n( \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n      ( is-contr-based-paths (hom A x z) (comp-is-segal A is-segal-A x y z f g))\n      ( is-segal-A x y z f g)\n      ( map-total-hom2-eq-is-segal A is-segal-A x y z f g)\n</code></pre> RS17, Proposition 5.12<pre><code>#def equiv-hom2-eq-comp-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n( k : hom A x z)\n  : Equiv ((comp-is-segal A is-segal-A x y z f g) = k) (hom2 A x y z f g k)\n  :=\n    ( ( map-hom2-eq-is-segal A is-segal-A x y z f g k) ,\n      ( is-equiv-fiberwise-is-equiv-total\n        ( hom A x z)\n        ( \\ m \u2192 (comp-is-segal A is-segal-A x y z f g) = m)\n        ( hom2 A x y z f g)\n        ( map-hom2-eq-is-segal A is-segal-A x y z f g)\n        ( is-equiv-map-total-hom2-eq-is-segal A is-segal-A x y z f g)\n        ( k)))\n</code></pre> <p>Homotopies form a congruence, meaning that homotopies are respected by composition:</p> RS17, Proposition 5.13<pre><code>#def congruence-homotopy-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f g : hom A x y)\n( h k : hom A y z)\n( p : f = g)\n( q : h = k)\n  : ( comp-is-segal A is-segal-A x y z f h) =\n    ( comp-is-segal A is-segal-A x y z g k)\n  :=\n    ind-path\n      ( hom A y z)\n      ( h)\n      ( \\ k' q' \u2192\n        ( comp-is-segal A is-segal-A x y z f h) =\n        ( comp-is-segal A is-segal-A x y z g k'))\n      ( ind-path\n        ( hom A x y)\n        ( f)\n        ( \\ g' p' \u2192\n          ( comp-is-segal A is-segal-A x y z f h) =\n          ( comp-is-segal A is-segal-A x y z g' h))\n        ( refl)\n        ( g)\n        ( p))\n      ( k)\n      ( q)\n</code></pre> <p>As a special case of the above:</p> <pre><code>#def postwhisker-homotopy-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f g : hom A x y)\n( h : hom A y z)\n( p : f = g)\n  : ( comp-is-segal A is-segal-A x y z f h) = (comp-is-segal A is-segal-A x y z g h)\n  := congruence-homotopy-is-segal A is-segal-A x y z f g h h p refl\n</code></pre> <p>As a special case of the above:</p> <pre><code>#def prewhisker-homotopy-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( w x y : A)\n( k : hom A w x)\n( f g : hom A x y)\n( p : f = g)\n  : ( comp-is-segal A is-segal-A w x y k f) =\n    ( comp-is-segal A is-segal-A w x y k g)\n  := congruence-homotopy-is-segal A is-segal-A w x y k k f g refl p\n</code></pre> RS17, Proposition 5.14(a)<pre><code>#def compute-postwhisker-homotopy-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y z : A)\n( f g : hom A x y)\n( h : hom A y z)\n( p : f = g)\n  : ( postwhisker-homotopy-is-segal A is-segal-A x y z f g h p) =\n    ( ap (hom A x y) (hom A x z) f g (\\ k \u2192 comp-is-segal A is-segal-A x y z k h) p)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192\n        ( postwhisker-homotopy-is-segal A is-segal-A x y z f g' h p') =\n        ( ap\n          (hom A x y) (hom A x z)\n          (f) (g') (\\ k \u2192 comp-is-segal A is-segal-A x y z k h) (p')))\n      ( refl)\n      ( g)\n      ( p)\n</code></pre> RS17, Proposition 5.14(b)<pre><code>#def prewhisker-homotopy-is-ap-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( w x y : A)\n( k : hom A w x)\n( f g : hom A x y)\n( p : f = g)\n  : ( prewhisker-homotopy-is-segal A is-segal-A w x y k f g p) =\n    ( ap (hom A x y) (hom A w y) f g (comp-is-segal A is-segal-A w x y k) p)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192\n        ( prewhisker-homotopy-is-segal A is-segal-A w x y k f g' p') =\n        ( ap (hom A x y) (hom A w y) f g' (comp-is-segal A is-segal-A w x y k) p'))\n      ( refl)\n      ( g)\n      ( p)\n#section is-segal-Unit\n#def is-contr-\u0394\u00b2\u2192Unit uses (extext)\n  : is-contr (\u0394\u00b2 \u2192 Unit)\n  :=\n    ( \\ _ \u2192 unit ,\n\\ k \u2192\n      naiveextext-extext extext\n        ( 2 \u00d7 2) \u0394\u00b2 (\\ _ \u2192 BOT)\n        ( \\ _ \u2192 Unit) (\\ _ \u2192 recBOT)\n        ( \\ _ \u2192 unit) k\n        ( \\ _ \u2192 refl))\n#def is-segal-Unit uses (extext)\n  : is-segal Unit\n  :=\n\\ x y z f g \u2192\n    is-contr-is-retract-of-is-contr\n( \u03a3 (h : hom Unit x z) , (hom2 Unit x y z f g h))\n      ( \u0394\u00b2 \u2192 Unit)\n      ( ( \\ (_ , k) \u2192 k) ,\n        ( \\ k \u2192 ((\\ t \u2192 k (t , t)) , k) , \\ _ \u2192 refl))\n      ( is-contr-\u0394\u00b2\u2192Unit)\n#end is-segal-Unit\n</code></pre> <p> <p></p> <p>Interchange law</p> <pre><code>#section homotopy-interchange-law\n#variable A : U\n#variable is-segal-A : is-segal A\n#variables x y z : A\n#def statement-homotopy-interchange-law\n( f1 f2 f3 : hom A x y)\n( h1 h2 h3 : hom A y z)\n( p : f1 = f2)\n( q : f2 = f3)\n( p' : h1 = h2)\n( q' : h2 = h3)\n  : U\n  := congruence-homotopy-is-segal A is-segal-A x y z f1 f3 h1 h3\n      ( concat (hom A x y) f1 f2 f3 p q)\n      ( concat (hom A y z) h1 h2 h3 p' q') =\n    concat\n      ( hom A x z)\n      ( comp-is-segal A is-segal-A x y z f1 h1)\n      ( comp-is-segal A is-segal-A x y z f2 h2)\n      ( comp-is-segal A is-segal-A x y z f3 h3)\n      ( congruence-homotopy-is-segal A is-segal-A x y z f1 f2 h1 h2 p p')\n      ( congruence-homotopy-is-segal A is-segal-A x y z f2 f3 h2 h3 q q')\n</code></pre> RS17, Proposition 5.15<pre><code>#def homotopy-interchange-law\n( f1 f2 f3 : hom A x y)\n( h1 h2 h3 : hom A y z)\n( p : f1 = f2)\n( q : f2 = f3)\n( p' : h1 = h2)\n( q' : h2 = h3)\n  : statement-homotopy-interchange-law f1 f2 f3 h1 h2 h3 p q p' q'\n  := ind-path\n    ( hom A x y)\n    ( f2)\n    ( \\ f3 q -&gt; statement-homotopy-interchange-law f1 f2 f3 h1 h2 h3 p q p' q')\n    ( ind-path\n      ( hom A x y)\n      ( f1)\n      ( \\ f2 p -&gt; statement-homotopy-interchange-law f1 f2 f2 h1 h2 h3\n          p refl p' q')\n      ( ind-path\n        ( hom A y z)\n        ( h2)\n        ( \\ h3 q' -&gt; statement-homotopy-interchange-law f1 f1 f1 h1 h2 h3\nrefl refl p' q')\n        ( ind-path\n          ( hom A y z)\n          ( h1)\n          ( \\ h2 p' -&gt; statement-homotopy-interchange-law f1 f1 f1 h1 h2 h2\nrefl refl p' refl)\n          ( refl)\n          ( h2)\n          ( p'))\n        ( h3)\n        ( q'))\n      ( f2)\n      ( p))\n    ( f3)\n    ( q)\n#end homotopy-interchange-law\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#inner-anodyne-shape-inclusions","title":"Inner anodyne shape inclusions","text":"<p>An inner fibration is a map <code>\u03b1 : A' \u2192 A</code> which is right orthogonal to <code>\u039b \u2282 \u0394\u00b2</code>. This is the relative notion of a Segal type.</p> <pre><code>#def is-inner-fibration\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n  : U\n  := is-right-orthogonal-to-shape (2 \u00d7 2) \u0394\u00b2 (\\ t \u2192 \u039b t) A' A \u03b1\n</code></pre> <p>We say that a shape inclusion <code>\u03d5 \u2282 \u03c8</code> is inner anodyne if it is anodyne for <code>\u039b \u2282 \u0394\u00b2</code>, i.e., if every inner fibration <code>A' \u2192 A</code> is right orthogonal to <code>\u03d5 \u2282 \u03c8</code>.</p> <pre><code>#def is-inner-anodyne\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n  : U\n  := is-anodyne-for-shape (2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t) I \u03c8 \u03d5\n#def unpack-is-inner-anodyne\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n  : is-inner-anodyne I \u03c8 \u03d5\n  = ( (A' : U) \u2192 (A : U) \u2192 (\u03b1 : A' \u2192 A)\n    \u2192 is-inner-fibration A' A \u03b1\n    \u2192 is-right-orthogonal-to-shape I \u03c8 \u03d5 A' A \u03b1)\n  := refl\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#weak-inner-anodyne-shape-inclusions","title":"Weak inner anodyne shape inclusions","text":"<p>We say that a shape inclusion <code>\u03d5 \u2282 \u03c8</code> is weak inner anodyne if every Segal type <code>A</code> has unique extensions with respect to <code>\u03d5 \u2282 \u03c8</code>.</p> <p>This notion was just called \"anodyne\" in RS17.</p> RS17, Definition 5.19<pre><code>#def is-weak-inner-anodyne\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03a6 : \u03c8 \u2192 TOPE)\n  : U\n  := (A : U) \u2192 is-segal A \u2192 (h : \u03a6 \u2192 A) \u2192 is-contr ((t : \u03c8) \u2192 A[ \u03a6 t \u21a6 h t ])\n</code></pre> <p>Since Segal types are exactly those that have unique extensions with respect to <code>\u039b \u2282 \u0394\u00b2</code>, we see that weak inner anodyne is a special case of the general notion of weak anodyne introduced earlier.</p> <pre><code>#def is-weak-inner-anodyne-is-weak-anodyne-for-\u039b-\u0394\u00b2\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( is-wa-\u039b-\u0394\u00b2 : is-weak-anodyne-for-shape (2 \u00d7 2) \u0394\u00b2 (\\ t \u2192 \u039b t) I \u03c8 \u03d5)\n  : is-weak-inner-anodyne I \u03c8 \u03d5\n  :=\n\\ A is-segal-A \u2192\n      ( is-wa-\u039b-\u0394\u00b2 A (has-unique-inner-extensions-is-segal A is-segal-A))\n#def is-weak-anodyne-for-\u039b-\u0394\u00b2-is-weak-inner-anodyne\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( is-wia : is-weak-inner-anodyne I \u03c8 \u03d5)\n  : is-weak-anodyne-for-shape (2 \u00d7 2) \u0394\u00b2 (\\ t \u2192 \u039b t) I \u03c8 \u03d5\n  :=\n\\ A has-uie-A \u2192\n      ( is-wia A (is-segal-has-unique-inner-extensions A has-uie-A))\n</code></pre> <p>The shape inclusion <code>\u039b \u2282 \u0394\u00b2</code> is tautologically inner anodyne</p> <pre><code>#def is-weak-inner-anodyne-\u039b\u00b2\u2081\n  : is-weak-inner-anodyne (2 \u00d7 2) \u0394\u00b2 \u039b\u00b2\u2081\n  :=\n    is-weak-inner-anodyne-is-weak-anodyne-for-\u039b-\u0394\u00b2 (2 \u00d7 2) \u0394\u00b2 (\\ t \u2192 \u039b t)\n    ( is-weak-anodyne-for-self (2 \u00d7 2) \u0394\u00b2 (\\ t \u2192 \u039b t))\n</code></pre> <p>Weak inner anodyne shape inclusions are preserved under pushout product. This is the direct proof from RS17. One could also deduce it from the corresponding general statements about weak anodyne shape inclusions.</p> RS17, lemma 5.20<pre><code>#def is-weak-inner-anodyne-pushout-product-left-is-weak-inner-anodyne uses (weakextext)\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03a6 : \u03c8 \u2192 TOPE)\n( is-weak-inner-anodyne-\u03c8-\u03a6 : is-weak-inner-anodyne I \u03c8 \u03a6)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n  : is-weak-inner-anodyne (I \u00d7 J)\n      (\\ (t,s) \u2192 \u03c8 t \u2227 \u03b6 s)\n      (\\ (t,s) \u2192 (\u03a6 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s))\n  := \\ A is-segal-A h \u2192\n    is-contr-equiv-is-contr'\n      (((t,s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 A[(\u03a6 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 h (t,s)])\n( (s : \u03b6) \u2192 ((t : \u03c8) \u2192 A[ \u03a6 t \u21a6 h (t,s)])[ \u03c7 s \u21a6 \\ t \u2192 h (t, s)])\n      (uncurry-opcurry I J \u03c8 \u03a6 \u03b6 \u03c7 (\\ s t \u2192 A) h)\n      (weakextext\n        ( J)\n        ( \u03b6)\n        ( \u03c7)\n( \\ s \u2192 (t : \u03c8) \u2192 A[ \u03a6 t \u21a6 h (t,s)])\n        ( \\ s \u2192 is-weak-inner-anodyne-\u03c8-\u03a6 A is-segal-A (\\ t \u2192 h (t,s)))\n        ( \\ s t \u2192 h (t,s)))\n#def is-weak-inner-anodyne-pushout-product-right-is-weak-inner-anodyne uses (weakextext)\n( I J : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03a6 : \u03c8 \u2192 TOPE)\n( \u03b6 : J \u2192 TOPE)\n( \u03c7 : \u03b6 \u2192 TOPE)\n(is-weak-inner-anodyne-\u03b6-\u03c7 : is-weak-inner-anodyne J \u03b6 \u03c7)\n  : is-weak-inner-anodyne (I \u00d7 J)\n      (\\ (t,s) \u2192 \u03c8 t \u2227 \u03b6 s)\n      (\\ (t,s) \u2192 (\u03a6 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s))\n  := \\ A is-segal-A h \u2192\n    is-contr-equiv-is-contr\n( (t : \u03c8) \u2192 ((s : \u03b6) \u2192 A[ \u03c7 s \u21a6 h (t,s)])[ \u03a6 t \u21a6 \\ s \u2192 h (t, s)])\n      (((t,s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 A[(\u03a6 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 h (t,s)])\n      (curry-uncurry I J \u03c8 \u03a6 \u03b6 \u03c7 (\\ s t \u2192 A) h)\n      (weakextext\n        ( I)\n        ( \u03c8)\n        ( \u03a6)\n( \\ t \u2192 (s : \u03b6) \u2192 A[ \u03c7 s \u21a6 h (t,s)])\n        ( \\ t \u2192 is-weak-inner-anodyne-\u03b6-\u03c7 A is-segal-A (\\ s \u2192 h (t,s)))\n        ( \\ s t \u2192 h (s,t)))\n</code></pre> <p>The following argument from RS17 proves that <code>\u039b\u00b3\u2082 \u2282 \u0394\u00b3</code> is weakly inner anodyne. It should be easy to adapt it to prove that it is actually inner anodyne.</p> RS17, lemma 5.21<pre><code>#section retraction-\u039b\u00b3\u2082-\u0394\u00b3-pushout-product-\u039b\u00b2\u2081-\u0394\u00b2\n-- \u0394\u00b3\u00d7\u039b\u00b2\u2081 \u222a_{\u039b\u00b3\u2082\u00d7\u039b\u00b2\u2081} \u039b\u00b3\u2082\u00d7\u0394\u00b2\n#def pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081\n  : (\u0394\u00b3\u00d7\u0394\u00b2) \u2192 TOPE\n  := shape-pushout-prod (2 \u00d7 2 \u00d7 2) (2 \u00d7 2) \u0394\u00b3 \u039b\u00b3\u2082 \u0394\u00b2 \u039b\u00b2\u2081\n#variable A : U\n#variable h : \u039b\u00b3\u2082 \u2192 A\n#def h^\n  : pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081 \u2192 A\n  := \\ ( ((t1, t2), t3), (s1, s2) ) \u2192\nrecOR\n      ( s1 \u2264 t1 \u2227 t2 \u2264 s2 \u21a6 h ((t1, t2), t3),\n        t1 \u2264 s1 \u2227 t2 \u2264 s2 \u21a6 h ((s1, t2), t3),\n        s1 \u2264 t1 \u2227 t3 \u2264 s2 \u2227 s2 \u2264 t2 \u21a6 h ((t1, s2), t3),\n        t1 \u2264 s1 \u2227 t3 \u2264 s2 \u2227 s2 \u2264 t2 \u21a6 h ((s1, s2), t3),\n        s1 \u2264 t1 \u2227 s2 \u2264 t3 \u21a6 h ((t1, s2), s2),\n        t1 \u2264 s1 \u2227 s2 \u2264 t3 \u21a6 h ((s1, s2), s2))\n#def extend-against-\u039b\u00b3\u2082-\u0394\u00b3\n  : U\n  := (t : \u0394\u00b3) \u2192 A[ \u039b\u00b3\u2082 t \u21a6 h t ]\n#def extend-against-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 uses (h)\n  : U\n  := (x : \u0394\u00b3\u00d7\u0394\u00b2) \u2192 A[ pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081 x \u21a6 h^ x]\n#def retract-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 uses (A h)\n(f : extend-against-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2)\n  : extend-against-\u039b\u00b3\u2082-\u0394\u00b3\n  := \\ ((t1, t2), t3) \u2192 f ( ((t1, t2), t3), (t1, t2) )\n#def section-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 uses (A h)\n(g : (t : \u0394\u00b3) \u2192 A[ \u039b\u00b3\u2082 t \u21a6 h t ])\n  : (x : \u0394\u00b3\u00d7\u0394\u00b2) \u2192 A[ pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081 x \u21a6 h^ x]\n  :=\n    \\ ( ((t1, t2), t3), (s1, s2) ) \u2192\nrecOR\n      ( s1 \u2264 t1 \u2227 t2 \u2264 s2 \u21a6 g ((t1, t2), t3),\n        t1 \u2264 s1 \u2227 t2 \u2264 s2 \u21a6 g ((s1, t2), t3),\n        s1 \u2264 t1 \u2227 t3 \u2264 s2 \u2227 s2 \u2264 t2 \u21a6 g ((t1, s2), t3),\n        t1 \u2264 s1 \u2227 t3 \u2264 s2 \u2227 s2 \u2264 t2 \u21a6 g ((s1, s2), t3),\n        s1 \u2264 t1 \u2227 s2 \u2264 t3 \u21a6 g ((t1, s2), s2),\n        t1 \u2264 s1 \u2227 s2 \u2264 t3 \u21a6 g ((s1, s2), s2))\n#def homotopy-retraction-section-id-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 uses (A h)\n  : homotopy extend-against-\u039b\u00b3\u2082-\u0394\u00b3 extend-against-\u039b\u00b3\u2082-\u0394\u00b3\n    ( comp\n      ( extend-against-\u039b\u00b3\u2082-\u0394\u00b3)\n      ( extend-against-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2)\n      ( extend-against-\u039b\u00b3\u2082-\u0394\u00b3)\n      ( retract-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2)\n      ( section-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2))\n    ( identity extend-against-\u039b\u00b3\u2082-\u0394\u00b3)\n  := \\ t \u2192 refl\n#def is-retract-of-\u0394\u00b3-\u0394\u00b3\u00d7\u0394\u00b2 uses (A h)\n  : is-retract-of\n      extend-against-\u039b\u00b3\u2082-\u0394\u00b3\n      extend-against-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2\n  :=\n    ( section-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 ,\n      ( retract-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 ,\n        homotopy-retraction-section-id-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2))\n#end retraction-\u039b\u00b3\u2082-\u0394\u00b3-pushout-product-\u039b\u00b2\u2081-\u0394\u00b2\n#def is-weak-inner-anodyne-\u0394\u00b3-\u039b\u00b3\u2082 uses (weakextext)\n  : is-weak-inner-anodyne (2 \u00d7 2 \u00d7 2) \u0394\u00b3 \u039b\u00b3\u2082\n  :=\n\\ A is-segal-A h \u2192\n    is-contr-is-retract-of-is-contr\n      (extend-against-\u039b\u00b3\u2082-\u0394\u00b3 A h)\n      (extend-against-pushout-prod-\u039b\u00b3\u2082-\u039b\u00b2\u2081-\u0394\u00b3\u00d7\u0394\u00b2 A h)\n      (is-retract-of-\u0394\u00b3-\u0394\u00b3\u00d7\u0394\u00b2 A h)\n      (is-weak-inner-anodyne-pushout-product-right-is-weak-inner-anodyne\n        ( 2 \u00d7 2 \u00d7 2)\n        ( 2 \u00d7 2)\n        ( \u0394\u00b3)\n        ( \u039b\u00b3\u2082)\n        ( \u0394\u00b2)\n        ( \u039b\u00b2\u2081)\n        ( is-weak-inner-anodyne-\u039b\u00b2\u2081)\n        ( A)\n        ( is-segal-A)\n        ( h^ A h))\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#products-of-segal-types","title":"Products of Segal types","text":"<p>This is an additional section which describes morphisms in products of types as products of morphisms. It is implicitly stated in Proposition 8.21.</p> <pre><code>#section morphisms-of-products-is-products-of-morphisms\n#variables A B : U\n#variable p : ( product A B )\n#variable p' : ( product A B )\n#def morphism-in-product-to-product-of-morphism\n  : hom ( product A B ) p p' \u2192\n    product ( hom A ( first p ) ( first p' ) ) ( hom B ( second p ) ( second p' ) )\n  :=  \\ f \u2192 ( \\ ( t : \u0394\u00b9 ) \u2192 first ( f t ) , \\ ( t : \u0394\u00b9 ) \u2192 second ( f t ) )\n#def product-of-morphism-to-morphism-in-product\n  : product ( hom A ( first p ) ( first p' ) ) ( hom B ( second p ) ( second p' ) ) \u2192\n    hom ( product A B ) p p'\n  := \\ ( f , g ) ( t : \u0394\u00b9 ) \u2192 ( f t , g t )\n#def morphisms-in-product-to-product-of-morphism-to-morphism-in-product-is-id\n  : ( f :  product ( hom A ( first p ) ( first p' ) ) ( hom B ( second p ) ( second p' ) ) ) \u2192\n    ( morphism-in-product-to-product-of-morphism )\n    ( ( product-of-morphism-to-morphism-in-product )\n      f ) = f\n  := \\ f \u2192 refl\n#def product-of-morphism-to-morphisms-in-product-to-product-of-morphism-is-id\n  : ( f :  hom ( product A B ) p p' ) \u2192\n    ( product-of-morphism-to-morphism-in-product )\n    ( ( morphism-in-product-to-product-of-morphism )\n      f ) = f\n  := \\ f \u2192 refl\n#def morphism-in-product-equiv-product-of-morphism\n  : Equiv\n    ( hom ( product A B ) p p' )\n    ( product ( hom A ( first p ) ( first p' ) ) ( hom B ( second p ) ( second p' ) ) )\n  :=\n    ( ( morphism-in-product-to-product-of-morphism ) ,\n      ( ( ( product-of-morphism-to-morphism-in-product ) ,\n          ( product-of-morphism-to-morphisms-in-product-to-product-of-morphism-is-id ) ) ,\n        ( ( product-of-morphism-to-morphism-in-product ) ,\n          ( morphisms-in-product-to-product-of-morphism-to-morphism-in-product-is-id ) ) ) )\n#end morphisms-of-products-is-products-of-morphisms\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#fibers-of-maps-between-segal-types","title":"Fibers of maps between Segal types","text":"<p>For any map <code>f : A \u2192 B</code> between Segal types, each fiber <code>fib A B f b</code> is again a Segal type. This is an instance of a general statement about types with unique extensions for the shape inclusion <code>\u039b \u2282 \u0394\u00b2</code>.</p> <pre><code>#def is-fiberwise-segal-are-segal uses (extext)\n( A B : U)\n( f : A \u2192 B)\n( is-segal-A : is-segal A)\n( is-segal-B : is-segal B)\n( b : B)\n  : is-segal (fib A B f b)\n  :=\n    is-segal-has-unique-inner-extensions (fib A B f b)\n    ( has-fiberwise-unique-extensions-have-unique-extensions extext\n      ( 2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t) A B f\n      ( has-unique-inner-extensions-is-segal A is-segal-A)\n      ( has-unique-inner-extensions-is-segal B is-segal-B)\n      ( b))\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/","title":"The 2-category of Segal types","text":"<p>These formalisations correspond to Section 6 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>03-simplicial-type-theory.rzk.md</code> \u2014 We rely on definitions of simplicies and   their subshapes.</li> <li><code>04-extension-types.rzk.md</code> \u2014 We use extension extensionality.</li> <li><code>05-segal-types.rzk.md</code> - We use the notion of hom types.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#functors","title":"Functors","text":"<p>Functions between types induce an action on hom types, preserving sources and targets. The action is called <code>ap-hom</code> to avoid conflicting with <code>ap</code>.</p> RS17, Section 6.1<pre><code>#def ap-hom\n( A B : U)\n( F : A \u2192 B)\n( x y : A)\n( f : hom A x y)\n  : hom B (F x) (F y)\n  := \\ t \u2192 F (f t)\n#def ap-hom2\n( A B : U)\n( F : A \u2192 B)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n( h : hom A x z)\n(\u03b1 : hom2 A x y z f g h)\n  : hom2 B (F x) (F y) (F z)\n    ( ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h)\n  := \\ t \u2192 F (\u03b1 t)\n</code></pre> <p>Functions between types automatically preserve identity arrows. Preservation of identities follows from extension extensionality because these arrows are pointwise equal.</p> RS17, Proposition 6.1.a<pre><code>#def functors-pres-id uses (extext)\n( A B : U)\n( F : A \u2192 B)\n( x : A)\n  : ( ap-hom A B F x x (id-hom A x)) = (id-hom B (F x))\n  :=\n    naiveextext-extext\n      ( extext)\n      ( 2)\n      ( \u0394\u00b9)\n      ( \u2202\u0394\u00b9)\n      ( \\ t \u2192 B)\n      ( \\ t \u2192 recOR (t \u2261 0\u2082 \u21a6 F x , t \u2261 1\u2082 \u21a6 F x))\n      ( ap-hom A B F x x (id-hom A x))\n      ( id-hom B (F x))\n      ( \\ t \u2192 refl)\n</code></pre> <p>Preservation of composition requires the Segal hypothesis.</p> RS17, Proposition 6.1.b<pre><code>#def functors-pres-comp\n( A B : U)\n( is-segal-A : is-segal A)\n( is-segal-B : is-segal B)\n( F : A \u2192 B)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  :\n    ( comp-is-segal B is-segal-B\n      ( F x) (F y) (F z)\n      ( ap-hom A B F x y f)\n      ( ap-hom A B F y z g))\n    =\n    ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g))\n  :=\n    uniqueness-comp-is-segal B is-segal-B\n      ( F x) (F y) (F z)\n      ( ap-hom A B F x y f)\n      ( ap-hom A B F y z g)\n      ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g))\n      ( ap-hom2 A B F x y z f g\n        ( comp-is-segal A is-segal-A x y z f g)\n        ( witness-comp-is-segal A is-segal-A x y z f g))\n#def rev-functors-pres-comp\n( A B : U)\n( is-segal-A : is-segal A)\n( is-segal-B : is-segal B)\n( F : A \u2192 B)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  :\n    ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g))\n    =\n    ( comp-is-segal B is-segal-B\n      ( F x) (F y) (F z)\n      ( ap-hom A B F x y f)\n      ( ap-hom A B F y z g))\n  :=\n    rev (hom B (F x) (F z))\n    ( comp-is-segal B is-segal-B\n      ( F x) (F y) (F z)\n      ( ap-hom A B F x y f)\n      ( ap-hom A B F y z g))\n    ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g))\n    ( functors-pres-comp A B is-segal-A is-segal-B F x y z f g)\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformations","title":"Natural transformations","text":"<p>Given two simplicial maps <code>f g : (x : A) \u2192 B x</code> , a natural transformation from <code>f</code> to <code>g</code> is an arrow <code>\u03b7 : hom ((x : A) \u2192 B x) f g</code> between them.</p> RS17, Definition 6.2<pre><code>#def nat-trans\n( A : U)\n( B : A \u2192 U)\n( f g : (x : A) \u2192 (B x))\n  : U\n  := hom ((x : A) \u2192 (B x)) f g\n</code></pre> <p>Equivalently , natural transformations can be determined by their components , i.e. as a family of arrows <code>(x : A) \u2192 hom (B x) (f x) (g x)</code>.</p> <pre><code>#def nat-trans-components\n( A : U)\n( B : A \u2192 U)\n( f g : (x : A) \u2192 (B x))\n  : U\n  := ( x : A) \u2192 hom (B x) (f x) (g x)\n</code></pre> <pre><code>#def ev-components-nat-trans\n( A : U)\n( B : A \u2192 U)\n( f g : (x : A) \u2192 (B x))\n( \u03b7 : nat-trans A B f g)\n  : nat-trans-components A B f g\n  := \\ x t \u2192 \u03b7 t x\n#def nat-trans-nat-trans-components\n( A : U)\n( B : A \u2192 U)\n( f g : (x : A) \u2192 (B x))\n( \u03b7 : nat-trans-components A B f g)\n  : nat-trans A B f g\n  := \\ t x \u2192 \u03b7 x t\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformation-extensionality","title":"Natural transformation extensionality","text":"RS17, Proposition 6.3<pre><code>#def is-equiv-ev-components-nat-trans\n( A : U)\n( B : A \u2192 U)\n( f g : (x : A) \u2192 (B x))\n  : is-equiv\n      ( nat-trans A B f g)\n      ( nat-trans-components A B f g)\n      ( ev-components-nat-trans A B f g)\n  :=\n    ( ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl) ,\n      ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl))\n#def equiv-components-nat-trans\n( A : U)\n( B : A \u2192 U)\n( f g : (x : A) \u2192 (B x))\n  : Equiv (nat-trans A B f g) (nat-trans-components A B f g)\n  :=\n    ( ev-components-nat-trans A B f g ,\n      is-equiv-ev-components-nat-trans A B f g)\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#naturality-square","title":"Naturality square","text":"<p>Natural transformations are automatically natural when the codomain is a Segal type.</p> RS17, Proposition 6.6<pre><code>#section comp-eq-square-is-segal\n#variable A : U\n#variable is-segal-A : is-segal A\n#variable \u03b1 : (\u0394\u00b9\u00d7\u0394\u00b9) \u2192 A\n#def \u03b100 : A := \u03b1 (0\u2082,0\u2082)\n#def \u03b101 : A := \u03b1 (0\u2082,1\u2082)\n#def \u03b110 : A := \u03b1 (1\u2082,0\u2082)\n#def \u03b111 : A := \u03b1 (1\u2082,1\u2082)\n#def \u03b10* : \u0394\u00b9 \u2192 A := \\ t \u2192 \u03b1 (0\u2082,t)\n#def \u03b11* : \u0394\u00b9 \u2192 A := \\ t \u2192 \u03b1 (1\u2082,t)\n#def \u03b1*0 : \u0394\u00b9 \u2192 A := \\ s \u2192 \u03b1 (s,0\u2082)\n#def \u03b1*1 : \u0394\u00b9 \u2192 A := \\ s \u2192 \u03b1 (s,1\u2082)\n#def \u03b1-diag : \u0394\u00b9 \u2192 A := \\ s \u2192 \u03b1 (s,s)\n#def lhs uses (\u03b1) : \u0394\u00b9 \u2192 A := comp-is-segal A is-segal-A \u03b100 \u03b101 \u03b111 \u03b10* \u03b1*1\n#def rhs uses (\u03b1) : \u0394\u00b9 \u2192 A := comp-is-segal A is-segal-A \u03b100 \u03b110 \u03b111 \u03b1*0 \u03b11*\n#def lower-triangle-square : hom2 A \u03b100 \u03b101 \u03b111 \u03b10* \u03b1*1 \u03b1-diag\n  := \\ (s, t) \u2192 \u03b1 (t,s)\n#def upper-triangle-square : hom2 A \u03b100 \u03b110 \u03b111 \u03b1*0 \u03b11* \u03b1-diag\n  := \\ (s,t) \u2192 \u03b1 (s,t)\n#def comp-eq-square-is-segal uses (\u03b1)\n  : comp-is-segal A is-segal-A \u03b100 \u03b101 \u03b111 \u03b10* \u03b1*1 =\n    comp-is-segal A is-segal-A \u03b100 \u03b110 \u03b111 \u03b1*0 \u03b11*\n  :=\n    zig-zag-concat (hom A \u03b100 \u03b111) lhs \u03b1-diag rhs\n    ( uniqueness-comp-is-segal A is-segal-A \u03b100 \u03b101 \u03b111 \u03b10* \u03b1*1 \u03b1-diag\n      ( lower-triangle-square))\n    ( uniqueness-comp-is-segal A is-segal-A \u03b100 \u03b110 \u03b111 \u03b1*0 \u03b11* \u03b1-diag\n      ( upper-triangle-square))\n#end comp-eq-square-is-segal\n</code></pre> <p>We now extract a naturality square from a natural transformation whose codomain is a Segal type.</p> RS17, Proposition 6.6<pre><code>#def naturality-nat-trans-is-segal\n(A B : U)\n(is-segal-B : is-segal B)\n(f g : A \u2192 B)\n(\u03b1 : nat-trans A (\\ _ \u2192 B) f g)\n(x y : A)\n(k : hom A x y)\n  : comp-is-segal B is-segal-B (f x) (f y) (g y)\n    ( ap-hom A B f x y k)\n    ( \\ s \u2192 \u03b1 s y) =\n    comp-is-segal B is-segal-B (f x) (g x) (g y)\n    ( \\ s \u2192 \u03b1 s x)\n    ( ap-hom A B g x y k)\n  := comp-eq-square-is-segal B is-segal-B (\\ (s,t) \u2192 \u03b1 s (k t))\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#vertical-composition","title":"Vertical composition","text":"<p>We can define vertical composition for natural transformations in families of Segal types.</p> <pre><code>#def vertical-comp-nat-trans-components\n( A : U)\n( B : A \u2192 U)\n( is-segal-B : (x : A) \u2192 is-segal (B x))\n( f g h : (x : A) \u2192 (B x))\n( \u03b7 : nat-trans-components A B f g)\n( \u03b7' : nat-trans-components A B g h)\n  : nat-trans-components A B f h\n  := \\ x \u2192 comp-is-segal (B x) (is-segal-B x) (f x) (g x) (h x) (\u03b7 x) (\u03b7' x)\n#def vertical-comp-nat-trans\n( A : U)\n( B : A \u2192 U)\n( is-segal-B : (x : A) \u2192 is-segal (B x))\n( f g h : (x : A) \u2192 (B x))\n( \u03b7 : nat-trans A B f g)\n( \u03b7' : nat-trans A B g h)\n  : nat-trans A B f h\n  :=\n\\ t x \u2192\n    vertical-comp-nat-trans-components A B is-segal-B f g h\n      ( \\ x' t' \u2192 \u03b7 t' x')\n      ( \\ x' t' \u2192 \u03b7' t' x')\n      ( x)\n      ( t)\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#functoriality-of-evaluation-at-components","title":"Functoriality of evaluation at components","text":"<p>The components of the identity natural transformation are identity arrows.</p> RS17, Proposition 6.5(ii)<pre><code>#def id-arr-components-id-nat-trans\n( A : U)\n( B : A \u2192 U)\n( f : (x : A) \u2192 (B x))\n( a : A)\n  : (ev-components-nat-trans A B f f (id-hom ((x : A) \u2192 B x) f)) a =\n    id-hom (B a) (f a)\n  := refl\n</code></pre> <p>When the fibers of a family of types <code>B : A \u2192 U</code> are Segal types, the components of the natural transformation defined by composing in the Segal type <code>(x : A) \u2192 B x</code> agree with the components defined by vertical composition.</p> RS17, Proposition 6.5(i)<pre><code>#def comp-components-comp-nat-trans-is-segal uses (funext)\n( A : U)\n( B : A \u2192 U)\n( is-segal-B : (x : A) \u2192 is-segal (B x))\n( f g h : (x : A) \u2192 (B x))\n( \u03b1 : nat-trans A B f g)\n( \u03b2 : nat-trans A B g h)\n( a : A)\n  : ( comp-is-segal (B a) (is-segal-B a) (f a) (g a) (h a)\n      ( ev-components-nat-trans A B f g \u03b1 a)\n      ( ev-components-nat-trans A B g h \u03b2 a)) =\n( ev-components-nat-trans A B f h\n      ( comp-is-segal\n        ( (x : A) \u2192 B x) ( is-segal-function-type (funext) (A) (B) (is-segal-B))\n        ( f) (g) (h) (\u03b1) (\u03b2))) a\n  :=\n    functors-pres-comp\n( (x : A) \u2192 (B x)) (B a)\n    ( is-segal-function-type (funext) (A) (B) (is-segal-B)) (is-segal-B a)\n    ( \\ s \u2192 s a) (f) (g) (h) (\u03b1) (\u03b2)\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#horizontal-composition","title":"Horizontal composition","text":"<p>Horizontal composition of natural transformations makes sense over any type. In particular , contrary to what is written in [RS17] we do not need <code>C</code> to be Segal.</p> <pre><code>#def horizontal-comp-nat-trans\n( A B C : U)\n( f g : A \u2192 B)\n( f' g' : B \u2192 C)\n( \u03b7 : nat-trans A (\\ _ \u2192 B) f g)\n( \u03b7' : nat-trans B (\\ _ \u2192 C) f' g')\n  : nat-trans A (\\ _ \u2192 C) (\\ x \u2192 f' (f x)) (\\ x \u2192 g' (g x))\n  := \\ t x \u2192 \u03b7' t (\u03b7 t x)\n#def horizontal-comp-nat-trans-components\n( A B C : U)\n( f g : A \u2192 B)\n( f' g' : B \u2192 C)\n( \u03b7 : nat-trans-components A (\\ _ \u2192 B) f g)\n( \u03b7' : nat-trans-components B (\\ _ \u2192 C) f' g')\n  : nat-trans-components A (\\ _ \u2192 C) (\\ x \u2192 f' (f x)) (\\ x \u2192 g' (g x))\n  := \\ x t \u2192 \u03b7' (\u03b7 x t) t\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#whiskering","title":"Whiskering","text":"<p>Whiskering is a special case of horizontal composition when one of the natural transformations is the identity.</p> <pre><code>#def postwhisker-nat-trans\n( B C D : U)\n( f g : B \u2192 C)\n( h : C \u2192 D)\n( \u03b7 : nat-trans B (\\ _ \u2192 C) f g)\n  : nat-trans B (\\ _ \u2192 D) (comp B C D h f) (comp B C D h g)\n  := horizontal-comp-nat-trans B C D f g h h \u03b7 (id-hom (C \u2192 D) h)\n#def prewhisker-nat-trans\n( A B C : U)\n( k : A \u2192 B)\n( f g : B \u2192 C)\n( \u03b7 : nat-trans B (\\ _ \u2192 C) f g)\n  : nat-trans A (\\ _ \u2192 C) (comp A B C f k) (comp A B C g k)\n  := horizontal-comp-nat-trans A B C k k f g (id-hom (A \u2192 B) k) \u03b7\n#def whisker-nat-trans\n( A B C D : U)\n( k : A \u2192 B)\n( f g : B \u2192 C)\n( h : C \u2192 D)\n( \u03b7 : nat-trans B (\\ _ \u2192 C) f g)\n  : nat-trans A (\\ _ \u2192 D)\n    ( triple-comp A B C D h f k)\n    ( triple-comp A B C D h g k)\n  :=\n    postwhisker-nat-trans A C D (comp A B C f k) (comp A B C g k) h\n    ( prewhisker-nat-trans A B C k f g \u03b7)\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#gray-interchanger","title":"Gray interchanger","text":"<p>The horizontal composition operation also defines coherence data in the form of the \"Gray interchanger\" built from two commutative triangles.</p> <pre><code>#def gray-interchanger-horizontal-comp-nat-trans\n( A B C : U)\n( f g : A \u2192 B)\n( f' g' : B \u2192 C)\n( \u03b7 : nat-trans A (\\ _ \u2192 B) f g)\n( \u03b7' : nat-trans B (\\ _ \u2192 C) f' g')\n  : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 (A \u2192 C)\n  := \\ (t, s) a \u2192 \u03b7' s (\u03b7 t a)\n#def left-gray-interchanger-horizontal-comp-nat-trans\n( A B C : U)\n( f g : A \u2192 B)\n( f' g' : B \u2192 C)\n( \u03b7 : nat-trans A (\\ _ \u2192 B) f g)\n( \u03b7' : nat-trans B (\\ _ \u2192 C) f' g')\n  : hom2 (A \u2192 C) (comp A B C f' f) (comp A B C f' g) (comp A B C g' g)\n    ( postwhisker-nat-trans A B C f g f' \u03b7)\n    ( prewhisker-nat-trans A B C g f' g' \u03b7')\n    ( horizontal-comp-nat-trans A B C f g f' g' \u03b7 \u03b7')\n  := \\ (t, s) a \u2192 \u03b7' s (\u03b7 t a)\n#def right-gray-interchanger-horizontal-comp-nat-trans\n( A B C : U)\n( f g : A \u2192 B)\n( f' g' : B \u2192 C)\n( \u03b7 : nat-trans A (\\ _ \u2192 B) f g)\n( \u03b7' : nat-trans B (\\ _ \u2192 C) f' g')\n  : hom2 (A \u2192 C) (comp A B C f' f) (comp A B C g' f) (comp A B C g' g)\n    ( prewhisker-nat-trans A B C f f' g' \u03b7')\n    ( postwhisker-nat-trans A B C f g g' \u03b7)\n    ( horizontal-comp-nat-trans A B C f g f' g' \u03b7 \u03b7')\n  := \\ (t, s) a \u2192 \u03b7' t (\u03b7 s a)\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/","title":"Discrete types","text":"<p>These formalisations correspond to Section 7 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/01-paths.rzk.md</code> - We require basic path algebra.</li> <li><code>hott/04-equivalences.rzk.md</code> - We require the notion of equivalence between   types.</li> <li><code>03-simplicial-type-theory.rzk.md</code> \u2014 We rely on definitions of simplicies and   their subshapes.</li> <li><code>04-extension-types.rzk.md</code> \u2014 We use extension extensionality.</li> <li><code>05-segal-types.rzk.md</code> - We use the notion of hom types.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#the-definition","title":"The definition","text":"<p>Discrete types are types in which the hom-types are canonically equivalent to identity types.</p> RS17, Definition 7.1<pre><code>#def hom-eq\n( A : U)\n( x y : A)\n( p : x = y)\n  : hom A x y\n  := ind-path (A) (x) (\\ y' p' \u2192 hom A x y') ((id-hom A x)) (y) (p)\n#def is-discrete\n( A : U)\n  : U\n  := (x : A) \u2192 (y : A) \u2192 is-equiv (x = y) (hom A x y) (hom-eq A x y)\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#alternative-definitions","title":"Alternative definitions","text":"<p>One can characterize discrete types in various other equivalent:</p> <pre><code>#section discrete-types-alternative\n#variable A : U\n#def is-\u0394\u00b9-local\n  : U\n  := is-equiv A (\u0394\u00b9 \u2192 A) (\\ a _ \u2192 a)\n</code></pre> <pre><code>#def is-left-local\n  : U\n  := is-local-type 2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082) A\n#def is-right-local\n  : U\n  := is-local-type 2 \u0394\u00b9 (\\ t \u2192 t \u2261 1\u2082) A\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#alternative-definitions-proofs","title":"Alternative definitions : proofs","text":"<p>First ot all, note that we have two section-retraction pairs</p> <pre><code>#def is-section-retraction-0-\u0394\u00b9-0\n  : is-section-retraction-pair\n    ( A) ( \u0394\u00b9 \u2192 A) ( (t : 2 | \u0394\u00b9 t \u2227 t \u2261 0\u2082) \u2192 A)\n    ( \\ a _ \u2192 a) (\\ \u03c4 t \u2192 \u03c4 t)\n  :=\n    ( ( \\ \u03c3 \u2192 \u03c3 0\u2082 , \\ _ \u2192 refl)\n    , ( \\ \u03c3 \u2192 \u03c3 0\u2082 , \\ _ \u2192 refl))\n#def is-section-retraction-1-\u0394\u00b9-1\n  : is-section-retraction-pair\n    ( A) ( \u0394\u00b9 \u2192 A) ( (t : 2 | \u0394\u00b9 t \u2227 t \u2261 1\u2082) \u2192 A)\n    ( \\ a _ \u2192 a) (\\ \u03c4 t \u2192 \u03c4 t)\n  :=\n    ( ( \\ \u03c3 \u2192 \u03c3 1\u2082 , \\ _ \u2192 refl)\n    , ( \\ \u03c3 \u2192 \u03c3 1\u2082 , \\ _ \u2192 refl))\n</code></pre> <p>From this it follows that the three alternative definitions are all equivalent to each other.</p> <pre><code>#def is-left-local-is-\u0394\u00b9-local\n  : is-\u0394\u00b9-local \u2192 is-left-local\n  :=\n    is-equiv-retraction-is-equiv-section-is-section-retraction-pair\n      ( A) ( \u0394\u00b9 \u2192 A) ( (t : 2 | \u0394\u00b9 t \u2227 t \u2261 0\u2082) \u2192 A)\n      ( \\ a _ \u2192 a) (\\ \u03c4 t \u2192 \u03c4 t)\n    ( is-section-retraction-0-\u0394\u00b9-0)\n#def is-\u0394\u00b9-local-is-left-local\n  : is-left-local \u2192 is-\u0394\u00b9-local\n  :=\n    is-equiv-section-is-equiv-retraction-is-section-retraction-pair\n      ( A) ( \u0394\u00b9 \u2192 A) ( (t : 2 | \u0394\u00b9 t \u2227 t \u2261 0\u2082) \u2192 A)\n      ( \\ a _ \u2192 a) (\\ \u03c4 t \u2192 \u03c4 t)\n    ( is-section-retraction-0-\u0394\u00b9-0)\n#def is-right-local-is-\u0394\u00b9-local\n  : is-\u0394\u00b9-local \u2192 is-right-local\n  :=\n    is-equiv-retraction-is-equiv-section-is-section-retraction-pair\n      ( A) ( \u0394\u00b9 \u2192 A) ( (t : 2 | \u0394\u00b9 t \u2227 t \u2261 1\u2082) \u2192 A)\n      ( \\ a _ \u2192 a) (\\ \u03c4 t \u2192 \u03c4 t)\n    ( is-section-retraction-1-\u0394\u00b9-1)\n#def is-\u0394\u00b9-local-is-right-local\n  : is-right-local \u2192 is-\u0394\u00b9-local\n  :=\n    is-equiv-section-is-equiv-retraction-is-section-retraction-pair\n      ( A) ( \u0394\u00b9 \u2192 A) ( (t : 2 | \u0394\u00b9 t \u2227 t \u2261 1\u2082) \u2192 A)\n      ( \\ a _ \u2192 a) (\\ \u03c4 t \u2192 \u03c4 t)\n    ( is-section-retraction-1-\u0394\u00b9-1)\n</code></pre> <p>Next, we aim to compare the original <code>is-discrete</code> with <code>is-\u0394\u00b9-local</code>.</p> <p>To do this, we note that we have an equivalence of maps between <code>A \u2192 (\u0394\u00b9 \u2192 A)</code> and the total map of the family <code>\\ (a, b) \u2192 hom-eq a b : a = b \u2192 hom A a b</code> .</p> <pre><code>#def equiv-of-maps-total-map-hom-eq-const-\u0394\u00b9\n  : Equiv-of-maps\n    ( A) ( \u0394\u00b9 \u2192 A)\n    ( \\ a _ \u2192 a)\n    ( free-paths A) ( fibered-arr' A)\n    ( \\ ((a,b), p) \u2192 ((a,b), hom-eq A a b p))\n  :=\n  ( ( ( constant-free-path A\n      , fibered-arr-free-arr' A)\n    , \\ _ \u2192 refl)\n  , ( is-equiv-constant-free-path A\n    , is-equiv-fibered-arr-free-arr' A))\n</code></pre> <p>The rest is just logical bookkeeping using that equivalences are preserved under equivalences of maps and when passing to/from total types.</p> <pre><code>#def is-\u0394\u00b9-local-is-discrete\n( is-discrete-A : is-discrete A)\n  : is-\u0394\u00b9-local\n  :=\n    is-equiv-Equiv-is-equiv ( A) ( \u0394\u00b9 \u2192 A) ( \\ a _ \u2192 a)\n      ( free-paths A) ( fibered-arr' A)\n      ( \\ ((a,b), p) \u2192 ((a,b), hom-eq A a b p))\n    ( equiv-of-maps-total-map-hom-eq-const-\u0394\u00b9)\n    ( is-equiv-total-is-equiv-fiberwise\n        ( product A A) ( \\ (a,b) \u2192 a = b) ( \\ (a,b) \u2192 hom A a b)\n      ( \\ (a,b) \u2192 hom-eq A a b)\n      ( \\ (a,b) \u2192 is-discrete-A a b))\n#def is-discrete-is-\u0394\u00b9-local\n( is-\u0394\u00b9-local-A : is-\u0394\u00b9-local)\n  : is-discrete A\n  :=\n\\ a b \u2192\n    ( is-equiv-fiberwise-is-equiv-total ( product A A) ( \\ (a,b) \u2192 a = b)\n        ( \\ (a,b) \u2192 hom A a b)\n      ( \\ (a,b) \u2192 hom-eq A a b)\n      ( is-equiv-Equiv-is-equiv' ( A) ( \u0394\u00b9 \u2192 A) ( \\ a _ \u2192 a)\n          ( free-paths A) ( fibered-arr' A)\n          ( \\ ((a,b), p) \u2192 ((a,b), hom-eq A a b p))\n        ( equiv-of-maps-total-map-hom-eq-const-\u0394\u00b9)\n        (is-\u0394\u00b9-local-A)))\n    ( a, b)\n#end discrete-types-alternative\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#families-of-discrete-types","title":"Families of discrete types","text":"<p>By function extensionality, the dependent function type associated to a family of discrete types is discrete.</p> <pre><code>#def equiv-hom-eq-function-type-is-discrete uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-discrete-A : (x : X) \u2192 is-discrete (A x))\n( f g : (x : X) \u2192 A x)\n  : Equiv (f = g) (hom ((x : X) \u2192 A x) f g)\n  :=\n    equiv-triple-comp\n      ( f = g)\n( (x : X) \u2192 f x = g x)\n( (x : X) \u2192 hom (A x) (f x) (g x))\n( hom ((x : X) \u2192 A x) f g)\n      ( equiv-FunExt funext X A f g)\n      ( equiv-function-equiv-family funext X\n        ( \\ x \u2192 (f x = g x))\n        ( \\ x \u2192 hom (A x) (f x) (g x))\n        ( \\ x \u2192 (hom-eq (A x) (f x) (g x) , (is-discrete-A x (f x) (g x)))))\n      ( flip-ext-fun-inv\n        ( 2)\n        ( \u0394\u00b9)\n        ( \u2202\u0394\u00b9)\n        ( X)\n        ( \\ t x \u2192 A x)\n        ( \\ t x \u2192 recOR (t \u2261 0\u2082 \u21a6 f x , t \u2261 1\u2082 \u21a6 g x)))\n#def compute-hom-eq-function-type-is-discrete uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-discrete-A : (x : X) \u2192 is-discrete (A x))\n( f g : (x : X) \u2192 A x)\n( h : f = g)\n  : ( hom-eq ((x : X) \u2192 A x) f g h) =\n    ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) h\n  :=\n    ind-path\n( (x : X) \u2192 A x)\n      ( f)\n( \\ g' h' \u2192\n        hom-eq ((x : X) \u2192 A x) f g' h' =\n        (first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g')) h')\n      ( refl)\n      ( g)\n      ( h)\n</code></pre> RS17, Proposition 7.2<pre><code>#def is-discrete-function-type uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-discrete-A : (x : X) \u2192 is-discrete (A x))\n  : is-discrete ((x : X) \u2192 A x)\n  :=\n\\ f g \u2192\n    is-equiv-homotopy\n      ( f = g)\n( hom ((x : X) \u2192 A x) f g)\n( hom-eq ((x : X) \u2192 A x) f g)\n      ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g))\n      ( compute-hom-eq-function-type-is-discrete X A is-discrete-A f g)\n      ( second (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g))\n</code></pre> <p>By extension extensionality, an extension type into a family of discrete types is discrete. Since <code>equiv-extensions-BOT-equiv</code> considers total extension types only, extending from <code>BOT</code>, that's all we prove here for now.</p> <pre><code>#def equiv-hom-eq-extension-type-is-discrete uses (extext)\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-discrete-A : (t : \u03c8) \u2192 is-discrete (A t))\n( f g : (t : \u03c8) \u2192 A t)\n  : Equiv (f = g) (hom ((t : \u03c8) \u2192 A t) f g)\n  :=\n    equiv-triple-comp\n      ( f = g)\n( (t : \u03c8) \u2192 f t = g t)\n( (t : \u03c8) \u2192 hom (A t) (f t) (g t))\n( hom ((t : \u03c8) \u2192 A t) f g)\n      ( equiv-ExtExt extext I \u03c8 (\\ _ \u2192 BOT) A (\\ _ \u2192 recBOT) f g)\n      ( equiv-extensions-BOT-equiv\n        ( extext)\n        ( I)\n        ( \u03c8)\n        ( \\ t \u2192 f t = g t)\n        ( \\ t \u2192 hom (A t) (f t) (g t))\n        ( \\ t \u2192 (hom-eq (A t) (f t) (g t) , (is-discrete-A t (f t) (g t)))))\n      ( fubini\n        ( I)\n        ( 2)\n        ( \u03c8)\n        ( \\ t \u2192 BOT)\n        ( \u0394\u00b9)\n        ( \u2202\u0394\u00b9)\n        ( \\ t s \u2192 A t)\n        ( \\ (t , s) \u2192 recOR (s \u2261 0\u2082 \u21a6 f t , s \u2261 1\u2082 \u21a6 g t)))\n#def compute-hom-eq-extension-type-is-discrete uses (extext)\n( I : CUBE)\n( \u03c8 : (t : I) \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-discrete-A : (t : \u03c8) \u2192 is-discrete (A t))\n( f g : (t : \u03c8) \u2192 A t)\n( h : f = g)\n  : ( hom-eq ((t : \u03c8) \u2192 A t) f g h) =\n    ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) h\n  :=\n    ind-path\n( (t : \u03c8) \u2192 A t)\n      ( f)\n( \\ g' h' \u2192\n        ( hom-eq ((t : \u03c8) \u2192 A t) f g' h') =\n        ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g') h'))\n      ( refl)\n      ( g)\n      ( h)\n</code></pre> RS17, Proposition 7.2, for extension types<pre><code>#def is-discrete-extension-type uses (extext)\n( I : CUBE)\n( \u03c8 : (t : I) \u2192 TOPE)\n( A : \u03c8 \u2192 U)\n( is-discrete-A : (t : \u03c8) \u2192 is-discrete (A t))\n  : is-discrete ((t : \u03c8) \u2192 A t)\n  :=\n\\ f g \u2192\n    is-equiv-homotopy\n      ( f = g)\n( hom ((t : \u03c8) \u2192 A t) f g)\n( hom-eq ((t : \u03c8) \u2192 A t) f g)\n      ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g))\n      ( compute-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)\n      ( second (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g))\n</code></pre> <p>For instance, the arrow type of a discrete type is discrete.</p> <pre><code>#def is-discrete-arr uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n  : is-discrete (arr A)\n  := is-discrete-extension-type 2 \u0394\u00b9 (\\ _ \u2192 A) (\\ _ \u2192 is-discrete-A)\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#contractible-types-are-discrete","title":"Contractible types are discrete","text":"<p>Every contractible type is automatically discrete.</p> <pre><code>#def is-discrete-is-contr uses (extext)\n( A : U)\n  : is-contr A \u2192 is-discrete A\n  :=\n\\ is-contr-A \u2192\n    ( is-discrete-is-\u0394\u00b9-local A\n      ( is-\u0394\u00b9-local-is-left-local A\n        ( is-local-type-is-contr extext 2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082) A\n          is-contr-A)))\n#def is-discrete-Unit uses (extext)\n  : is-discrete Unit\n  := is-discrete-is-contr Unit (is-contr-Unit)\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types-are-segal-types","title":"Discrete types are Segal types","text":"<p>Recall that we can characterize discrete type either as those local for <code>{0} \u2282 \u0394\u00b9</code> or, equivalently, as those that are local for <code>{1} \u2282 \u0394\u00b9</code>. This suggests two different relative notions of discreteness and corresponding notions of anodyne shape inclusions.</p> <p>Note that while the absolute notions of locality for <code>{0} \u2282 \u0394\u00b9</code> and <code>{1} \u2282 \u0394\u00b9</code> agree, the relative notions do not. We will explore this discrepancy more when we introduce covariant and contravariant type families.</p> <pre><code>#def is-left-fibration\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n  : U\n  := is-right-orthogonal-to-shape 2 \u0394\u00b9 ( \\ s \u2192 s \u2261 0\u2082) A' A \u03b1\n#def is-right-fibration\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n  : U\n  := is-right-orthogonal-to-shape 2 \u0394\u00b9 ( \\ s \u2192 s \u2261 1\u2082) A' A \u03b1\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#left-and-right-anodyne-shape-inclusions","title":"Left and right anodyne shape inclusions","text":"<pre><code>#def is-left-anodyne\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n  : U\n  := is-anodyne-for-shape 2 \u0394\u00b9 ( \\ s \u2192 s \u2261 0\u2082) I \u03c8 \u03d5\n#def is-right-anodyne\n( I : CUBE)\n( \u03c8 : I \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n  : U\n  := is-anodyne-for-shape 2 \u0394\u00b9 ( \\ s \u2192 s \u2261 1\u2082) I \u03c8 \u03d5\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#left-fibrations-are-inner-fibrations","title":"Left fibrations are inner fibrations","text":"<p>We aim to show that every left fibration is an inner fibration, i.e. that the inner horn inclusion <code>\u039b \u2282 \u0394\u00b2</code> is left anodyne.</p> <p>The first step is to identify the pair <code>{0} \u2282 \u0394\u00b9</code> with the pair of subshapes <code>{1} \u2282 right-leg-of-\u039b</code> of <code>\u039b</code>.</p> <pre><code>#def is-left-anodyne-1-right-leg-of-\u039b\n  : is-left-anodyne ( 2 \u00d7 2)\n    (\\ ts \u2192 right-leg-of-\u039b ts) ( \\ (_,s) \u2192 s \u2261 0\u2082)\n  :=\n\\ A' A \u03b1 \u2192\n  is-right-orthogonal-to-shape-isomorphism A' A \u03b1\n  ( 2 \u00d7 2) (\\ ts \u2192 right-leg-of-\u039b ts) (\\ (t , s) \u2192 t \u2261 1\u2082 \u2227 s \u2261 0\u2082)\n  ( 2) (\u0394\u00b9) (\\ t \u2192 t \u2261 0\u2082)\n  ( functorial-isomorphism-0-\u0394\u00b9-1-right-leg-of-\u039b)\n</code></pre> <p>Next we use that <code>\u039b</code> is the pushout of its left leg and its right leg to deduce that the pair <code>left-leg-of-\u039b \u2282 \u039b</code> is left anodyne.</p> <pre><code>#def left-leg-of-\u039b : \u039b \u2192 TOPE\n  := \\ (t, s) \u2192 s \u2261 0\u2082\n#def is-left-anodyne-left-leg-of-\u039b-\u039b\n  : is-left-anodyne ( 2 \u00d7 2)\n    ( \\ ts \u2192 \u039b ts) ( \\ ts \u2192 left-leg-of-\u039b ts)\n  :=\n\\ A' A \u03b1 is-left-fib-\u03b1 \u2192\n    is-right-orthogonal-to-shape-pushout A' A \u03b1\n    ( 2 \u00d7 2) ( \\ ts \u2192 right-leg-of-\u039b ts) (\\ ts \u2192 left-leg-of-\u039b ts)\n    ( is-left-anodyne-1-right-leg-of-\u039b A' A \u03b1 is-left-fib-\u03b1)\n</code></pre> <p>Furthermore, we observe that the pair <code>left-leg-of-\u0394 \u2282 \u0394\u00b9\u00d7\u0394\u00b9</code> is the product of <code>\u0394\u00b9</code> with the left anodyne pair <code>{0} \u2282 \u0394\u00b9</code>, hence left anodyne itself.</p> <pre><code>#def is-left-anodyne-left-leg-of-\u039b-\u0394\u00b9\u00d7\u0394\u00b9 uses (extext)\n  : is-left-anodyne ( 2 \u00d7 2)\n    ( \\ ts \u2192 \u0394\u00b9\u00d7\u0394\u00b9 ts) ( \\ ts \u2192 left-leg-of-\u039b ts)\n  :=\n\\ A' A \u03b1 \u2192\n    is-right-orthogonal-to-shape-product extext A' A \u03b1\n2 \u0394\u00b9 2 \u0394\u00b9 ( \\ s \u2192 s \u2261 0\u2082)\n</code></pre> <p>Next, we use the left cancellation of left anodyne shape inclusions to deduce that <code>\u039b \u2282 \u0394\u00b9\u00d7\u0394\u00b9</code> is left anodyne.</p> <pre><code>#def is-left-anodyne-\u039b-\u0394\u00b9\u00d7\u0394\u00b9 uses (extext)\n  : is-left-anodyne ( 2 \u00d7 2)\n    ( \\ ts \u2192 \u0394\u00b9\u00d7\u0394\u00b9 ts) ( \\ ts \u2192 \u039b ts)\n  :=\n  is-anodyne-left-cancel-for-shape 2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082)\n  ( 2 \u00d7 2) ( \\ ts \u2192 \u0394\u00b9\u00d7\u0394\u00b9 ts) ( \\ ts \u2192 \u039b ts) ( \\ ts \u2192 left-leg-of-\u039b ts)\n  ( is-left-anodyne-left-leg-of-\u039b-\u039b)\n  ( is-left-anodyne-left-leg-of-\u039b-\u0394\u00b9\u00d7\u0394\u00b9)\n</code></pre> <p>Finally, we right cancel the functorial retract <code>\u0394\u00b2 \u2282 \u0394\u00b9\u00d7\u0394\u00b9</code> to obtain the desired left anodyne shape inclusion <code>\u039b \u2282 \u0394\u00b2</code>.</p> <pre><code>#def is-left-anodyne-\u039b-\u0394\u00b2 uses (extext)\n  : is-left-anodyne (2 \u00d7 2)\n    \u0394\u00b2 (\\ t \u2192 \u039b t)\n  :=\n  is-anodyne-right-cancel-retract-for-shape 2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082)\n  ( 2 \u00d7 2) ( \\ ts \u2192 \u0394\u00b9\u00d7\u0394\u00b9 ts) ( \\ ts \u2192 \u0394\u00b2 ts) ( \\ ts \u2192 \u039b ts)\n  ( is-functorial-retract-\u0394\u00b2-\u0394\u00b9\u00d7\u0394\u00b9)\n  ( is-left-anodyne-\u039b-\u0394\u00b9\u00d7\u0394\u00b9)\n</code></pre> <p>which we can unpack to get the desired implication</p> <pre><code>#def is-inner-fibration-is-left-fibration uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n  : is-left-fibration A' A \u03b1 \u2192 is-inner-fibration A' A \u03b1\n  := is-left-anodyne-\u039b-\u0394\u00b2 A' A \u03b1\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#left-fibrations-and-segal-types","title":"Left fibrations and Segal types","text":"<p>Since the Segal types are precisely the local types with respect to <code>\u039b \u2282 \u0394\u00b2</code>, we immediately deduce that in any left fibration <code>\u03b1 : A' \u2192 A</code>, if <code>A</code> is a Segal type, then so is <code>A'</code>.</p> RS 17, Theorem 8.8, categorical version<pre><code>#def is-segal-domain-left-fibration-is-segal-codomain uses (extext)\n( A' A : U)\n( \u03b1 : A' \u2192 A)\n( is-left-fib-\u03b1 : is-left-fibration A' A \u03b1)\n( is-segal-A : is-segal A)\n  : is-segal A'\n  :=\n    is-segal-is-local-horn-inclusion A'\n      ( is-local-type-right-orthogonal-is-local-type\n        ( 2 \u00d7 2) \u0394\u00b2 ( \\ ts \u2192 \u039b ts) A' A \u03b1\n        ( is-inner-fibration-is-left-fibration A' A \u03b1 is-left-fib-\u03b1)\n        ( is-local-horn-inclusion-is-segal A is-segal-A))\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types-are-segal-types_1","title":"Discrete types are Segal types","text":"<p>Another immediate corollary is that every discrete type is Segal.</p> <pre><code>#def is-segal-is-discrete uses (extext)\n( A : U)\n  : is-discrete A \u2192 is-segal A\n  :=\n\\ is-discrete-A \u2192\n  ( is-segal-has-unique-inner-extensions A\n    ( is-weak-anodyne-is-anodyne-for-shape extext\n      ( 2) (\u0394\u00b9) (\\ t \u2192 t \u2261 0\u2082) ( 2 \u00d7 2) (\u0394\u00b2) (\\ t \u2192 \u039b t)\n      ( is-left-anodyne-\u039b-\u0394\u00b2)\n      ( A)\n      ( has-unique-extensions-is-local-type 2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082) A\n        ( is-left-local-is-\u0394\u00b9-local A\n          ( is-\u0394\u00b9-local-is-discrete A is-discrete-A)))))\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types-are-segal-types-original-proof-of-rs17","title":"Discrete types are Segal types (original proof of RS17)","text":"<p>This chapter contains the original proof of RS17 that discrete types are automatically Segal types. We retain it since some intermediate calculations might still be of use.</p> <pre><code>#section discrete-arr-equivalences\n#variable A : U\n#variable is-discrete-A : is-discrete A\n#variables x y z w : A\n#variable f : hom A x y\n#variable g : hom A z w\n#def is-equiv-hom-eq-discrete uses (extext x y z w)\n  : is-equiv (f =_{arr A} g) (hom (arr A) f g) (hom-eq (arr A) f g)\n  := (is-discrete-arr A is-discrete-A) f g\n#def equiv-hom-eq-discrete uses (extext x y z w)\n  : Equiv (f =_{arr A} g) (hom (arr A) f g)\n  := (hom-eq (arr A) f g , (is-discrete-arr A is-discrete-A) f g)\n#def equiv-square-hom-arr\n  : Equiv\n      ( hom (arr A) f g)\n( \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n              ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n                A [ t \u2261 0\u2082 \u2227 \u0394\u00b9 s \u21a6 f s ,\n                    t \u2261 1\u2082 \u2227 \u0394\u00b9 s \u21a6 g s ,\n                    \u0394\u00b9 t \u2227 s \u2261 0\u2082 \u21a6 h t ,\n                    \u0394\u00b9 t \u2227 s \u2261 1\u2082 \u21a6 k t])))\n  :=\n    ( \\ \u03b1 \u2192\n      ( ( \\ t \u2192 \u03b1 t 0\u2082) ,\n        ( ( \\ t \u2192 \u03b1 t 1\u2082) , (\\ (t , s) \u2192 \u03b1 t s))) ,\n      ( ( ( \\ \u03c3 t s \u2192 (second (second \u03c3)) (t , s)) , (\\ \u03b1 \u2192 refl)) ,\n        ( ( \\ \u03c3 t s \u2192 (second (second \u03c3)) (t , s)) , (\\ \u03c3 \u2192 refl))))\n</code></pre> <pre><code>#def is-equiv-ap-fibered-arr-free-arr uses (w x y z)\n  : is-equiv\n      ( f =_{\u0394\u00b9 \u2192 A} g)\n      ( fibered-arr-free-arr A f = fibered-arr-free-arr A g)\n      ( ap\n        ( arr A)\n( \u03a3 (u : A) , (\u03a3 (v : A) , (hom A u v)))\n        ( f)\n        ( g)\n        ( fibered-arr-free-arr A))\n  :=\n    is-emb-is-equiv\n      ( arr A)\n( \u03a3 (u : A) , (\u03a3 (v : A) , (hom A u v)))\n      ( fibered-arr-free-arr A)\n      ( is-equiv-fibered-arr-free-arr A)\n      ( f)\n      ( g)\n#def equiv-eq-fibered-arr-eq-free-arr uses (w x y z)\n  : Equiv (f =_{\u0394\u00b9 \u2192 A} g) (fibered-arr-free-arr A f = fibered-arr-free-arr A g)\n  :=\n    equiv-ap-is-equiv\n      ( arr A)\n( \u03a3 (u : A) , (\u03a3 (v : A) , (hom A u v)))\n      ( fibered-arr-free-arr A)\n      ( is-equiv-fibered-arr-free-arr A)\n      ( f)\n      ( g)\n#def equiv-sigma-over-product-hom-eq\n  : Equiv\n      ( fibered-arr-free-arr A f = fibered-arr-free-arr A g)\n( \u03a3 ( p : x = z) ,\n( \u03a3 ( q : y = w) ,\n              ( product-transport A A (hom A) x z y w p q f = g)))\n  :=\n    extensionality-\u03a3-over-product\n      ( A) (A)\n      ( hom A)\n      ( fibered-arr-free-arr A f)\n      ( fibered-arr-free-arr A g)\n#def equiv-square-sigma-over-product uses (extext is-discrete-A)\n  : Equiv\n( \u03a3 ( p : x = z) ,\n( \u03a3 (q : y = w) ,\n            ( product-transport A A (hom A) x z y w p q f = g)))\n( \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n            ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n              A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                  (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n  :=\n    equiv-left-cancel\n      ( f =_{\u0394\u00b9 \u2192 A} g)\n( \u03a3 ( p : x = z) ,\n( \u03a3 ( q : y = w) ,\n              ( product-transport A A (hom A) x z y w p q f = g)))\n( \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n              ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n                A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                    (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                    (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t ,\n                    (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n      ( equiv-comp\n        ( f =_{\u0394\u00b9 \u2192 A} g)\n        ( fibered-arr-free-arr A f = fibered-arr-free-arr A g)\n( \u03a3 ( p : x = z) ,\n( \u03a3 ( q : y = w) ,\n                ( product-transport A A (hom A) x z y w p q f = g)))\n        equiv-eq-fibered-arr-eq-free-arr\n        equiv-sigma-over-product-hom-eq)\n      ( equiv-comp\n        ( f =_{\u0394\u00b9 \u2192 A} g)\n        ( hom (arr A) f g)\n( \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n                ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n                  A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                      (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                      (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t ,\n                      (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n        ( equiv-hom-eq-discrete)\n        ( equiv-square-hom-arr))\n</code></pre> <p>We close the section so we can use path induction.</p> <pre><code>#end discrete-arr-equivalences\n</code></pre> <pre><code>#def fibered-map-square-sigma-over-product\n( A : U)\n( x y z w : A)\n( f : hom A x y)\n( p : x = z)\n( q : y = w)\n  : ( g : hom A z w) \u2192\n    ( product-transport A A (hom A) x z y w p q f = g) \u2192\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 (hom-eq A x z p) t ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w q) t])\n  :=\n    ind-path\n      ( A)\n      ( x)\n( \\ z' p' \u2192\n        ( g : hom A z' w) \u2192\n        ( product-transport A A (hom A) x z' y w p' q f = g) \u2192\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 (hom-eq A x z' p') t ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w q) t]))\n      ( ind-path\n        ( A)\n        ( y)\n( \\ w' q' \u2192\n          ( g : hom A x w') \u2192\n          ( product-transport A A (hom A) x x y w' refl q' f = g) \u2192\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w' q') t]))\n        ( ind-path\n          ( hom A x y)\n          ( f)\n          ( \\ g' \u03c4' \u2192\n            ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n              A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                  (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g' s ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n          ( \\ (t , s) \u2192 f s))\n        ( w)\n        ( q))\n      ( z)\n      ( p)\n#def square-sigma-over-product\n( A : U)\n( x y z w : A)\n( f : hom A x y)\n( g : hom A z w)\n  ( ( p , (q , \u03c4)) :\n( \u03a3 ( p : x = z) ,\n( \u03a3 ( q : y = w) ,\n            ( product-transport A A (hom A) x z y w p q f = g))))\n  : \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t]))\n  :=\n    ( ( hom-eq A x z p) ,\n      ( ( hom-eq A y w q) ,\n        ( fibered-map-square-sigma-over-product\n          ( A)\n          ( x) (y) (z) (w)\n          ( f) (p) (q) (g)\n          ( \u03c4))))\n#def refl-refl-map-equiv-square-sigma-over-product uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f g : hom A x y)\n( \u03c4 : product-transport A A (hom A) x x y y refl refl f = g)\n  : ( first\n      ( equiv-square-sigma-over-product A is-discrete-A x y x y f g)\n      (refl , (refl , \u03c4))) =\n    ( square-sigma-over-product\n      ( A)\n      ( x) (y) (x) (y)\n      ( f) (g)\n      ( refl , (refl , \u03c4)))\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' \u03c4' \u2192\n        ( first\n          ( equiv-square-sigma-over-product A is-discrete-A x y x y f g')\n          ( refl , (refl , \u03c4'))) =\n        ( square-sigma-over-product\n          ( A)\n          ( x) (y) (x) (y)\n          ( f) (g')\n          ( refl , (refl , \u03c4'))))\n      ( refl)\n      ( g)\n      ( \u03c4)\n#def map-equiv-square-sigma-over-product uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y z w : A)\n( f : hom A x y)\n( p : x = z)\n( q : y = w)\n  : ( g : hom A z w) \u2192\n( \u03c4 : product-transport A A (hom A) x z y w p q f = g) \u2192\n    ( first\n      ( equiv-square-sigma-over-product A is-discrete-A x y z w f g)\n      ( p , (q , \u03c4))) =\n    ( square-sigma-over-product\n        A x y z w f g (p , (q , \u03c4)))\n  :=\n    ind-path\n      ( A)\n      ( y)\n( \\ w' q' \u2192\n        ( g : hom A z w') \u2192\n( \u03c4 : product-transport A A (hom A) x z y w' p q' f = g) \u2192\n        ( first\n          ( equiv-square-sigma-over-product\n              A is-discrete-A x y z w' f g))\n          ( p , (q' , \u03c4)) =\n        ( square-sigma-over-product A x y z w' f g)\n          ( p , (q' , \u03c4)))\n      ( ind-path\n        ( A)\n        ( x)\n( \\ z' p' \u2192\n          ( g : hom A z' y) \u2192\n( \u03c4 : product-transport A A (hom A) x z' y y p' refl f = g) \u2192\n          ( first\n            ( equiv-square-sigma-over-product A is-discrete-A x y z' y f g)\n            ( p' , (refl , \u03c4))) =\n          ( square-sigma-over-product A x y z' y f g (p' , (refl , \u03c4))))\n        ( refl-refl-map-equiv-square-sigma-over-product\n            ( A) (is-discrete-A) (x) (y) (f))\n        ( z)\n        ( p))\n      ( w)\n      ( q)\n#def is-equiv-square-sigma-over-product uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y z w : A)\n( f : hom A x y)\n( g : hom A z w)\n  : is-equiv\n( \u03a3 ( p : x = z) ,\n( \u03a3 ( q : y = w) ,\n            ( product-transport A A (hom A) x z y w p q f = g)))\n( \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n            ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n              A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                  (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n    ( square-sigma-over-product A x y z w f g)\n  :=\n    is-equiv-rev-homotopy\n( \u03a3 ( p : x = z) ,\n( \u03a3 ( q : y = w) ,\n            ( product-transport A A (hom A) x z y w p q f = g)))\n( \u03a3 ( h : hom A x z) ,\n( \u03a3 ( k : hom A y w) ,\n            ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n              A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                  (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t ,\n                  (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n    ( first (equiv-square-sigma-over-product A is-discrete-A x y z w f g))\n    ( square-sigma-over-product A x y z w f g)\n    ( \\ (p , (q , \u03c4)) \u2192\n      map-equiv-square-sigma-over-product A is-discrete-A x y z w f p q g \u03c4)\n    ( second (equiv-square-sigma-over-product A is-discrete-A x y z w f g))\n#def is-equiv-fibered-map-square-sigma-over-product uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y z w : A)\n( f : hom A x y)\n( g : hom A z w)\n( p : x = z)\n( q : y = w)\n  : is-equiv\n    ( product-transport A A (hom A) x z y w p q f = g)\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 (hom-eq A x z p) t ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w q) t])\n    ( fibered-map-square-sigma-over-product A x y z w f p q g)\n  :=\n    fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv\n      ( x = z)\n      ( hom A x z)\n      ( y = w)\n      ( hom A y w)\n      ( \\ p' q' \u2192 (product-transport A A (hom A) x z y w p' q' f) = g)\n      ( \\ h' k' \u2192\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h' t ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k' t]))\n      ( hom-eq A x z)\n      ( hom-eq A y w)\n      ( \\ p' q' \u2192\n        fibered-map-square-sigma-over-product\n          ( A)\n          ( x) (y) (z) (w)\n          ( f)\n          ( p')\n          ( q')\n          ( g))\n      ( is-equiv-square-sigma-over-product A is-discrete-A x y z w f g)\n      ( is-discrete-A x z)\n      ( is-discrete-A y w)\n      ( p)\n      ( q)\n#def is-equiv-fibered-map-square-sigma-over-product-refl-refl uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f : hom A x y)\n( g : hom A x y)\n  : is-equiv\n    (f = g)\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n    ( fibered-map-square-sigma-over-product\n      A x y x y f refl refl g)\n  :=\n    is-equiv-fibered-map-square-sigma-over-product\n      A is-discrete-A x y x y f g refl refl\n</code></pre> <p>The previous calculations allow us to establish a family of equivalences:</p> <pre><code>#def is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f : hom A x y)\n  : is-equiv\n( \u03a3 ( g : hom A x y) , f = g)\n( \u03a3 ( g : hom A x y) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n    ( total-map\n      ( hom A x y)\n      ( \\ g \u2192 f = g)\n      ( \\ g \u2192\n        ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n      ( fibered-map-square-sigma-over-product\n          A x y x y f refl refl))\n  :=\n    is-equiv-total-is-equiv-fiberwise\n      ( hom A x y)\n      ( \\ g \u2192 f = g)\n      ( \\ g \u2192\n        ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n      ( fibered-map-square-sigma-over-product\n          A x y x y f refl refl)\n      ( \\ g \u2192\n        is-equiv-fibered-map-square-sigma-over-product-refl-refl\n          ( A) (is-discrete-A)\n          ( x) (y)\n          ( f) (g))\n#def equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f : hom A x y)\n  : Equiv\n( \u03a3 (g : hom A x y) , f = g)\n( \u03a3 (g : hom A x y) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  :=\n    ( ( total-map\n        ( hom A x y)\n        ( \\ g \u2192 f = g)\n        ( \\ g \u2192\n          ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n        ( fibered-map-square-sigma-over-product\n            A x y x y f refl refl)) ,\n    is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl\n      A is-discrete-A x y f)\n</code></pre> <p>Now using the equivalence on total spaces and the contractibility of based path spaces, we conclude that the codomain extension type is contractible.</p> <pre><code>#def is-contr-horn-refl-refl-extension-type uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f : hom A x y)\n  : is-contr\n( \u03a3 ( g : hom A x y) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  :=\n    is-contr-equiv-is-contr\n( \u03a3 ( g : hom A x y) , f = g)\n( \u03a3 ( g : hom A x y) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n      ( equiv-sum-fibered-map-square-sigma-over-product-refl-refl\n          A is-discrete-A x y f)\n      ( is-contr-based-paths (hom A x y) f)\n</code></pre> <p>The extension types that appear in the Segal condition are retracts of this type --- at least when the second arrow in the composable pair is an identity.</p> <pre><code>#def triangle-to-square-section\n( A : U)\n( x y : A)\n( f g : hom A x y)\n( \u03b1 : hom2 A x y y f (id-hom A y) g)\n  : ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n    A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n        (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n        (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n        (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]\n  := \\ (t , s) \u2192 recOR (t \u2264 s \u21a6 \u03b1 (s , t) , s \u2264 t \u21a6 g s)\n#def sigma-triangle-to-sigma-square-section\n( A : U)\n( x y : A)\n( f : hom A x y)\n  ( (d , \u03b1) : \u03a3 (d : hom A x y) , hom2 A x y y f (id-hom A y) d)\n  : \u03a3 ( g : hom A x y) ,\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n  := ( d , triangle-to-square-section A x y f d \u03b1)\n#def sigma-square-to-sigma-triangle-retraction\n( A : U)\n( x y : A)\n( f : hom A x y)\n  ( (g , \u03c3) :\n\u03a3 ( g : hom A x y) ,\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  : \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d)\n  := ( (\\ t \u2192 \u03c3 (t , t)) , (\\ (t , s) \u2192 \u03c3 (s , t)))\n#def sigma-triangle-to-sigma-square-retract\n( A : U)\n( x y : A)\n( f : hom A x y)\n  : is-retract-of\n( \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d))\n( \u03a3 ( g : hom A x y) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  :=\n    ( ( sigma-triangle-to-sigma-square-section A x y f) ,\n      ( ( sigma-square-to-sigma-triangle-retraction A x y f) ,\n        ( \\ d\u03b1 \u2192 refl)))\n</code></pre> <p>We can now verify the Segal condition in the case of composable pairs in which the second arrow is an identity.</p> <pre><code>#def is-contr-hom2-with-id-is-discrete uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f : hom A x y)\n  : is-contr ( \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d))\n  :=\n    is-contr-is-retract-of-is-contr\n( \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d))\n( \u03a3 ( g : hom A x y) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n      ( sigma-triangle-to-sigma-square-retract A x y f)\n      ( is-contr-horn-refl-refl-extension-type A is-discrete-A x y f)\n</code></pre> <p>But since <code>A</code> is discrete, its hom type family is equivalent to its identity type family, and we can use \"path induction\" over arrows to reduce the general case to the one just proven:</p> <pre><code>#def is-contr-hom2-is-discrete uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n  : is-contr (\u03a3 (h : hom A x z) , hom2 A x y z f g h)\n  :=\n    ind-based-path\n      ( A)\n      ( y)\n      ( \\ w \u2192 hom A y w)\n      ( \\ w \u2192 hom-eq A y w)\n      ( is-discrete-A y)\n( \\ w d \u2192 is-contr ( \u03a3 (h : hom A x w) , hom2 A x y w f d h))\n      ( is-contr-hom2-with-id-is-discrete A is-discrete-A x y f)\n      ( z)\n      ( g)\n</code></pre> <p>Finally, we conclude:</p> RS17, Proposition 7.3<pre><code>#def is-segal-is-discrete' uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n  : is-segal A\n  := is-contr-hom2-is-discrete A is-discrete-A\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/","title":"Covariant families","text":"<p>These formalisations correspond to Section 8 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/*</code> - We require various prerequisites from homotopy type theory, for   instance the notion of contractible types.</li> <li><code>03-simplicial-type-theory.rzk.md</code> \u2014 We rely on definitions of simplicies and   their subshapes.</li> <li><code>04-extension-types.rzk.md</code> \u2014 We use Theorem 4.1, an equivalence between   lifts.</li> <li><code>05-segal-types.rzk.md</code> - We make use of the notion of Segal types and their   structures.</li> <li><code>06-contractible.rzk.md</code> - We make use of weak function extensionality. ! Some   of the definitions in this file rely on extension extensionality:</li> </ul> <pre><code>#assume extext : ExtExt\n#assume weakfunext : WeakFunExt\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#dependent-hom-types","title":"Dependent hom types","text":"<p>In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type.</p> RS17, Section 8 Prelim<pre><code>#def dhom\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( u : C x)\n( v : C y)\n  : U\n  := (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u , t \u2261 1\u2082 \u21a6 v]\n</code></pre> <p>It will be convenient to collect together dependent hom types with fixed domain but varying codomain.</p> <pre><code>#def dhom-from\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( u : C x)\n  : U\n  := ( \u03a3 (v : C y) , dhom A x y f C u v)\n</code></pre> <p>There is also a type of dependent commutative triangles over a base commutative triangle.</p> <pre><code>#def dhom2\n( A : U)\n( x y z : A)\n( f : hom A x y)\n( g : hom A y z)\n( h : hom A x z)\n( \u03b1 : hom2 A x y z f g h)\n( C : A \u2192 U)\n( u : C x)\n( v : C y)\n( w : C z)\n( ff : dhom A x y f C u v)\n( gg : dhom A y z g C v w)\n( hh : dhom A x z h C u w)\n  : U\n  :=\n    ( (t1 , t2) : \u0394\u00b2) \u2192 C (\u03b1 (t1 , t2)) [\n        t2 \u2261 0\u2082 \u21a6 ff t1 ,\n        t1 \u2261 1\u2082 \u21a6 gg t2 ,\n        t2 \u2261 t1 \u21a6 hh t2\n      ]\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-families_1","title":"Covariant families","text":"<p>A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain.</p> RS17, Definition 8.2<pre><code>#def is-covariant\n( A : U)\n( C : A \u2192 U)\n  : U\n  :=\n( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (u : C x) \u2192\n    is-contr (dhom-from A x y f C u)\n</code></pre> The type of covariant families over a fixed type<pre><code>#def covariant-family (A : U) : U\n  := ( \u03a3 (C : (A \u2192 U)) , is-covariant A C)\n</code></pre> <p>The notion of a covariant family is stable under substitution into the base.</p> RS17, Remark 8.3<pre><code>#def is-covariant-substitution-is-covariant\n( A B : U)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( g : B \u2192 A)\n  : is-covariant B (\\ b \u2192 C (g b))\n  := \\ x y f u \u2192 is-covariant-C (g x) (g y) (ap-hom B A g x y f) u\n</code></pre> <p>The notion of having a unique lift with a fixed domain may also be expressed by contractibility of the type of extensions along the domain inclusion into the 1-simplex.</p> <pre><code>#def has-unique-fixed-domain-lifts\n( A : U)\n( C : A \u2192 U)\n  : U\n  :=\n( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (u : C x) \u2192\n    is-contr ((t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n</code></pre> <p>These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed domain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here.</p> <pre><code>#def equiv-lifts-with-fixed-domain\n( A : U)\n( C : A \u2192 U)\n( x y : A)\n( f : hom A x y)\n( u : C x)\n  : Equiv\n((t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n      (dhom-from A x y f C u)\n  :=\n    ( \\ h \u2192 (h 1\u2082 , \\ t \u2192 h t) ,\n      ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl) ,\n        ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl))))\n</code></pre> <p>By the equivalence-invariance of contractibility, this proves the desired logical equivalence</p> <pre><code>#def is-covariant-has-unique-fixed-domain-lifts\n( A : U)\n( C : A \u2192 U)\n  : (has-unique-fixed-domain-lifts A C) \u2192 ( is-covariant A C)\n  :=\n\\ C-has-unique-lifts x y f u \u2192\n      is-contr-equiv-is-contr\n( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n        ( dhom-from A x y f C u)\n        ( equiv-lifts-with-fixed-domain A C x y f u)\n        ( C-has-unique-lifts x y f u)\n#def has-unique-fixed-domain-lifts-is-covariant\n( A : U)\n( C : A \u2192 U)\n  : (is-covariant A C) \u2192 (has-unique-fixed-domain-lifts A C)\n  :=\n\\ is-covariant-C x y f u \u2192\n      is-contr-equiv-is-contr'\n( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n        ( dhom-from A x y f C u)\n        ( equiv-lifts-with-fixed-domain A C x y f u)\n        ( is-covariant-C x y f u)\n</code></pre> RS17, Proposition 8.4<pre><code>#def has-unique-fixed-domain-lifts-iff-is-covariant\n( A : U)\n( C : A \u2192 U)\n  : iff\n      ( has-unique-fixed-domain-lifts A C)\n      ( is-covariant A C)\n  :=\n    ( is-covariant-has-unique-fixed-domain-lifts A C,\n      has-unique-fixed-domain-lifts-is-covariant A C)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#naive-left-fibrations","title":"Naive left fibrations","text":"<p>For any functor <code>p : C\u0302 \u2192 A</code>, we can make a naive definition of what it means to be a left fibration.</p> <pre><code>#def is-naive-left-fibration\n( A C\u0302 : U)\n( p : C\u0302 \u2192 A)\n  : U\n  :=\n    is-homotopy-cartesian\n      C\u0302 (coslice C\u0302)\n      A (coslice A)\n      p (coslice-fun C\u0302 A p)\n</code></pre> <p>As a sanity check we unpack the definition of <code>is-naive-left-fibration</code>.</p> <pre><code>#def is-naive-left-fibration-unpacked\n( A C\u0302 : U)\n( p : C\u0302 \u2192 A)\n  : is-naive-left-fibration A C\u0302 p =\n((c : C\u0302) \u2192 is-equiv (coslice C\u0302 c) (coslice A (p c)) (coslice-fun C\u0302 A p c))\n  := refl\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#naive-left-fibrations-are-left-fibrations","title":"Naive left fibrations are left fibrations","text":"<p>Recall that a map <code>\u03b1 : A' \u2192 A</code> is called a left fibration if it is right orthogonal to the shape inclusion <code>{0} \u2282 \u0394\u00b9</code>.</p> <p>This notion agrees with that of a naive left fibration.</p> <pre><code>#section is-left-fibration-is-naive-left-fibration\n#variables A' A : U\n#variable \u03b1 : A' \u2192 A\n#def is-left-fibration-is-naive-left-fibration\n( is-nlf : is-naive-left-fibration A A' \u03b1)\n  : is-left-fibration A' A \u03b1\n  :=\n\\ a' \u2192\n      is-equiv-equiv-is-equiv\n        ( coslice' A' (a' 0\u2082)) (coslice' A (\u03b1 (a' 0\u2082)))\n        ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n        ( coslice A' (a' 0\u2082)) (coslice A (\u03b1 (a' 0\u2082)))\n        ( coslice-fun A' A \u03b1 (a' 0\u2082))\n        ( ( coslice-coslice' A' (a' 0\u2082), coslice-coslice' A (\u03b1 (a' 0\u2082))),\n\\ _ \u2192 refl)\n        ( is-equiv-coslice-coslice' A' (a' 0\u2082))\n        ( is-equiv-coslice-coslice' A (\u03b1 (a' 0\u2082)))\n        ( is-nlf (a' 0\u2082))\n#def is-naive-left-fibration-is-left-fibration\n( is-lf : is-left-fibration A' A \u03b1)\n  : is-naive-left-fibration A A' \u03b1\n  :=\n\\ a' \u2192\n      is-equiv-equiv-is-equiv'\n        ( coslice' A' a') (coslice' A (\u03b1 a'))\n        ( \\ \u03c3' t \u2192 \u03b1 (\u03c3' t))\n        ( coslice A' a') (coslice A (\u03b1 a'))\n        ( coslice-fun A' A \u03b1 a')\n        ( ( coslice-coslice' A' a', coslice-coslice' A (\u03b1 a')),\n\\ _ \u2192 refl)\n        ( is-equiv-coslice-coslice' A' a')\n        ( is-equiv-coslice-coslice' A (\u03b1 a'))\n        ( is-lf (\\ t \u2192 a'))\n#def is-naive-left-fibration-iff-is-left-fibration\n  : iff\n      ( is-naive-left-fibration A A' \u03b1)\n      ( is-left-fibration A' A \u03b1)\n  :=\n    ( is-left-fibration-is-naive-left-fibration,\n      is-naive-left-fibration-is-left-fibration)\n#end is-left-fibration-is-naive-left-fibration\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#naive-left-fibrations-vs-covariant-families","title":"Naive left fibrations vs. covariant families","text":"<p>We aim to prove that a type family <code>C : A \u2192 U</code>, is covariant if and only if the projection <code>p : total-type A C \u2192 A</code> is a naive left fibration.</p> <p>The theorem asserts the logical equivalence of two contractibility statements, one for the types <code>dhom-from A a a' f C c</code> and one for the fibers of the canonical map <code>coslice (total-type A C) (a, c) \u2192 coslice A a</code>; Thus it suffices to show that for each <code>a a' : A</code>, <code>f : hom A a a'</code>, <code>c : C a</code>. these two types are equivalent.</p> <p>We fix the following variables.</p> <pre><code>#section is-naive-left-fibration-is-covariant-proof\n#variable A : U\n#variable a : A\n#variable C : A \u2192 U\n#variable c : C a\n</code></pre> <p>Note that we do not fix <code>a' : A</code> and <code>f : hom A a a'</code>. Letting these vary lets us give an easy proof by invoking the induction principle for fibers.</p> <p>We make some abbreviations to make the proof more readable:</p> <pre><code>-- We prepend all local names in this section\n-- with the random identifyier temp-b9wX\n-- to avoid cluttering the global name space.\n-- Once rzk supports local variables, these should be renamed.\n#def temp-b9wX-coslice-fun\n  : coslice (total-type A C) (a, c) \u2192 coslice A a\n  := coslice-fun (total-type A C) A (\\ (x, _) \u2192 x) (a, c)\n#def temp-b9wX-fib\n(a' : A)\n(f : hom A a a')\n  : U\n  :=\n    fib (coslice (total-type A C) (a, c))\n        (coslice A a)\n        (temp-b9wX-coslice-fun)\n        (a', f)\n</code></pre> <p>We construct the forward map; this one is straightforward since it goes from strict extension type to a weak one.</p> <pre><code>#def temp-b9wX-forward\n( a' : A)\n( f : hom A a a')\n  : dhom-from A a a' f C c \u2192 temp-b9wX-fib a' f\n  :=\n    \\ (c', f\u0302) \u2192 (((a', c'), \\ t \u2192 (f t, f\u0302 t)) , refl)\n</code></pre> <p>The only non-trivial part is showing that this map has a section. We do this by the following fiber induction.</p> <pre><code>#def temp-b9wX-has-section'-forward\n  ( (a', f) : coslice A a)\n( u : temp-b9wX-fib a' f)\n  : U\n  := \u03a3 ( v : dhom-from A a a' f C c), ( temp-b9wX-forward a' f v = u)\n#def temp-b9wX-forward-section'\n  : ( (a', f) : coslice A a) \u2192\n( u : temp-b9wX-fib a' f) \u2192\n    temp-b9wX-has-section'-forward (a', f) u\n  :=\n    ind-fib\n      ( coslice (total-type A C) (a, c))\n      ( coslice A a)\n      ( temp-b9wX-coslice-fun)\n      ( temp-b9wX-has-section'-forward)\n      (\\ ((a', c'), g\u0302) \u2192 ((c', \\ t \u2192 second (g\u0302 t)) , refl))\n</code></pre> <p>We have constructed a section. It is also definitionally a retraction, yielding the desired equivalence.</p> <pre><code>#def temp-b9wX-has-inverse-forward\n( a' : A)\n( f : hom A a a')\n  : has-inverse\n      (dhom-from A a a' f C c)\n      (temp-b9wX-fib a' f)\n      (temp-b9wX-forward a' f)\n  :=\n    ( \\ u \u2192 first (temp-b9wX-forward-section' (a', f) u),\n    ( \\ _ \u2192 refl,\n\\ u \u2192 second (temp-b9wX-forward-section' (a', f) u)\n    ))\n#def temp-b9wX-the-equivalence\n( a' : A)\n( f : hom A a a')\n  : Equiv\n      (dhom-from A a a' f C c)\n      (temp-b9wX-fib a' f)\n  :=\n    ( (temp-b9wX-forward a' f),\n      is-equiv-has-inverse\n        (dhom-from A a a' f C c)\n        (temp-b9wX-fib a' f)\n        (temp-b9wX-forward a' f)\n        (temp-b9wX-has-inverse-forward a' f)\n    )\n#end is-naive-left-fibration-is-covariant-proof\n</code></pre> <p>Finally, we deduce the theorem by some straightforward logical bookkeeping.</p> RS17, Theorem 8.5<pre><code>#def is-naive-left-fibration-is-covariant\n( A : U)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : is-naive-left-fibration A (total-type A C) (\\ (a, _) \u2192 a)\n  :=\n    \\ (a, c) \u2192\n      is-equiv-is-contr-map\n        ( coslice (total-type A C) (a, c))\n        ( coslice A a)\n        ( temp-b9wX-coslice-fun A a C c)\n        ( \\ (a', f) \u2192\n          is-contr-equiv-is-contr\n            (dhom-from A a a' f C c)\n            (temp-b9wX-fib A a C c a' f)\n            (temp-b9wX-the-equivalence A a C c a' f)\n            (is-covariant-C a a' f c)\n        )\n#def is-covariant-is-naive-left-fibration\n( A : U)\n( C : A \u2192 U)\n( inlf-\u03a3C : is-naive-left-fibration A (total-type A C) (\\ (a, _) \u2192 a))\n  : is-covariant A C\n  :=\n\\ a a' f c \u2192\n      is-contr-equiv-is-contr'\n        ( dhom-from A a a' f C c)\n        ( temp-b9wX-fib A a C c a' f)\n        ( temp-b9wX-the-equivalence A a C c a' f)\n        ( is-contr-map-is-equiv\n          ( coslice (total-type A C) (a, c))\n          ( coslice A a)\n          ( temp-b9wX-coslice-fun A a C c)\n          ( inlf-\u03a3C (a, c))\n          (a', f)\n        )\n#def is-naive-left-fibration-iff-is-covariant\n( A : U)\n( C : A \u2192 U)\n  :\n    iff\n      (is-covariant A C)\n      (is-naive-left-fibration A (total-type A C) (\\ (a, _) \u2192 a))\n  :=\n    ( is-naive-left-fibration-is-covariant A C,\n      is-covariant-is-naive-left-fibration A C)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#total-type-of-a-covariant-family-over-a-segal-type","title":"Total type of a covariant family over a Segal type","text":"<p>For every covariant family <code>C : A \u2192 U</code>, the projection <code>\u03a3 A, C \u2192 A</code> is an left fibration, hence an inner fibration. It immediately follows that if <code>A</code> is Segal, then so is <code>\u03a3 A, C</code>.</p> RS17, Theorem 8.8<pre><code>#def is-segal-total-type-covariant-family-is-segal-base uses (extext)\n( A : U)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : is-segal A \u2192 is-segal (total-type A C)\n  :=\n    is-segal-domain-left-fibration-is-segal-codomain extext\n      ( total-type A C) A (\\ (a,_) \u2192 a)\n        ( is-left-fibration-is-naive-left-fibration\n            ( total-type A C) A (\\ (a,_) \u2192 a)\n            ( is-naive-left-fibration-is-covariant A C is-covariant-C))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#representable-covariant-families","title":"Representable covariant families","text":"<p>If <code>A</code> is a Segal type and <code>a : A</code> is any term, then <code>hom A a</code> defines a covariant family over A, and conversely if this family is covariant for every <code>a : A</code>, then <code>A</code> must be a Segal type. The proof involves a rather lengthy composition of equivalences.</p> <pre><code>#def dhom-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n( v : hom A a y)\n  : U\n  := dhom A x y f (\\ z \u2192 hom A a z) u v\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n( v : hom A a y)\n  : Equiv\n    ( dhom-representable A a x y f u v)\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  :=\n    curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 (\\ t s \u2192 A)\n    ( \\ (t , s) \u2192\nrecOR\n        ( (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t))\n#def dhom-from-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : U\n  := dhom-from A x y f (\\ z \u2192 hom A a z) u\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-from-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( v : hom A a y) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    total-equiv-family-of-equiv\n      ( hom A a y)\n      ( \\ v \u2192 dhom-representable A a x y f u v)\n      ( \\ v \u2192\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n      ( \\ v \u2192 uncurried-dhom-representable A a x y f u v)\n#def square-to-hom2-pushout\n( A : U)\n( w x y z : A)\n( u : hom A w x)\n( f : hom A x z)\n( g : hom A w y)\n( v : hom A y z)\n  : ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 g t ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]) \u2192\n( \u03a3 (d : hom A w z) , product (hom2 A w x z u f d) (hom2 A w y z g v d))\n  :=\n\\ sq \u2192\n    ( ( \\ t \u2192 sq (t , t)) , (\\ (t , s) \u2192 sq (s , t) , \\ (t , s) \u2192 sq (t , s)))\n#def hom2-pushout-to-square\n( A : U)\n( w x y z : A)\n( u : hom A w x)\n( f : hom A x z)\n( g : hom A w y)\n( v : hom A y z)\n  : ( \u03a3 ( d : hom A w z) ,\n        ( product (hom2 A w x z u f d) (hom2 A w y z g v d))) \u2192\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 g t ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  :=\n    \\ (d , (\u03b11 , \u03b12)) (t , s) \u2192\nrecOR\n      ( t \u2264 s \u21a6 \u03b11 (s , t) ,\n        s \u2264 t \u21a6 \u03b12 (t , s))\n#def equiv-square-hom2-pushout\n( A : U)\n( w x y z : A)\n( u : hom A w x)\n( f : hom A x z)\n( g : hom A w y)\n( v : hom A y z)\n  : Equiv\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 g t ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n( \u03a3 (d : hom A w z) , (product (hom2 A w x z u f d) (hom2 A w y z g v d)))\n  :=\n    ( ( square-to-hom2-pushout A w x y z u f g v) ,\n      ( ( hom2-pushout-to-square A w x y z u f g v , \\ sq \u2192 refl) ,\n        ( hom2-pushout-to-square A w x y z u f g v , \\ \u03b1s \u2192 refl)))\n#def representable-dhom-from-uncurry-hom2\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n( \u03a3 (v : hom A a y) ,\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n( \u03a3 ( v : hom A a y) ,\n( \u03a3 ( d : hom A a y) ,\n            ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n  :=\n    total-equiv-family-of-equiv\n    ( hom A a y)\n    ( \\ v \u2192\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n( \\ v \u2192\n      ( \u03a3 ( d : hom A a y) ,\n          ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( \\ v \u2192 equiv-square-hom2-pushout A a x a y u f (id-hom A a) v)\n#def representable-dhom-from-hom2\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( d : hom A a y) ,\n( \u03a3 ( v : hom A a y) ,\n            ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n  :=\n    equiv-triple-comp\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( v : hom A a y) ,\n        ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n( \u03a3 ( v : hom A a y) ,\n( \u03a3 ( d : hom A a y) ,\n            ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n( \u03a3 ( d : hom A a y) ,\n( \u03a3 ( v : hom A a y) ,\n            ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( uncurried-dhom-from-representable A a x y f u)\n    ( representable-dhom-from-uncurry-hom2 A a x y f u)\n    ( fubini-\u03a3 (hom A a y) (hom A a y)\n      ( \\ v d \u2192 product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))\n#def representable-dhom-from-hom2-dist\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( d : hom A a y) ,\n        ( product\n          ( hom2 A a x y u f d)\n( \u03a3 (v : hom A a y) , (hom2 A a a y (id-hom A a) v d))))\n  :=\n    equiv-right-cancel\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( d : hom A a y) ,\n        ( product\n          ( hom2 A a x y u f d)\n( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d)))\n( \u03a3 ( d : hom A a y) ,\n( \u03a3 ( v : hom A a y) ,\n            ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( representable-dhom-from-hom2 A a x y f u)\n    ( total-equiv-family-of-equiv\n      ( hom A a y)\n      ( \\ d \u2192\n        ( product\n          ( hom2 A a x y u f d)\n( \u03a3 (v : hom A a y) , (hom2 A a a y (id-hom A a) v d))))\n( \\ d \u2192\n        ( \u03a3 ( v : hom A a y) ,\n            ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n      ( \\ d \u2192\n        ( distributive-product-\u03a3\n          ( hom2 A a x y u f d)\n          ( hom A a y)\n          ( \\ v \u2192 hom2 A a a y (id-hom A a) v d))))\n</code></pre> <p>Now we introduce the hypothesis that A is Segal type.</p> <pre><code>#def representable-dhom-from-path-space-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( d : hom A a y) ,\n        ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d))))\n  :=\n    equiv-right-cancel\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( d : hom A a y) ,\n        ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d))))\n( \u03a3 ( d : hom A a y) ,\n        ( product\n          ( hom2 A a x y u f d)\n( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d)))\n    ( representable-dhom-from-hom2-dist A a x y f u)\n    ( total-equiv-family-of-equiv\n      ( hom A a y)\n      ( \\ d \u2192 product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d)))\n      ( \\ d \u2192\n        ( product\n          ( hom2 A a x y u f d)\n( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d)))\n      ( \\ d \u2192\n        ( total-equiv-family-of-equiv\n          ( hom2 A a x y u f d)\n( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d)))\n( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))\n          ( \\ \u03b1 \u2192\n            ( total-equiv-family-of-equiv\n              ( hom A a y)\n              ( \\ v \u2192 (v = d))\n              ( \\ v \u2192 hom2 A a a y (id-hom A a) v d)\n              ( \\ v \u2192 (equiv-homotopy-hom2-is-segal A is-segal-A a y v d)))))))\n#def codomain-based-paths-contraction\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n( d : hom A a y)\n  : Equiv\n    ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d)))\n    ( hom2 A a x y u f d)\n  :=\n    equiv-projection-contractible-fibers\n      ( hom2 A a x y u f d)\n( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d)))\n      ( \\ \u03b1 \u2192 is-contr-endpoint-based-paths (hom A a y) d)\n#def is-segal-representable-dhom-from-hom2\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n( \u03a3 (d : hom A a y) , (hom2 A a x y u f d))\n  :=\n    equiv-comp\n    ( dhom-from-representable A a x y f u)\n( \u03a3 (d : hom A a y) ,\n      ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d))))\n( \u03a3 (d : hom A a y) , (hom2 A a x y u f d))\n    ( representable-dhom-from-path-space-is-segal A is-segal-A a x y f u)\n    ( total-equiv-family-of-equiv\n      ( hom A a y)\n      ( \\ d \u2192 product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d)))\n      ( \\ d \u2192 hom2 A a x y u f d)\n      ( \\ d \u2192 codomain-based-paths-contraction A a x y f u d))\n#def is-segal-representable-dhom-from-contractible\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : is-contr (dhom-from-representable A a x y f u)\n  :=\n    is-contr-equiv-is-contr'\n      ( dhom-from-representable A a x y f u)\n( \u03a3 (d : hom A a y) , (hom2 A a x y u f d))\n      ( is-segal-representable-dhom-from-hom2 A is-segal-A a x y f u)\n      ( is-segal-A a x y u f)\n</code></pre> <p>Finally, we see that covariant hom families in a Segal type are covariant.</p> RS17, Proposition 8.13(&lt;-)<pre><code>#def is-covariant-representable-is-segal\n(A : U)\n(is-segal-A : is-segal A)\n(a : A)\n  : is-covariant A (hom A a)\n  := is-segal-representable-dhom-from-contractible A is-segal-A a\n</code></pre> <p>The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows:</p> RS17, Proposition 8.13(\u2192)<pre><code>#def is-segal-is-covariant-representable\n( A : U)\n( corepresentable-family-is-covariant : (a : A) \u2192\n    is-covariant A (\\ x \u2192 hom A a x))\n  : is-segal A\n  :=\n\\ x y z f g \u2192\n    is-contr-base-is-contr-\u03a3\n( \u03a3 (h : hom A x z) , hom2 A x y z f g h)\n( \\ hk \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk))\n    ( \\ hk \u2192 (first hk , \\ (t , s) \u2192 first hk s))\n( is-contr-equiv-is-contr'\n      ( \u03a3 ( hk : \u03a3 (h : hom A x z) , hom2 A x y z f g h) ,\n( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk)))\n      ( dhom-from-representable A x y z g f)\n      ( inv-equiv\n        ( dhom-from-representable A x y z g f)\n( \u03a3 ( hk : \u03a3 (h : hom A x z) , hom2 A x y z f g h) ,\n( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk)))\n        ( equiv-comp\n          ( dhom-from-representable A x y z g f)\n( \u03a3 ( h : hom A x z) ,\n              ( product\n                ( hom2 A x y z f g h)\n( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h)))\n( \u03a3 ( hk : \u03a3 (h : hom A x z) , hom2 A x y z f g h) ,\n( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk)))\n          ( representable-dhom-from-hom2-dist A x y z g f)\n          ( associative-\u03a3\n            ( hom A x z)\n            ( \\ h \u2192 hom2 A x y z f g h)\n( \\ h _ \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h))))\n      ( corepresentable-family-is-covariant x y z g f))\n</code></pre> <p>While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows.</p> <pre><code>#def cofibration-union-test\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( ( (t , s) : \u2202\u25a1) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s)) \u2192\n      A [ (t \u2261 1\u2082) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (t \u2261 1\u2082) \u2227 (s \u2261 1\u2082) \u21a6 y])\n  :=\n    cofibration-union\n    ( 2 \u00d7 2)\n    ( \\ (t , s) \u2192 (t \u2261 1\u2082) \u2227 \u0394\u00b9 s)\n    ( \\ (t , s) \u2192\n      ((t \u2261 0\u2082) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082)))\n    ( \\ (t , s) \u2192 A)\n    ( \\ (t , s) \u2192\nrecOR\n        ( (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t))\n#def base-hom-rewriting\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s)) \u2192\n      A [ (t \u2261 1\u2082) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (t \u2261 1\u2082) \u2227 (s \u2261 1\u2082) \u21a6 y])\n    ( hom A a y)\n  :=\n    ( ( \\ v \u2192 (\\ r \u2192 v ((1\u2082 , r)))) ,\n      ( ( \\ v (t , s) \u2192 v s , \\ _ \u2192 refl) ,\n        ( \\ v (_ , s) \u2192 v s , \\ _ \u2192 refl)))\n#def base-hom-expansion\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( ( (t , s) : \u2202\u25a1) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( hom A a y)\n  :=\n    equiv-comp\n    ( ( (t , s) : \u2202\u25a1) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s)) \u2192\n      A [ (t \u2261 1\u2082) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (t \u2261 1\u2082) \u2227 (s \u2261 1\u2082) \u21a6 y])\n    ( hom A a y)\n    ( cofibration-union-test A a x y f u)\n    ( base-hom-rewriting A a x y f u)\n#def representable-dhom-from-expansion\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n( \u03a3 ( sq :\n          ( (t , s) : \u2202\u25a1) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s)) ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n( \u03a3 ( v : hom A a y) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    equiv-total-pullback-is-equiv\n    ( ( (t , s) : \u2202\u25a1) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( hom A a y)\n    ( first (base-hom-expansion A a x y f u))\n    ( second (base-hom-expansion A a x y f u))\n    ( \\ v \u2192\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n#def representable-dhom-from-composite-expansion\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n( \u03a3 ( sq :\n          ( (t , s) : \u2202\u25a1) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s)) ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    equiv-right-cancel\n      ( dhom-from-representable A a x y f u)\n( \u03a3 ( sq :\n            ( (t , s) : \u2202\u25a1) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s)) ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n( \u03a3 ( v : hom A a y) ,\n          ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n            A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n                (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n                (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n      ( uncurried-dhom-from-representable A a x y f u)\n      ( representable-dhom-from-expansion A a x y f u)\n#def representable-dhom-from-cofibration-composition\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n( \u03a3 ( sq :\n          ( (t , s) : \u2202\u25a1) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s)) ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    cofibration-composition (2 \u00d7 2) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1\n      ( \\ (t , s) \u2192\n        ( (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082)))\n      ( \\ ts \u2192 A)\n      ( \\ (t , s) \u2192\nrecOR\n          ( (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t))\n#def representable-dhom-from-as-extension-type\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A a x)\n  : Equiv\n      ( dhom-from-representable A a x y f u)\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  :=\n    equiv-right-cancel\n    ( dhom-from-representable A a x y f u)\n    ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n( \u03a3 ( sq :\n          ( (t , s) : \u2202\u25a1) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s)) ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n    ( representable-dhom-from-composite-expansion A a x y f u)\n    ( representable-dhom-from-cofibration-composition A a x y f u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-lifts-transport-and-uniqueness","title":"Covariant lifts, transport, and uniqueness","text":"<p>In a covariant family C over a base type A , a term u : C x may be transported along an arrow f : hom A x y to give a term in C y.</p> RS17, covariant transport from beginning of Section 8.2<pre><code>#def covariant-transport\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n  : C y\n  :=\nfirst (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u))\n</code></pre> <p>For example, if <code>A</code> is a Segal type and <code>a : A</code>, the family <code>C x := hom A a x</code> is covariant as shown above. Transport of an <code>e : C x</code> along an arrow <code>f : hom A x y</code> just yields composition of <code>f</code> with <code>e</code>.</p> RS17, Example 8.14<pre><code>#def compute-covariant-transport-of-hom-family-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( e : hom A a x)\n( f : hom A x y)\n  : covariant-transport A x y f\n      (hom A a) (is-covariant-representable-is-segal A is-segal-A a) e =\n    comp-is-segal A is-segal-A a x y e f\n  :=\nrefl\n</code></pre> RS17, covariant lift from beginning of Section 8.2<pre><code>#def covariant-lift\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n  : ( dhom A x y f C u (covariant-transport A x y f C is-covariant-C u))\n  :=\nsecond (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u))\n#def covariant-uniqueness\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n( lift : dhom-from A x y f C u)\n  : ( covariant-transport A x y f C is-covariant-C u) = (first lift)\n  :=\n    first-path-\u03a3\n    ( C y)\n    ( \\ v \u2192 dhom A x y f C u v)\n    ( center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u))\n    ( lift)\n    ( homotopy-contraction (dhom-from A x y f C u) (is-covariant-C x y f u) lift)\n#def covariant-uniqueness-curried\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n  : ( v : C y)\n  \u2192 ( dhom A x y f C u v)\n  \u2192 ( covariant-transport A x y f C is-covariant-C u) = v\n  :=\n\\ v g \u2192 covariant-uniqueness A x y f C is-covariant-C u (v, g)\n</code></pre> <p>We show that for each <code>v : C y</code>, the map <code>covariant-uniqueness</code> is an equivalence. This follows from the fact that the total types (summed over <code>v : C y</code>) of both sides are contractible.</p> RS17, Lemma 8.15<pre><code>#def is-equiv-total-map-covariant-uniqueness-curried\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n  : is-equiv\n(\u03a3 (v : C y), dhom A x y f C u v)\n(\u03a3 (v : C y), covariant-transport A x y f C is-covariant-C u = v)\n      ( total-map (C y)\n        (dhom A x y f C u)\n        (\\ v \u2192 covariant-transport A x y f C is-covariant-C u = v)\n        (covariant-uniqueness-curried A x y f C is-covariant-C u)\n      )\n  :=\n    is-equiv-are-contr\n(\u03a3 (v : C y), dhom A x y f C u v)\n(\u03a3 (v : C y), covariant-transport A x y f C is-covariant-C u = v)\n      (is-covariant-C x y f u)\n      (is-contr-based-paths (C y) (covariant-transport A x y f C is-covariant-C u))\n      ( total-map (C y)\n        (dhom A x y f C u)\n        (\\ v \u2192 covariant-transport A x y f C is-covariant-C u = v)\n        (covariant-uniqueness-curried A x y f C is-covariant-C u)\n      )\n#def is-equiv-covariant-uniqueness-curried\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n( v : C y)\n  : is-equiv\n      (dhom A x y f C u v)\n      (covariant-transport A x y f C is-covariant-C u = v)\n      (covariant-uniqueness-curried A x y f C is-covariant-C u v)\n  :=\n    is-equiv-fiberwise-is-equiv-total\n      (C y)\n      (dhom A x y f C u)\n      (\\ v' \u2192 covariant-transport A x y f C is-covariant-C u = v')\n      (covariant-uniqueness-curried A x y f C is-covariant-C u)\n      (is-equiv-total-map-covariant-uniqueness-curried A x y f C is-covariant-C u)\n      v\n</code></pre> <p>We compute covariant transport of a substitution.</p> <pre><code>#def compute-covariant-transport-of-substitution\n( A B : U)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( g : B \u2192 A)\n( x y : B)\n( f : hom B x y)\n( u : C (g x))\n  : covariant-transport B x y f (\\ b \u2192 C (g b))\n    ( is-covariant-substitution-is-covariant A B C is-covariant-C g) u\n    =\n    covariant-transport A (g x) (g y) (ap-hom B A g x y f) C\n    ( is-covariant-C) u\n  := refl\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-functoriality","title":"Covariant functoriality","text":"<p>The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law.</p> <pre><code>#def id-dhom\n( A : U)\n( x : A)\n( C : A \u2192 U)\n( u : C x)\n  : dhom A x x (id-hom A x) C u u\n  := \\ t \u2192 u\n</code></pre> RS17, Proposition 8.16, Part 2, Covariant families preserve identities<pre><code>#def id-arr-covariant-transport\n( A : U)\n( x : A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C x)\n  : ( covariant-transport A x x (id-hom A x) C is-covariant-C u) = u\n  :=\n    covariant-uniqueness\n      A x x (id-hom A x) C is-covariant-C u (u , id-dhom A x C u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#natural-transformations","title":"Natural transformations","text":"<p>A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts.</p> RS17, Proposition 8.17, Covariant naturality<pre><code>#def covariant-fiberwise-transformation-application\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C D : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n( u : C x)\n  : dhom-from A x y f D (\u03d5 x u)\n  :=\n    ( ( \u03d5 y (covariant-transport A x y f C is-covariant-C u)) ,\n      ( \\ t \u2192 \u03d5 (f t) (covariant-lift A x y f C is-covariant-C u t)))\n#def naturality-covariant-fiberwise-transformation\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C D : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( is-covariant-D : is-covariant A D)\n( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n( u : C x)\n  : ( covariant-transport A x y f D is-covariant-D (\u03d5 x u)) =\n    ( \u03d5 y (covariant-transport A x y f C is-covariant-C u))\n  :=\n    covariant-uniqueness A x y f D is-covariant-D (\u03d5 x u)\n      ( covariant-fiberwise-transformation-application\n          A x y f C D is-covariant-C \u03d5 u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-equivalence","title":"Covariant equivalence","text":"<p>A family of types that is equivalent to a covariant family is itself covariant.</p> <p>To prove this we first show that the corresponding types of lifts with fixed domain are equivalent:</p> <pre><code>#def equiv-covariant-total-dhom\n( A : U)\n( C : A \u2192 U)\n( x y : A)\n( f : hom A x y)\n  : Equiv\n( (t : \u0394\u00b9) \u2192 C (f t))\n( \u03a3 (u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n  :=\n    ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t)) ,\n      ( ( \\ k t \u2192 (second k) t , \\ h \u2192 refl) ,\n        ( ( \\ k t \u2192 (second k) t , \\ h \u2192 refl))))\n</code></pre> <pre><code>#section dhom-from-equivalence\n#variable A : U\n#variables B C : A \u2192 U\n#variable equiv-BC : (a : A) \u2192 Equiv (B a) (C a)\n#variables x y : A\n#variable f : hom A x y\n#def equiv-total-dhom-equiv uses (A x y)\n  : Equiv ( (t : \u0394\u00b9) \u2192 B (f t)) ((t : \u0394\u00b9) \u2192 C (f t))\n  :=\n    equiv-extensions-BOT-equiv\n      ( extext)\n      ( 2)\n      ( \u0394\u00b9)\n      ( \\ t \u2192 B (f t))\n      ( \\ t \u2192 C (f t))\n      ( \\ t \u2192 equiv-BC (f t))\n#def equiv-total-covariant-dhom-equiv uses (extext equiv-BC)\n  : Equiv\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n( \u03a3 (u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n  :=\n    equiv-triple-comp\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n( (t : \u0394\u00b9) \u2192 B (f t))\n( (t : \u0394\u00b9) \u2192 C (f t))\n( \u03a3 (u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n( inv-equiv\n      ( (t : \u0394\u00b9) \u2192 B (f t))\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n      ( equiv-covariant-total-dhom A B x y f))\n    ( equiv-total-dhom-equiv)\n    ( equiv-covariant-total-dhom A C x y f)\n#def equiv-pullback-total-covariant-dhom-equiv uses (A y)\n  : Equiv\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n( \u03a3 (u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n  :=\n    equiv-total-pullback-is-equiv\n      ( B x)\n      ( C x)\n      ( first (equiv-BC x))\n      ( second (equiv-BC x))\n( \\ u \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n#def is-equiv-to-pullback-total-covariant-dhom-equiv uses (extext A y)\n  : is-equiv\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n    ( \\ (i , h) \u2192 (i , \\ t \u2192 (first (equiv-BC (f t))) (h t)))\n  :=\n    is-equiv-right-factor\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n( \u03a3 (u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n    ( \\ (i , h) \u2192 (i , \\ t \u2192 (first (equiv-BC (f t))) (h t)))\n    ( first (equiv-pullback-total-covariant-dhom-equiv))\n    ( second (equiv-pullback-total-covariant-dhom-equiv))\n    ( second (equiv-total-covariant-dhom-equiv))\n#def equiv-to-pullback-total-covariant-dhom-equiv uses (extext A y)\n  : Equiv\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n( \u03a3 (i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n  :=\n    ( \\ (i , h) \u2192 (i , \\ t \u2192 (first (equiv-BC (f t))) (h t)) ,\n      is-equiv-to-pullback-total-covariant-dhom-equiv)\n#def family-equiv-dhom-family-equiv uses (extext A y)\n(i : B x)\n  : Equiv\n( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])\n( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i])\n  :=\n    family-of-equiv-is-equiv-total\n    ( B x)\n( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 ii]))\n( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) ii]))\n    ( \\ ii h t \u2192 (first (equiv-BC (f t))) (h t))\n    ( is-equiv-to-pullback-total-covariant-dhom-equiv)\n    ( i)\n#end dhom-from-equivalence\n</code></pre> <p>Now we introduce the hypothesis that <code>C</code> is covariant in the form of <code>has-unique-fixed-domain-lifts</code>.</p> <pre><code>#def equiv-has-unique-fixed-domain-lifts uses (extext)\n( A : U)\n( B C : A \u2192 U)\n( equiv-BC : (a : A) \u2192 Equiv (B a) (C a))\n( has-unique-fixed-domain-lifts-C :\n    has-unique-fixed-domain-lifts A C)\n  : has-unique-fixed-domain-lifts A B\n  :=\n\\ x y f i \u2192\n    is-contr-equiv-is-contr'\n( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])\n( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i])\n    ( family-equiv-dhom-family-equiv A B C equiv-BC x y f i)\n    ( has-unique-fixed-domain-lifts-C x y f ((first (equiv-BC x)) i))\n#def equiv-is-covariant uses (extext)\n( A : U)\n( B C : A \u2192 U)\n( equiv-BC : (a : A) \u2192 Equiv (B a) (C a))\n( is-covariant-C : is-covariant A C)\n  : is-covariant A B\n  :=\n    ( first (has-unique-fixed-domain-lifts-iff-is-covariant A B))\n      ( equiv-has-unique-fixed-domain-lifts\n        A B C equiv-BC\n        ( (second (has-unique-fixed-domain-lifts-iff-is-covariant A C))\n          is-covariant-C))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-families","title":"Contravariant families","text":"<p>A family of types over a base type is contravariant if every arrow in the base has a unique lift with specified codomain.</p> <pre><code>#def dhom-to\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( v : C y)\n  : U\n  := ( \u03a3 (u : C x) , dhom A x y f C u v)\n</code></pre> RS17, Definition 8.2, dual form<pre><code>#def is-contravariant\n( A : U)\n( C : A \u2192 U)\n  : U\n  :=\n( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (v : C y) \u2192\n    is-contr (dhom-to A x y f C v)\n</code></pre> The type of contravariant families over a fixed type<pre><code>#def contravariant-family (A : U) : U\n  := ( \u03a3 (C : A \u2192 U) , is-contravariant A C)\n</code></pre> <p>The notion of a contravariant family is stable under substitution into the base.</p> RS17, Remark 8.3, dual form<pre><code>#def is-contravariant-substitution-is-contravariant\n( A B : U)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( g : B \u2192 A)\n  : is-contravariant B (\\ b \u2192 C (g b))\n  := \\ x y f v \u2192 is-contravariant-C (g x) (g y) (ap-hom B A g x y f) v\n</code></pre> <p>The notion of having a unique lift with a fixed codomain may also be expressed by contractibility of the type of extensions along the codomain inclusion into the 1-simplex.</p> <pre><code>#def has-unique-fixed-codomain-lifts\n( A : U)\n( C : A \u2192 U)\n  : U\n  :=\n( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (v : C y) \u2192\n    is-contr ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n</code></pre> <p>These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed codomain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here.</p> <pre><code>#def equiv-lifts-with-fixed-codomain\n( A : U)\n( C : A \u2192 U)\n( x y : A)\n( f : hom A x y)\n( v : C y)\n  : Equiv\n( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n      ( dhom-to A x y f C v)\n  :=\n    ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t)) ,\n      ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl) ,\n        ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl))))\n</code></pre> <p>By the equivalence-invariance of contractibility, this proves the desired logical equivalence</p> <pre><code>#def is-contravariant-has-unique-fixed-codomain-lifts\n( A : U)\n( C : A \u2192 U)\n  : (has-unique-fixed-codomain-lifts A C) \u2192 ( is-contravariant A C)\n  :=\n\\ C-has-unique-lifts x y f v \u2192\n      is-contr-equiv-is-contr\n( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n      ( dhom-to A x y f C v)\n      ( equiv-lifts-with-fixed-codomain A C x y f v)\n      ( C-has-unique-lifts x y f v)\n#def has-unique-fixed-codomain-lifts-is-contravariant\n( A : U)\n( C : A \u2192 U)\n  : (is-contravariant A C) \u2192 (has-unique-fixed-codomain-lifts A C)\n  :=\n\\ is-contravariant-C x y f v \u2192\n      is-contr-equiv-is-contr'\n( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n      ( dhom-to A x y f C v)\n      ( equiv-lifts-with-fixed-codomain A C x y f v)\n      ( is-contravariant-C x y f v)\n</code></pre> RS17, Proposition 8.4<pre><code>#def has-unique-fixed-codomain-lifts-iff-is-contravariant\n( A : U)\n( C : A \u2192 U)\n  : iff\n      ( has-unique-fixed-codomain-lifts A C)\n      ( is-contravariant A C)\n  :=\n    ( is-contravariant-has-unique-fixed-codomain-lifts A C,\n      has-unique-fixed-codomain-lifts-is-contravariant A C)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#representable-contravariant-families","title":"Representable contravariant families","text":"<p>If A is a Segal type and a : A is any term, then the family \\ x \u2192 hom A x a defines a contravariant family over A , and conversely if this family is contravariant for every a : A , then A must be a Segal type. The proof involves a rather lengthy composition of equivalences.</p> <pre><code>#def dhom-contra-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A x a)\n( v : hom A y a)\n  : U\n  := dhom A x y f (\\ z \u2192 hom A z a) u v\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-contra-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( u : hom A x a)\n( v : hom A y a)\n  : Equiv\n    ( dhom-contra-representable A a x y f u v)\n    ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n      A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a])\n  :=\n    curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 (\\ t s \u2192 A)\n      ( \\ (t , s) \u2192\nrecOR\n        ( (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n          (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n          (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a))\n#def dhom-to-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : U\n  := dhom-to A x y f (\\ z \u2192 hom A z a) v\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-to-representable\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n( \u03a3 (u : hom A x a) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n  :=\n    total-equiv-family-of-equiv\n    ( hom A x a)\n    ( \\ u \u2192 dhom-contra-representable A a x y f u v)\n    ( \\ u \u2192\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n    ( \\ u \u2192 uncurried-dhom-contra-representable A a x y f u v)\n#def representable-dhom-to-uncurry-hom2\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n( \u03a3 ( u : hom A x a) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n( \u03a3 (u : hom A x a) ,\n(\u03a3 (d : hom A x a) ,\n        product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n  :=\n    total-equiv-family-of-equiv (hom A x a)\n    ( \\ u \u2192\n      ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n        A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n            (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n            (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n( \\ u \u2192\n      \u03a3 ( d : hom A x a) ,\n        ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n    ( \\ u \u2192 equiv-square-hom2-pushout A x a y a u (id-hom A a) f v)\n#def representable-dhom-to-hom2\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n( \u03a3 (d : hom A x a) ,\n( \u03a3 (u : hom A x a) ,\n        product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n  :=\n    equiv-triple-comp\n    ( dhom-to-representable A a x y f v)\n( \u03a3 ( u : hom A x a) ,\n        ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192\n          A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s ,\n              (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t ,\n              (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n( \u03a3 ( u : hom A x a) ,\n( \u03a3 ( d : hom A x a) ,\n            ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n( \u03a3 ( d : hom A x a) ,\n( \u03a3 ( u : hom A x a) ,\n            ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n    ( uncurried-dhom-to-representable A a x y f v)\n    ( representable-dhom-to-uncurry-hom2 A a x y f v)\n    ( fubini-\u03a3 (hom A x a) (hom A x a)\n      ( \\ u d \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n#def representable-dhom-to-hom2-swap\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n( \u03a3 ( d : hom A x a) ,\n( \u03a3 ( u : hom A x a) ,\n            ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))))\n  :=\n    equiv-comp\n      ( dhom-to-representable A a x y f v)\n( \u03a3 ( d : hom A x a) ,\n( \u03a3 ( u : hom A x a) ,\n              ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n( \u03a3 ( d : hom A x a) ,\n( \u03a3 ( u : hom A x a) ,\n              ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))))\n      ( representable-dhom-to-hom2 A a x y f v)\n      ( total-equiv-family-of-equiv (hom A x a)\n(\\ d \u2192\n          \u03a3 ( u : hom A x a) ,\n            ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n( \\ d \u2192\n          \u03a3 ( u : hom A x a) ,\n            ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))\n        ( \\ d \u2192 total-equiv-family-of-equiv (hom A x a)\n          ( \\ u \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))\n          ( \\ u \u2192 product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))\n          ( \\ u \u2192\n            sym-product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n#def representable-dhom-to-hom2-dist\n( A : U)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n      ( dhom-to-representable A a x y f v)\n( \u03a3 ( d : hom A x a) ,\n          ( product\n            ( hom2 A x y a f v d)\n( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)))\n  :=\n    equiv-right-cancel\n    ( dhom-to-representable A a x y f v)\n( \u03a3 (d : hom A x a) ,\n        ( product\n          ( hom2 A x y a f v d)\n( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)))\n( \u03a3 ( d : hom A x a) ,\n( \u03a3 (u : hom A x a) ,\n          product\n          ( hom2 A x y a f v d)\n          ( hom2 A x a a u (id-hom A a) d)))\n    ( representable-dhom-to-hom2-swap A a x y f v)\n    ( total-equiv-family-of-equiv (hom A x a)\n      ( \\ d \u2192\n        ( product\n          ( hom2 A x y a f v d)\n( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)))\n( \\ d \u2192\n        ( \u03a3 ( u : hom A x a) ,\n            ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))))\n      ( \\ d \u2192\n        ( distributive-product-\u03a3\n          ( hom2 A x y a f v d)\n          ( hom A x a)\n          ( \\ u \u2192 hom2 A x a a u (id-hom A a) d))))\n</code></pre> <p>Now we introduce the hypothesis that A is Segal type.</p> <pre><code>#def representable-dhom-to-path-space-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n( \u03a3 ( d : hom A x a) ,\n        ( product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d))))\n  :=\n    equiv-right-cancel\n    ( dhom-to-representable A a x y f v)\n( \u03a3 ( d : hom A x a) ,\n        ( product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d))))\n( \u03a3 ( d : hom A x a) ,\n        ( product\n          ( hom2 A x y a f v d)\n( \u03a3 (u : hom A x a) , (hom2 A x a a u (id-hom A a) d))))\n    ( representable-dhom-to-hom2-dist A a x y f v)\n    ( total-equiv-family-of-equiv (hom A x a)\n      ( \\ d \u2192 product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d)))\n      ( \\ d \u2192\n        product\n          ( hom2 A x y a f v d)\n( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))\n      ( \\ d \u2192\n        total-equiv-family-of-equiv\n          ( hom2 A x y a f v d)\n( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , (u = d)))\n( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))\n          ( \\ \u03b1 \u2192\n          ( total-equiv-family-of-equiv\n            ( hom A x a)\n            ( \\ u \u2192 (u = d))\n            ( \\ u \u2192 hom2 A x a a u (id-hom A a) d)\n            ( \\ u \u2192 equiv-homotopy-hom2'-is-segal A is-segal-A x a u d)))))\n#def is-segal-representable-dhom-to-hom2\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n( \u03a3 (d : hom A x a) , (hom2 A x y a f v d))\n  :=\n    equiv-comp\n    ( dhom-to-representable A a x y f v)\n( \u03a3 ( d : hom A x a) ,\n        ( product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d))))\n( \u03a3 (d : hom A x a) , (hom2 A x y a f v d))\n    ( representable-dhom-to-path-space-is-segal A is-segal-A a x y f v)\n    ( total-equiv-family-of-equiv\n      ( hom A x a)\n      ( \\ d \u2192 product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d)))\n      ( \\ d \u2192 hom2 A x y a f v d)\n      ( \\ d \u2192 codomain-based-paths-contraction A x y a v f d))\n#def is-segal-representable-dhom-to-contractible\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A x y)\n( v : hom A y a)\n  : is-contr (dhom-to-representable A a x y f v)\n  :=\n    is-contr-equiv-is-contr'\n      ( dhom-to-representable A a x y f v)\n( \u03a3 (d : hom A x a) , (hom2 A x y a f v d))\n      ( is-segal-representable-dhom-to-hom2 A is-segal-A a x y f v)\n      ( is-segal-A x y a f v)\n</code></pre> <p>Finally, we see that contravariant hom families in a Segal type are contravariant.</p> RS17, Proposition 8.13(&lt;-), dual<pre><code>#def is-contravariant-representable-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n  : is-contravariant A (\\ x \u2192 hom A x a)\n  := is-segal-representable-dhom-to-contractible A is-segal-A a\n</code></pre> <p>The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows:</p> RS17, Proposition 8.13(\u2192), dual<pre><code>#def is-segal-is-contravariant-representable\n( A : U)\n( representable-family-is-contravariant : (a : A) \u2192\n    is-contravariant A (\\ x \u2192 hom A x a))\n  : is-segal A\n  :=\n\\ x y z f g \u2192\n      is-contr-base-is-contr-\u03a3\n( \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n( \\ hk \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) (first hk)))\n      ( \\ hk \u2192 (first hk , \\ (t , s) \u2192 first hk t))\n( is-contr-equiv-is-contr'\n        ( \u03a3 ( hk : \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ,\n( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) (first hk)))\n        ( dhom-to-representable A z x y f g)\n        ( inv-equiv\n          ( dhom-to-representable A z x y f g)\n( \u03a3 ( hk : \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ,\n( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) (first hk)))\n          ( equiv-comp\n            ( dhom-to-representable A z x y f g)\n( \u03a3 ( h : hom A x z) ,\n                ( product\n                  ( hom2 A x y z f g h)\n( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) h)))\n( \u03a3 ( hk : \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ,\n( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) (first hk)))\n            ( representable-dhom-to-hom2-dist A z x y f g)\n            ( associative-\u03a3\n              ( hom A x z)\n              ( \\ h \u2192 hom2 A x y z f g h)\n( \\ h _ \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) h)))))\n              ( representable-family-is-contravariant z x y f g))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-lifts-transport-and-uniqueness","title":"Contravariant lifts, transport, and uniqueness","text":"<p>In a contravariant family C over a base type A, a term v : C y may be transported along an arrow f : hom A x y to give a term in C x.</p> RS17, contravariant transport from beginning of Section 8.2<pre><code>#def contravariant-transport\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( v : C y)\n  : C x\n  :=\nfirst\n      ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v))\n</code></pre> RS17, contravariant lift from beginning of Section 8.2<pre><code>#def contravariant-lift\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( v : C y)\n  : ( dhom A x y f C (contravariant-transport A x y f C is-contravariant-C v) v)\n  :=\nsecond\n      ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v))\n#def contravariant-uniqueness\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( v : C y)\n( lift : dhom-to A x y f C v)\n  : ( contravariant-transport A x y f C is-contravariant-C v) = (first lift)\n  :=\n    first-path-\u03a3\n    ( C x)\n    ( \\ u \u2192 dhom A x y f C u v)\n    ( center-contraction\n      ( dhom-to A x y f C v)\n      ( is-contravariant-C x y f v))\n    ( lift)\n    ( homotopy-contraction\n      ( dhom-to A x y f C v)\n      ( is-contravariant-C x y f v)\n      ( lift))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-functoriality","title":"Contravariant functoriality","text":"<p>The contravariant transport operation defines a comtravariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law.</p> RS17, Proposition 8.16, Part 2, dual, Contravariant families preserve identities<pre><code>#def id-arr-contravariant-transport\n( A : U)\n( x : A)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( u : C x)\n  : ( contravariant-transport A x x (id-hom A x) C is-contravariant-C u) = u\n  :=\n    contravariant-uniqueness A x x (id-hom A x) C is-contravariant-C u\n      ( u , id-dhom A x C u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-natural-transformations","title":"Contravariant natural transformations","text":"<p>A fiberwise map between contrvariant families is automatically \"natural\" commuting with the contravariant lifts.</p> RS17, Proposition 8.17, dual, Contravariant naturality<pre><code>#def contravariant-fiberwise-transformation-application\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C D : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n( v : C y)\n  : dhom-to A x y f D (\u03d5 y v)\n  :=\n    ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v) ,\n\\ t \u2192 \u03d5 (f t) (contravariant-lift A x y f C is-contravariant-C v t))\n#def naturality-contravariant-fiberwise-transformation\n( A : U)\n( x y : A)\n( f : hom A x y)\n( C D : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( is-contravariant-D : is-contravariant A D)\n( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n( v : C y)\n  : ( contravariant-transport A x y f D is-contravariant-D (\u03d5 y v)) =\n    ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v))\n  :=\n    contravariant-uniqueness A x y f D is-contravariant-D (\u03d5 y v)\n    ( contravariant-fiberwise-transformation-application\n        A x y f C D is-contravariant-C \u03d5 v)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#two-sided-discrete-fibrations","title":"Two sided discrete fibrations","text":"RS17, Definition 8.28<pre><code>#def is-two-sided-discrete\n( A B : U)\n( C : A \u2192 B \u2192 U)\n  : U\n  :=\n    product\n( (a : A) \u2192 is-covariant B (\\b \u2192 C a b))\n( (b : B) \u2192 is-contravariant A (\\ a \u2192 C a b))\n</code></pre> RS17, Proposition 8.29<pre><code>#def is-two-sided-discrete-hom-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n  : is-two-sided-discrete A A (hom A)\n  :=\n    ( is-covariant-representable-is-segal A is-segal-A ,\n      is-contravariant-representable-is-segal A is-segal-A)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#closure-properties-of-covariance","title":"Closure properties of covariance","text":"RS17, Theorem 8.30<pre><code>#def is-covariant-is-locally-covariant uses (weakfunext)\n( A B : U)\n( C : A \u2192 B \u2192 U)\n( is-locally-covariant : (b : B) \u2192 is-covariant A ( \\ a \u2192 C a b ) )\n  : is-covariant A ( \\ a \u2192 (( b : B ) \u2192 (C a b)))\n  :=\n    is-covariant-has-unique-fixed-domain-lifts\n      ( A)\n( \\ a \u2192 ( b : B ) \u2192 (C a b) )\n( \\ x y f g \u2192\n        is-contr-equiv-is-contr'\n          ( (t : \u0394\u00b9) \u2192 ((b : B) \u2192 C (f t) b) [  t \u2261 0\u2082 \u21a6 g ])\n( (b : B) \u2192 (t : \u0394\u00b9) \u2192 C (f t) b [ t \u2261 0\u2082 \u21a6 g b])\n          ( flip-ext-fun 2 \u0394\u00b9 (\\ t \u2192 t \u2261 0\u2082) B ( \\ t \u2192  C (f t)) ( \\ t \u2192 g))\n( weakfunext B\n            ( \\ b \u2192 ( (t : \u0394\u00b9) \u2192 C (f t) b [ t \u2261 0\u2082 \u21a6 g b] ) )\n            ( \\ b \u2192\n              ( has-unique-fixed-domain-lifts-is-covariant\n                ( A)\n                ( \\ a  \u2192 (C a b))\n                ( is-locally-covariant b))\n             x y f (g b))))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#discrete-fibers","title":"Discrete fibers","text":"<p>The fibers of a covariant fibration over a Segal type are discrete types.</p> RS17, Proposition 8.18<pre><code>#def is-discrete-is-covariant-segal\n( A : U)\n( is-segal-A : is-segal A)\n( C : A \u2192 U)\n( is-cov-C : is-covariant A C)\n( x : A)\n  : is-discrete (C x)\n  :=\n    ( \\ u v \u2192\n    is-equiv-fiberwise-is-equiv-total\n      ( C x)\n      ( \\ v' \u2192 (u = v'))\n      ( hom (C x) u)\n      ( hom-eq (C x) u)\n( is-equiv-are-contr\n        ( \u03a3 (y : (C x)) , u = y)\n( \u03a3 (y : (C x)) , hom (C x) u y)\n        ( is-contr-based-paths (C x) u)\n        ( is-cov-C x x (id-hom A x) u)\n        ( total-map\n          ( C x)\n          ( \\ v' \u2192 u = v')\n          ( hom (C x) u)\n          ( hom-eq (C x) u)))\n      ( v))\n</code></pre> <p>In a Segal type, covariant hom families are covariant, hence representable homs are discrete.</p> RS17, Corollary 8.19<pre><code>#def is-discrete-hom-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n  : is-discrete (hom A x y)\n  :=\n    is-discrete-is-covariant-segal\n      ( A)\n      ( is-segal-A)\n      ( hom A x)\n      ( is-covariant-representable-is-segal A is-segal-A x)\n      ( y)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/","title":"The Yoneda lemma","text":"<p>These formalisations correspond to Section 9 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/*</code> - We require various prerequisites from homotopy type theory, for   instance the axiom of function extensionality.</li> <li><code>03-simplicial-type-theory.rzk.md</code> \u2014 We rely on definitions of simplicies and   their subshapes.</li> <li><code>04-extension-types.rzk.md</code> \u2014 We use the fubini theorem and extension   extensionality.</li> <li><code>05-segal-types.rzk.md</code> - We make heavy use of the notion of Segal types</li> <li><code>08-covariant.rzk.md</code> - We use covariant type families.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#natural-transformations-involving-a-representable-functor","title":"Natural transformations involving a representable functor","text":"<p>Fix a Segal type <code>A</code> and a term <code>a : A</code>. The Yoneda lemma characterizes natural transformations from the representable type family <code>hom A a : A \u2192 U</code> to a covariant type family <code>C : A \u2192 U</code>.</p> <p>Ordinarily, such a natural transformation would involve a family of maps</p> <p><code>\u03d5 : (z : A) \u2192 hom A a z \u2192 C z</code></p> <p>together with a proof of naturality of these components, but by naturality-covariant-fiberwise-transformation naturality is automatic.</p> <pre><code>#def naturality-covariant-fiberwise-representable-transformation\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A a x)\n( g : hom A x y)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  : (covariant-transport A x y g C is-covariant-C (\u03d5 x f)) =\n    (\u03d5 y (comp-is-segal A is-segal-A a x y f g))\n  :=\n    naturality-covariant-fiberwise-transformation A x y g\n      (\\ z \u2192 hom A a z)\n      ( C)\n      ( is-covariant-representable-is-segal A is-segal-A a)\n      ( is-covariant-C)\n      ( \u03d5)\n      ( f)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-maps","title":"The Yoneda maps","text":"<p>For any Segal type <code>A</code> and term <code>a : A</code>, the Yoneda lemma provides an equivalence between the type <code>(z : A) \u2192 hom A a z \u2192 C z</code> of natural transformations out of the functor <code>hom A a</code> and values in an arbitrary covariant family <code>C</code> and the type <code>C a</code>.</p> <p>One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation.</p> <p>The following map, <code>evid</code>, evaluates a natural transformation out of a representable functor at the identity arrow.</p> <pre><code>#def evid\n( A : U)\n( a : A)\n( C : A \u2192 U)\n  : ( (z : A) \u2192 hom A a z \u2192 C z) \u2192 C a\n  := \\ \u03d5 \u2192 \u03d5 a (id-hom A a)\n</code></pre> <p>The inverse map only exists for Segal types.</p> <pre><code>#def yon\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : C a \u2192 ( (z : A) \u2192 hom A a z \u2192 C z)\n  := \\ u x f \u2192 covariant-transport A a x f C is-covariant-C u\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-composites","title":"The Yoneda composites","text":"<p>It remains to show that the Yoneda maps are inverses. One retraction is straightforward:</p> <pre><code>#def evid-yon\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( u : C a)\n  : ( evid A a C) ((yon A is-segal-A a C is-covariant-C) u) = u\n  := id-arr-covariant-transport A a C is-covariant-C u\n</code></pre> <p>The other composite carries <code>\u03d5</code> to an a priori distinct natural transformation. We first show that these are pointwise equal at all <code>x : A</code> and <code>f : hom A a x</code> in two steps.</p> <pre><code>#section yon-evid\n#variable A : U\n#variable is-segal-A : is-segal A\n#variable a : A\n#variable C : A \u2192 U\n#variable is-covariant-C : is-covariant A C\n</code></pre> <p>The composite <code>yon-evid</code> of <code>\u03d5</code> equals <code>\u03d5</code> at all <code>x : A</code> and <code>f : hom A a x</code>.</p> <pre><code>#def yon-evid-twice-pointwise\n( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n( x : A)\n( f : hom A a x)\n  : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f = \u03d5 x f\n  :=\n    concat\n      ( C x)\n      ( ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f)\n      ( \u03d5 x (comp-is-segal A is-segal-A a a x (id-hom A a) f))\n      ( \u03d5 x f)\n      ( naturality-covariant-fiberwise-representable-transformation\n        A is-segal-A a a x (id-hom A a) f C is-covariant-C \u03d5)\n      ( ap\n        ( hom A a x)\n        ( C x)\n        ( comp-is-segal A is-segal-A a a x (id-hom A a) f)\n        ( f)\n        ( \u03d5 x)\n        ( id-comp-is-segal A is-segal-A a x f))\n</code></pre> <p>By <code>funext</code>, these are equals as functions of <code>f</code> pointwise in <code>x</code>.</p> <pre><code>#def yon-evid-once-pointwise uses (funext)\n( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n( x : A)\n  : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x = \u03d5 x\n  :=\n    eq-htpy funext\n      ( hom A a x)\n      ( \\ f \u2192 C x)\n      ( \\ f \u2192 ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f)\n      ( \\ f \u2192 (\u03d5 x f))\n      ( \\ f \u2192 yon-evid-twice-pointwise \u03d5 x f)\n</code></pre> <p>By <code>funext</code> again, these are equal as functions of <code>x</code> and <code>f</code>.</p> <pre><code>#def yon-evid uses (funext)\n( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) = \u03d5\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 (hom A a x \u2192 C x))\n      ( \\ x \u2192 ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x)\n      ( \\ x \u2192 (\u03d5 x))\n      ( \\ x \u2192 yon-evid-once-pointwise \u03d5 x)\n#end yon-evid\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-lemma_1","title":"The Yoneda lemma","text":"<p>The Yoneda lemma says that evaluation at the identity defines an equivalence. This is proven combining the previous steps.</p> RS17, Theorem 9.1<pre><code>#def yoneda-lemma uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : is-equiv ((z : A) \u2192 hom A a z \u2192 C z) (C a) (evid A a C)\n  :=\n    ( ( ( yon A is-segal-A a C is-covariant-C) ,\n        ( yon-evid A is-segal-A a C is-covariant-C)) ,\n      ( ( yon A is-segal-A a C is-covariant-C) ,\n        ( evid-yon A is-segal-A a C is-covariant-C)))\n</code></pre> <p>For later use, we observe that the same proof shows that the inverse map is an equivalence.</p> <pre><code>#def inv-yoneda-lemma uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : is-equiv (C a) ((z : A) \u2192 hom A a z \u2192 C z)\n      ( yon A is-segal-A a C is-covariant-C)\n  :=\n    ( ( ( evid A a C) ,\n        ( evid-yon A is-segal-A a C is-covariant-C)) ,\n      ( ( evid A a C) ,\n        ( yon-evid A is-segal-A a C is-covariant-C)))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#naturality","title":"Naturality","text":"<p>The equivalence of the Yoneda lemma is natural in both <code>a : A</code> and <code>C : A \u2192 U</code>.</p> <p>Naturality in <code>a</code> follows from the fact that the maps <code>evid</code> and <code>yon</code> are fiberwise equivalences between covariant families over <code>A</code>, though it requires some work to prove that the domain is covariant.</p> <pre><code>#def is-covariant-yoneda-domain uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : is-covariant A (\\ a \u2192 (z : A) \u2192 hom A a z \u2192 C z)\n  :=\n    equiv-is-covariant\n    ( extext)\n    ( A)\n( \\ a -&gt; (z : A) \u2192 hom A a z \u2192 C z)\n    ( C)\n    ( \\ a -&gt; (evid A a C , yoneda-lemma A is-segal-A a C is-covariant-C))\n    ( is-covariant-C)\n#def is-natural-in-object-evid uses (funext extext)\n( A : U)\n( is-segal-A : is-segal A)\n( a b : A)\n( f : hom A a b)\n( C : A -&gt; U)\n( is-covariant-C : is-covariant A C)\n( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( covariant-transport A a b f C is-covariant-C (evid A a C \u03d5)) =\n( evid A b C\n\n      ( covariant-transport A a b f\n        ( \\ x -&gt; (z : A) \u2192 hom A x z \u2192 C z)\n        ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) \u03d5))\n  :=\n    naturality-covariant-fiberwise-transformation\n    ( A)\n    ( a)\n    ( b)\n    ( f)\n( \\ x -&gt; (z : A) \u2192 hom A x z \u2192 C z)\n    ( C)\n    ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C)\n    ( is-covariant-C)\n    ( \\ x -&gt; evid A x C)\n    ( \u03d5)\n#def is-natural-in-object-yon uses (funext extext)\n( A : U)\n( is-segal-A : is-segal A)\n( a b : A)\n( f : hom A a b)\n( C : A -&gt; U)\n( is-covariant-C : is-covariant A C)\n( u : C a)\n  : ( covariant-transport\n      A a b f\n      ( \\ x -&gt; (z : A) \u2192 hom A x z \u2192 C z)\n      ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C)\n      ( yon A is-segal-A a C is-covariant-C u)) =\n    ( yon A is-segal-A b C is-covariant-C\n      ( covariant-transport A a b f C is-covariant-C u))\n  :=\n    naturality-covariant-fiberwise-transformation\n    ( A)\n    ( a)\n    ( b)\n    ( f)\n    ( C)\n( \\ x -&gt; (z : A) \u2192 hom A x z \u2192 C z)\n    ( is-covariant-C)\n    ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C)\n    ( \\ x -&gt; yon A is-segal-A x C is-covariant-C)\n    ( u)\n</code></pre> <p>Naturality in <code>C</code> is not automatic but can be proven easily:</p> RS17, Lemma 9.2(i)<pre><code>#def is-natural-in-family-evid\n( A : U)\n( a : A)\n( C D : A \u2192 U)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( \u03c6 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( comp ((z : A) \u2192 hom A a z \u2192 C z) (C a) (D a) (\u03c8 a) (evid A a C)) \u03c6 =\n( comp ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z) (D a)\n    ( evid A a D) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6\n  := refl\n</code></pre> RS17, Lemma 9.2(ii)<pre><code>#def is-natural-in-family-yon-twice-pointwise\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C D : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( is-covariant-D : is-covariant A D)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( u : C a)\n( x : A)\n( f : hom A a x)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x f =\n    ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x f\n  :=\n    naturality-covariant-fiberwise-transformation\n      A a x f C D is-covariant-C is-covariant-D \u03c8 u\n#def is-natural-in-family-yon-once-pointwise uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C D : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( is-covariant-D : is-covariant A D)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( u : C a)\n( x : A)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x =\n    ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x\n  :=\n    eq-htpy funext\n      ( hom A a x)\n      ( \\ f \u2192 D x)\n      ( \\ f \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n          ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x f)\n      ( \\ f \u2192\n        ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x f)\n      ( \\ f \u2192\n        is-natural-in-family-yon-twice-pointwise\n          A is-segal-A a C D is-covariant-C is-covariant-D \u03c8 u x f)\n#def is-natural-in-family-yon uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C D : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( is-covariant-D : is-covariant A D)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( u : C a)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u =\n    ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 hom A a x \u2192 D x)\n      ( \\ x \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n          ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x)\n      ( \\ x \u2192\n        ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x)\n      ( \\ x \u2192\n        is-natural-in-family-yon-once-pointwise\n          A is-segal-A a C D is-covariant-C is-covariant-D \u03c8 u x)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#yoneda-embedding","title":"Yoneda embedding.","text":"Yoneda embedding. RS17, Definition 9.3<pre><code>#def yoneda-embedding\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n  :  hom A a' a \u2192 (z : A) \u2192 hom A a z \u2192 hom A a' z\n  :=\n     yon\n     ( A)\n     ( is-segal-A)\n     ( a)\n     ( hom A a')\n     ( is-covariant-representable-is-segal A is-segal-A a')\n#def compute-yoneda-embedding-evid uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n  : ( yoneda-embedding A is-segal-A a a') ( ( evid A a ( hom A a')) \u03c6) = \u03c6\n  :=\n     yon-evid\n      ( A)\n      ( is-segal-A)\n      ( a)\n      ( hom A a')\n      ( is-covariant-representable-is-segal A is-segal-A a') \u03c6\n#def htpy-compute-yoneda-embedding-evid uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n  : (x : A)\n    \u2192 ( ( yoneda-embedding A is-segal-A a a') ( ( evid A a ( hom A a')) \u03c6)) x\n    = \u03c6 x\n  :=\n     htpy-eq\n      ( A)\n      ( \\ x \u2192 ( hom A a x \u2192 hom A a' x))\n      ( ( yoneda-embedding A is-segal-A a a') ( ( evid A a ( hom A a')) \u03c6 ))\n      ( \u03c6)\n      ( compute-yoneda-embedding-evid A is-segal-A a a' \u03c6)\n#def htpy-yoneda-embedding-evid uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n( x : A)\n  : ( f : hom A a x)\n    \u2192 ( ( yoneda-embedding A is-segal-A a a') ( ( evid A a ( hom A a')) \u03c6)) x f\n    = \u03c6 x f\n  :=\n     htpy-eq\n      ( hom A a x)\n      ( \\ z \u2192 hom A a' x)\n      ( ( ( yoneda-embedding A is-segal-A a a')\n          ( ( evid A a ( hom A a')) \u03c6 )) x)\n      ( \u03c6 x)\n      ( htpy-compute-yoneda-embedding-evid A is-segal-A a a' \u03c6 x)\n#def rev-compute-htpy-yoneda-embedding-evid uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n( x : A)\n( f : hom A a x)\n  : \u03c6 x f\n    = ( ( yoneda-embedding A is-segal-A a a') ( ( evid A a ( hom A a')) \u03c6)) x f\n  :=\n     rev\n      ( hom A a' x)\n      ( ( ( yoneda-embedding A is-segal-A a a')\n          ( ( evid A a ( hom A a')) \u03c6 )) x f)\n      ( \u03c6 x f)\n      ( htpy-yoneda-embedding-evid A is-segal-A a a' \u03c6 x f)\n</code></pre> <p>Define the action by precompostition.</p> <pre><code>#def precomposition-evid-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n  : ( x : A ) \u2192 ( hom A a x \u2192 hom A a' x)\n  := \\ x f \u2192 comp-is-segal A is-segal-A a' a x ( ( evid A a ( hom A a')) \u03c6) f\n</code></pre> <p>The Yoneda embedding coincides with <code>precomposition-evid-is-segal</code>.</p> <pre><code>#def eq-yoneda-embedding-precomposition-evid\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n( x : A)\n( f : hom A a x)\n  : ( ( yoneda-embedding A is-segal-A a a') ( ( evid A a ( hom A a')) \u03c6)) x f\n    = precomposition-evid-is-segal A is-segal-A a a' \u03c6 x f\n  :=\n     compute-covariant-transport-of-hom-family-is-segal\n      ( A)\n      ( is-segal-A)\n      ( a')\n      ( a)\n      ( x)\n      ( (evid A a ( hom A a')) \u03c6)\n      ( f )\n</code></pre> <p>Now we cocatenate the paths to prove the result as stated.</p> <pre><code>#def eq-compute-precomposition-evid uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n( x : A)\n( f : hom A a x)\n  : (\u03c6 x) f = (precomposition-evid-is-segal A is-segal-A a a' \u03c6 x) f\n  :=\n     concat\n      ( hom A a' x)\n      ( \u03c6 x f)\n      ( ( ( yoneda-embedding A is-segal-A a a')\n          ( ( evid A a ( hom A a')) \u03c6 )) x f)\n      ( precomposition-evid-is-segal A is-segal-A a a' \u03c6 x f)\n      ( rev-compute-htpy-yoneda-embedding-evid A is-segal-A a a' \u03c6 x f)\n      ( eq-yoneda-embedding-precomposition-evid A is-segal-A a a' \u03c6 x f)\n#def eq-htpy-precomposition-evid\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n( x : A)\n  : \u03c6 x = precomposition-evid-is-segal A is-segal-A a a' \u03c6 x\n  :=\n     eq-htpy\n      ( funext)\n      ( hom A a x)\n      ( \\ z \u2192 hom A a' x)\n      ( \u03c6 x)\n      ( precomposition-evid-is-segal A is-segal-A a a' \u03c6 x)\n      ( \\ f \u2192 eq-compute-precomposition-evid A is-segal-A a a' \u03c6 x f)\n#def eq-precomposition-evid-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a a' : A)\n( \u03c6 : ( x : A) \u2192 ( hom A a x \u2192 hom A a' x))\n  : \u03c6 = precomposition-evid-is-segal A is-segal-A a a' \u03c6\n  :=\n     eq-htpy\n      ( funext)\n      ( A)\n      ( \\ x \u2192 ( hom A a x \u2192 hom A a' x))\n      ( \u03c6)\n      ( precomposition-evid-is-segal A is-segal-A a a' \u03c6)\n      ( \\ x \u2192 eq-htpy-precomposition-evid A is-segal-A a a' \u03c6 x)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#yoneda-for-contravariant-families","title":"Yoneda for contravariant families","text":"<p>Dually, the Yoneda lemma for contravariant type families characterizes natural transformations from the contravariant family represented by a term <code>a : A</code> in a Segal type to a contravariant type family <code>C : A \u2192 U</code>.</p> <p>By <code>naturality-contravariant-fiberwise-transformation</code> naturality is again automatic.</p> <pre><code>#def naturality-contravariant-fiberwise-representable-transformation\n( A : U)\n( is-segal-A : is-segal A)\n( a x y : A)\n( f : hom A y a)\n( g : hom A x y)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n  : ( contravariant-transport A x y g C is-contravariant-C (\u03d5 y f)) =\n    ( \u03d5 x (comp-is-segal A is-segal-A x y a g f))\n  :=\n    naturality-contravariant-fiberwise-transformation A x y g\n      ( \\ z \u2192 hom A z a) C\n      ( is-contravariant-representable-is-segal A is-segal-A a)\n      ( is-contravariant-C)\n      ( \u03d5)\n      ( f)\n</code></pre> <p>For any Segal type <code>A</code> and term <code>a : A</code>, the contravariant Yoneda lemma provides an equivalence between the type <code>(z : A) \u2192 hom A z a \u2192 C z</code> of natural transformations out of the functor <code>\\ z \u2192 hom A z a</code> and valued in an arbitrary contravariant family <code>C</code> and the type <code>C a</code>.</p> <p>One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the contravariant transport operation.</p> <p>The following map, <code>contra-evid</code> evaluates a natural transformation out of a representable functor at the identity arrow.</p> <pre><code>#def contra-evid\n( A : U)\n( a : A)\n( C : A \u2192 U)\n  : ( (z : A) \u2192 hom A z a \u2192 C z) \u2192 C a\n  := \\ \u03d5 \u2192 \u03d5 a (id-hom A a)\n</code></pre> <p>The inverse map only exists for Segal types and contravariant families.</p> <pre><code>#def contra-yon\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n  : C a \u2192 ((z : A) \u2192 hom A z a \u2192 C z)\n  := \\ v z f \u2192 contravariant-transport A z a f C is-contravariant-C v\n</code></pre> <p>It remains to show that the Yoneda maps are inverses. One retraction is straightforward:</p> <pre><code>#def contra-evid-yon\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( v : C a)\n  : contra-evid A a C ((contra-yon A is-segal-A a C is-contravariant-C) v) = v\n  := id-arr-contravariant-transport A a C is-contravariant-C v\n</code></pre> <p>The other composite carries <code>\u03d5</code> to an a priori distinct natural transformation. We first show that these are pointwise equal at all <code>x : A</code> and <code>f : hom A x a</code> in two steps.</p> <pre><code>#section contra-yon-evid\n#variable A : U\n#variable is-segal-A : is-segal A\n#variable a : A\n#variable C : A \u2192 U\n#variable is-contravariant-C : is-contravariant A C\n</code></pre> <p>The composite <code>contra-yon-evid</code> of <code>\u03d5</code> equals <code>\u03d5</code> at all <code>x : A</code> and <code>f : hom A x a</code>.</p> <pre><code>#def contra-yon-evid-twice-pointwise\n( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n( x : A)\n( f : hom A x a)\n  : ( (contra-yon A is-segal-A a C is-contravariant-C)\n        ((contra-evid A a C) \u03d5)) x f = \u03d5 x f\n  :=\n    concat\n      ( C x)\n      ( ((contra-yon A is-segal-A a C is-contravariant-C)\n            ((contra-evid A a C) \u03d5)) x f)\n      ( \u03d5 x (comp-is-segal A is-segal-A x a a f (id-hom A a)))\n      ( \u03d5 x f)\n      ( naturality-contravariant-fiberwise-representable-transformation\n          A is-segal-A a x a (id-hom A a) f C is-contravariant-C \u03d5)\n      ( ap\n        ( hom A x a)\n        ( C x)\n        ( comp-is-segal A is-segal-A x a a f (id-hom A a))\n        ( f)\n        ( \u03d5 x)\n        ( comp-id-is-segal A is-segal-A x a f))\n</code></pre> <p>By <code>funext</code>, these are equals as functions of <code>f</code> pointwise in <code>x</code>.</p> <pre><code>#def contra-yon-evid-once-pointwise uses (funext)\n( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n( x : A)\n  : ( (contra-yon A is-segal-A a C is-contravariant-C)\n        ( (contra-evid A a C) \u03d5)) x = \u03d5 x\n  :=\n    eq-htpy funext\n      ( hom A x a)\n      ( \\ f \u2192 C x)\n      ( \\ f \u2192\n        ( (contra-yon A is-segal-A a C is-contravariant-C)\n          ( (contra-evid A a C) \u03d5)) x f)\n      ( \\ f \u2192 (\u03d5 x f))\n      ( \\ f \u2192 contra-yon-evid-twice-pointwise \u03d5 x f)\n</code></pre> <p>By <code>funext</code> again, these are equal as functions of <code>x</code> and <code>f</code>.</p> <pre><code>#def contra-yon-evid uses (funext)\n( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n  : contra-yon A is-segal-A a C is-contravariant-C (contra-evid A a C \u03d5) = \u03d5\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 (hom A x a \u2192 C x))\n      ( contra-yon A is-segal-A a C is-contravariant-C (contra-evid A a C \u03d5))\n      ( \u03d5)\n      ( contra-yon-evid-once-pointwise \u03d5)\n#end contra-yon-evid\n</code></pre> <p>The contravariant Yoneda lemma says that evaluation at the identity defines an equivalence.</p> <pre><code>#def contra-yoneda-lemma uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n  : is-equiv ((z : A) \u2192 hom A z a \u2192 C z) (C a) (contra-evid A a C)\n  :=\n    ( ( ( contra-yon A is-segal-A a C is-contravariant-C) ,\n        ( contra-yon-evid A is-segal-A a C is-contravariant-C)) ,\n      ( ( contra-yon A is-segal-A a C is-contravariant-C) ,\n        ( contra-evid-yon A is-segal-A a C is-contravariant-C)))\n</code></pre> <p>For later use, we observe that the same proof shows that the inverse map is an equivalence.</p> <pre><code>#def inv-contra-yoneda-lemma uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n  : is-equiv (C a) ((z : A) \u2192 hom A z a \u2192 C z)\n      ( contra-yon A is-segal-A a C is-contravariant-C)\n  :=\n    ( ( ( contra-evid A a C) ,\n        ( contra-evid-yon A is-segal-A a C is-contravariant-C)) ,\n      ( ( contra-evid A a C) ,\n        ( contra-yon-evid A is-segal-A a C is-contravariant-C)))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#contravariant-naturality","title":"Contravariant naturality","text":"<p>The equivalence of the Yoneda lemma is natural in both <code>a : A</code> and <code>C : A \u2192 U</code>.</p> <p>Naturality in <code>a</code> follows from the fact that the maps <code>evid</code> and <code>yon</code> are fiberwise equivalences between contravariant families over <code>A</code>, though it requires some work, which has not yet been formalized, to prove that the domain is contravariant.</p> <p>Naturality in <code>C</code> is not automatic but can be proven easily:</p> RS17, Lemma 9.2(i), dual<pre><code>#def is-natural-in-family-contra-evid\n( A : U)\n( a : A)\n( C D : A \u2192 U)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( \u03c6 : (z : A) \u2192 hom A z a \u2192 C z)\n  : ( comp ((z : A) \u2192 hom A z a \u2192 C z) (C a) (D a)\n      ( \u03c8 a) (contra-evid A a C)) \u03c6 =\n( comp ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z) (D a)\n      ( contra-evid A a D) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6\n  := refl\n</code></pre> RS17, Lemma 9.2(ii), dual<pre><code>#def is-natural-in-family-contra-yon-twice-pointwise\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C D : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( is-contravariant-D : is-contravariant A D)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( u : C a)\n( x : A)\n( f : hom A x a)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x f =\n    ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n      ( contra-yon A is-segal-A a C is-contravariant-C)) u x f\n  :=\n    naturality-contravariant-fiberwise-transformation\n      A x a f C D is-contravariant-C is-contravariant-D \u03c8 u\n#def is-natural-in-family-contra-yon-once-pointwise uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C D : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( is-contravariant-D : is-contravariant A D)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( u : C a)\n( x : A)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n      (contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x =\n    ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n      (\\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n      (contra-yon A is-segal-A a C is-contravariant-C)) u x\n  :=\n    eq-htpy funext\n      ( hom A x a)\n      ( \\ f \u2192 D x)\n      ( \\ f \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n          ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x f)\n      ( \\ f \u2192\n        ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n        ( contra-yon A is-segal-A a C is-contravariant-C)) u x f)\n      ( \\ f \u2192\n        is-natural-in-family-contra-yon-twice-pointwise\n          A is-segal-A a C D is-contravariant-C is-contravariant-D \u03c8 u x f)\n#def is-natural-in-family-contra-yon uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C D : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n( is-contravariant-D : is-contravariant A D)\n( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n( u : C a)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u =\n    ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n      ( contra-yon A is-segal-A a C is-contravariant-C)) u\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 hom A x a \u2192 D x)\n      ( \\ x \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n          ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x)\n      ( \\ x \u2192\n        ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n        ( contra-yon A is-segal-A a C is-contravariant-C)) u x)\n      ( \\ x \u2192\n        is-natural-in-family-contra-yon-once-pointwise\n          A is-segal-A a C D is-contravariant-C is-contravariant-D \u03c8 u x)\n</code></pre> <p>From a type-theoretic perspective, the Yoneda lemma is a \u201cdirected\u201d version of the \u201ctransport\u201d operation for identity types. This suggests a \u201cdependently typed\u201d generalization of the Yoneda lemma, analogous to the full induction principle for identity types. We prove this as a special case of a result about covariant families over a type with an initial object.</p>"},{"location":"simplicial-hott/09-yoneda.rzk/#initial-objects","title":"Initial objects","text":"<p>A term <code>a</code> in a type <code>A</code> is initial if all of its mapping-out hom types are contractible.</p> RS17, Definition 9.6<pre><code>#def is-initial\n( A : U)\n( a : A)\n  : U\n  := ( x : A) \u2192 is-contr (hom A a x)\n</code></pre> <p>Initial objects satisfy an induction principle relative to covariant families.</p> <pre><code>#section initial-evaluation-equivalence\n#variable A : U\n#variable a : A\n#variable is-initial-a : is-initial A a\n#variable C : A \u2192 U\n#variable is-covariant-C : is-covariant A C\n#def arrows-from-initial\n( x : A)\n  : hom A a x\n  := center-contraction (hom A a x) (is-initial-a x)\n#def identity-component-arrows-from-initial\n  : arrows-from-initial a = id-hom A a\n  := homotopy-contraction (hom A a a) (is-initial-a a) (id-hom A a)\n#def ind-initial uses (is-initial-a)\n( u : C a)\n  : ( x : A) \u2192 C x\n  :=\n\\ x \u2192 covariant-transport A a x (arrows-from-initial x) C is-covariant-C u\n#def has-cov-section-ev-pt uses (is-initial-a)\n  : has-section ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ind-initial) ,\n      ( \\ u \u2192\n        concat\n          ( C a)\n          ( covariant-transport A a a\n            ( arrows-from-initial a) C is-covariant-C u)\n          ( covariant-transport A a a\n            ( id-hom A a) C is-covariant-C u)\n          ( u)\n          ( ap\n            ( hom A a a)\n            ( C a)\n            ( arrows-from-initial a)\n            ( id-hom A a)\n            ( \\ f \u2192\n              covariant-transport A a a f C is-covariant-C u)\n            ( identity-component-arrows-from-initial))\n          ( id-arr-covariant-transport A a C is-covariant-C u)))\n#def ind-initial-ev-pt-pointwise uses (is-initial-a)\n( s : (x : A) \u2192 C x)\n( b : A)\n  : ind-initial (ev-pt A a C s) b = s b\n  :=\n    covariant-uniqueness\n      ( A)\n      ( a)\n      ( b)\n      ( arrows-from-initial b)\n      ( C)\n      ( is-covariant-C)\n      ( ev-pt A a C s)\n      ( ( s b , \\ t \u2192 s (arrows-from-initial b t)))\n#end initial-evaluation-equivalence\n</code></pre> <p>We now prove that induction from an initial element in the base of a covariant family defines an inverse equivalence to evaluation at the element.</p> RS17, Theorem 9.7<pre><code>#def is-equiv-covariant-ev-initial uses (funext)\n( A : U)\n( a : A)\n( is-initial-a : is-initial A a)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n  : is-equiv ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ( ind-initial A a is-initial-a C is-covariant-C) ,\n        ( \\ s \u2192 eq-htpy\n                  funext\n                    ( A)\n                    ( C)\n                    ( ind-initial\n                        A a is-initial-a C is-covariant-C (ev-pt A a C s))\n                    ( s)\n                    ( ind-initial-ev-pt-pointwise\n                        A a is-initial-a C is-covariant-C s))) ,\n      ( has-cov-section-ev-pt A a is-initial-a C is-covariant-C))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#initial-objects-in-slice-categories","title":"Initial objects in slice categories","text":"<p>Recall that the type <code>coslice A a</code> is the type of arrows in <code>A</code> with domain <code>a</code>.</p> <p>We now show that the coslice under <code>a</code> in a Segal type <code>A</code> has an initial object given by the identity arrow at <code>a</code>. This makes use of the following equivalence.</p> <pre><code>#def equiv-hom-in-coslice\n( A : U)\n( a x : A)\n( f : hom A a x)\n  : Equiv\n    ( hom (coslice A a) (a , id-hom A a) (x , f))\n( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a])\n  :=\n    ( \\ h t s \u2192 (second (h s)) t ,\n      (( \\ k s \u2192 ( k 1\u2082 s , \\ t \u2192 k t s) ,\n\\ h \u2192 refl) ,\n      ( \\ k s \u2192 ( k 1\u2082 s , \\ t \u2192 k t s) ,\n\\ k \u2192 refl)))\n</code></pre> <p>Since <code>hom A a</code> is covariant when <code>A</code> is Segal, this latter type is contractible.</p> <pre><code>#def is-contr-is-segal-hom-in-coslice\n( A : U)\n( is-segal-A : is-segal A)\n( a x : A)\n( f : hom A a x)\n  : is-contr ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a])\n  :=\n    ( second (has-unique-fixed-domain-lifts-iff-is-covariant\n                A (\\ z \u2192 hom A a z)))\n      ( is-covariant-representable-is-segal A is-segal-A a)\n      ( a)\n      ( x)\n      ( f)\n      ( id-hom A a)\n</code></pre> <p>This proves the initiality of identity arrows in the coslice of a Segal type.</p> RS17, Lemma 9.8<pre><code>#def is-initial-id-hom-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n  : is-initial (coslice A a) (a , id-hom A a)\n  :=\n    \\ (x , f) \u2192\n    is-contr-equiv-is-contr'\n      ( hom (coslice A a) (a , id-hom A a) (x , f))\n( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a])\n      ( equiv-hom-in-coslice A a x f)\n      ( is-contr-is-segal-hom-in-coslice A is-segal-A a x f)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#dependent-yoneda-lemma","title":"Dependent Yoneda lemma","text":"<p>The dependent Yoneda lemma now follows by specializing these results.</p> <pre><code>#def dependent-evid\n( A : U)\n( a : A)\n( C : (coslice A a) \u2192 U)\n  : ( (p : coslice A a) \u2192 C p) \u2192 C (a , id-hom A a)\n  := \\ s \u2192 s (a , id-hom A a)\n#def dependent-yoneda-lemma' uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : (coslice A a) \u2192 U)\n( is-covariant-C : is-covariant (coslice A a) C)\n  : is-equiv\n( (p : coslice A a) \u2192 C p)\n      ( C (a , id-hom A a))\n      ( dependent-evid A a C)\n  :=\n    is-equiv-covariant-ev-initial\n      ( coslice A a)\n      ( (a , id-hom A a))\n      ( is-initial-id-hom-is-segal A is-segal-A a)\n      ( C)\n      ( is-covariant-C)\n</code></pre> <p>The actual dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map.</p> RS17, Theorem 9.5<pre><code>#def dependent-yoneda-lemma uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : (coslice A a) \u2192 U)\n( is-covariant-C : is-covariant (coslice A a) C)\n  : is-equiv\n( (x : A) \u2192 (f : hom A a x) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( \\ s \u2192 s a (id-hom A a))\n  :=\n    is-equiv-left-factor\n( (p : coslice A a) \u2192 C p)\n( (x : A) \u2192 (f : hom A a x) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( first (equiv-dependent-curry A (\\ z \u2192 hom A a z) (\\ x f \u2192 C (x , f))))\n      ( second (equiv-dependent-curry A (\\ z \u2192 hom A a z) (\\ x f \u2192 C (x , f))))\n      ( \\ s \u2192 s a (id-hom A a))\n      ( dependent-yoneda-lemma' A is-segal-A a C is-covariant-C)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#final-objects","title":"Final objects","text":"<p>A term <code>a</code> in a type <code>A</code> is initial if all of its mapping-out hom types are contractible.</p> <pre><code>#def is-final\n( A : U)\n( a : A)\n  : U\n  := (x : A) \u2192 is-contr (hom A x a)\n</code></pre> <p>Final objects satisfy an induction principle relative to contravariant families.</p> <pre><code>#section final-evaluation-equivalence\n#variable A : U\n#variable a : A\n#variable is-final-a : is-final A a\n#variable C : A \u2192 U\n#variable is-contravariant-C : is-contravariant A C\n#def arrows-to-final\n( x : A)\n  : hom A x a\n  := center-contraction (hom A x a) (is-final-a x)\n#def identity-component-arrows-to-final\n  : arrows-to-final a = id-hom A a\n  := homotopy-contraction (hom A a a) (is-final-a a) (id-hom A a)\n#def ind-final uses (is-final-a)\n( u : C a)\n  : ( x : A) \u2192 C x\n  :=\n\\ x \u2192\n    contravariant-transport A x a (arrows-to-final x) C is-contravariant-C u\n#def has-contra-section-ev-pt uses (is-final-a)\n  : has-section ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ind-final) ,\n      ( \\ u \u2192\n        concat\n          ( C a)\n          ( contravariant-transport A a a\n            ( arrows-to-final a) C is-contravariant-C u)\n          ( contravariant-transport A a a\n            ( id-hom A a) C is-contravariant-C u)\n          ( u)\n          ( ap\n            ( hom A a a)\n            ( C a)\n            ( arrows-to-final a)\n            ( id-hom A a)\n            ( \\ f \u2192\n              contravariant-transport A a a f C is-contravariant-C u)\n            ( identity-component-arrows-to-final))\n          ( id-arr-contravariant-transport A a C is-contravariant-C u)))\n#def ind-final-ev-pt-pointwise uses (is-final-a)\n( s : (x : A) \u2192 C x)\n( b : A)\n  : ind-final (ev-pt A a C s) b = s b\n  :=\n    contravariant-uniqueness\n      ( A)\n      ( b)\n      ( a)\n      ( arrows-to-final b)\n      ( C)\n      ( is-contravariant-C)\n      ( ev-pt A a C s)\n      ( ( s b , \\ t \u2192 s (arrows-to-final b t)))\n#end final-evaluation-equivalence\n</code></pre> <p>We now prove that induction from a final element in the base of a contravariant family defines an inverse equivalence to evaluation at the element.</p> RS17, Theorem 9.7, dual<pre><code>#def is-equiv-contravariant-ev-final uses (funext)\n( A : U)\n( a : A)\n( is-final-a : is-final A a)\n( C : A \u2192 U)\n( is-contravariant-C : is-contravariant A C)\n  : is-equiv ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ( ind-final A a is-final-a C is-contravariant-C) ,\n        ( \\ s \u2192 eq-htpy\n                  funext\n                    ( A)\n                    ( C)\n                    ( ind-final\n                        A a is-final-a C is-contravariant-C (ev-pt A a C s))\n                    ( s)\n                    ( ind-final-ev-pt-pointwise\n                        A a is-final-a C is-contravariant-C s))) ,\n      ( has-contra-section-ev-pt A a is-final-a C is-contravariant-C))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#final-objects-in-slice-categories","title":"Final objects in slice categories","text":"<p>Recall that the type <code>slice A a</code> is the type of arrows in <code>A</code> with codomain <code>a</code>.</p> <p>We now show that the slice over <code>a</code> in a Segal type <code>A</code> has a final object given by the identity arrow at <code>a</code>. This makes use of the following equivalence.</p> <pre><code>#def equiv-hom-in-slice\n( A : U)\n( a x : A)\n( f : hom A x a)\n  : Equiv\n    ( hom (slice A a) (x , f) (a , id-hom A a))\n( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a])\n  :=\n    ( \\ h t s \u2192 (second (h s)) t ,\n      (( \\ k s \u2192 ( k 0\u2082 s , \\ t \u2192 k t s) ,\n\\ h \u2192 refl) ,\n      ( \\ k s \u2192 ( k 0\u2082 s , \\ t \u2192 k t s) ,\n\\ k \u2192 refl)))\n</code></pre> <p>Since <code>\\ z \u2192 hom A z a</code> is contravariant when <code>A</code> is Segal, this latter type is contractible.</p> <pre><code>#def is-contr-is-segal-hom-in-slice\n( A : U)\n( is-segal-A : is-segal A)\n( a x : A)\n( f : hom A x a)\n  : is-contr ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a])\n  :=\n    ( second (has-unique-fixed-codomain-lifts-iff-is-contravariant\n                A (\\ z \u2192 hom A z a)))\n      ( is-contravariant-representable-is-segal A is-segal-A a)\n      ( x)\n      ( a)\n      ( f)\n      ( id-hom A a)\n</code></pre> <p>This proves the finality of identity arrows in the slice of a Segal type.</p> RS17, Lemma 9.8, dual<pre><code>#def is-final-id-hom-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n  : is-final (slice A a) (a , id-hom A a)\n  :=\n    \\ (x , f) \u2192\n    is-contr-equiv-is-contr'\n      ( hom (slice A a) (x , f) (a , id-hom A a))\n( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a])\n      ( equiv-hom-in-slice A a x f)\n      ( is-contr-is-segal-hom-in-slice A is-segal-A a x f)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#contravariant-dependent-yoneda-lemma","title":"Contravariant Dependent Yoneda lemma","text":"<p>The contravariant version of the dependent Yoneda lemma now follows by specializing these results.</p> <pre><code>#def contra-dependent-evid\n( A : U)\n( a : A)\n( C : (slice A a) \u2192 U)\n  : ((p : slice A a) \u2192 C p) \u2192 C (a , id-hom A a)\n  := \\ s \u2192 s (a , id-hom A a)\n#def contra-dependent-yoneda-lemma' uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : (slice A a) \u2192 U)\n( is-contravariant-C : is-contravariant (slice A a) C)\n  : is-equiv\n( (p : slice A a) \u2192 C p)\n      ( C (a , id-hom A a))\n      ( contra-dependent-evid A a C)\n  :=\n    is-equiv-contravariant-ev-final\n      ( slice A a)\n      ( (a , id-hom A a))\n      ( is-final-id-hom-is-segal A is-segal-A a)\n      ( C)\n      ( is-contravariant-C)\n</code></pre> <p>The actual contravariant dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map.</p> RS17, Theorem 9.5, dual<pre><code>#def contra-dependent-yoneda-lemma uses (funext)\n( A : U)\n( is-segal-A : is-segal A)\n( a : A)\n( C : (slice A a) \u2192 U)\n( is-contravariant-C : is-contravariant (slice A a) C)\n  : is-equiv\n( (x : A) \u2192 (f : hom A x a) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( \\ s \u2192 s a (id-hom A a))\n  :=\n    is-equiv-left-factor\n( (p : slice A a) \u2192 C p)\n( (x : A) \u2192 (f : hom A x a) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( first (equiv-dependent-curry A (\\ z \u2192 hom A z a) (\\ x f \u2192 C (x , f))))\n      ( second (equiv-dependent-curry A (\\ z \u2192 hom A z a) (\\ x f \u2192 C (x , f))))\n      ( \\ s \u2192 s a (id-hom A a))\n      ( contra-dependent-yoneda-lemma'\n          A is-segal-A a C is-contravariant-C)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#representable-families","title":"Representable Families","text":"<p>A covariant family is representable if it is fiberweise equivalent to covariant homs. In order to check if this is the case, it is not necessary to know if the family is covariant or not.</p> <pre><code>#def is-representable-family\n( A : U)\n( C : A \u2192 U)\n  : U\n  := \u03a3 (a : A) , (x : A) \u2192 (Equiv (hom A a x) (C x))\n</code></pre> <p>The definition makes it slightly awkward to access the actual equivalence, so we give a helper function.</p> <pre><code>#def equiv-for-is-representable-family\n( A : U)\n( C : A \u2192 U)\n( is-rep-C : is-representable-family A C)\n  : (x : A) \u2192 (hom A (first is-rep-C) x) \u2192 (C x)\n  := \\ x \u2192 first((second (is-rep-C)) x)\n</code></pre> <p>RS Proposition 9.10 gives an if and only if condition for a covariant family <code>C : A \u2192 U</code> to be representable. The condition is that the type <code>\u03a3 (x : A) , C x</code> has an initial object. For convenience, we give this condition a name.</p> <pre><code>#def has-initial-tot\n( A : U)\n( C : A \u2192 U)\n  : U\n  := \u03a3 ((a , u) : \u03a3 (x : A) , (C x))\n      , is-initial (\u03a3 (x : A) , (C x)) (a , u)\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/","title":"Rezk types","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Some of the definitions in this file rely on function extensionality, extension extensionality and weak function extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n#assume weakfunext : WeakFunExt\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#isomorphisms","title":"Isomorphisms","text":"<pre><code>#def has-retraction-arrow\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n  : U\n  := ( comp-is-segal A is-segal-A x y x f g) =_{hom A x x} (id-hom A x)\n#def Retraction-arrow\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : U\n  := \u03a3 ( g : hom A y x) , ( has-retraction-arrow A is-segal-A x y f g)\n#def has-section-arrow\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( h : hom A y x)\n  : U\n  := ( comp-is-segal A is-segal-A y x y h f) =_{hom A y y} (id-hom A y)\n#def Section-arrow\n(A : U)\n(is-segal-A : is-segal A)\n(x y : A)\n(f : hom A x y)\n  : U\n  := \u03a3 (h : hom A y x) , (has-section-arrow A is-segal-A x y f h)\n#def is-iso-arrow\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : U\n  :=\n    product\n    ( Retraction-arrow A is-segal-A x y f)\n    ( Section-arrow A is-segal-A x y f)\n#def Iso\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n  : U\n  := \u03a3 ( f : hom A x y) , is-iso-arrow A is-segal-A x y f\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#invertible-arrows","title":"Invertible arrows","text":"<p>We now show that <code>f : hom A a x</code> is an isomorphism if and only if it is invertible, meaning <code>f</code> has a two-sided composition inverse <code>g : hom A x a</code>.</p> <pre><code>#def has-inverse-arrow\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : U\n  :=\n\u03a3 ( g : hom A y x) ,\n      product\n      ( has-retraction-arrow A is-segal-A x y f g)\n      ( has-section-arrow A is-segal-A x y f g)\n#def is-iso-arrow-has-inverse-arrow\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : ( has-inverse-arrow A is-segal-A x y f) \u2192 (is-iso-arrow A is-segal-A x y f)\n  :=\n    ( \\ (g , (p , q)) \u2192 ((g , p) , (g , q)))\n#def has-inverse-arrow-is-iso-arrow uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : (is-iso-arrow A is-segal-A x y f) \u2192 (has-inverse-arrow A is-segal-A x y f)\n  :=\n    ( \\ ((g , p) , (h , q)) \u2192\n      ( g ,\n        ( p ,\n          ( concat\n            ( hom A y y)\n            ( comp-is-segal A is-segal-A y x y g f)\n            ( comp-is-segal A is-segal-A y x y h f)\n            ( id-hom A y)\n            ( postwhisker-homotopy-is-segal A is-segal-A y x y g h f\n              ( alternating-quintuple-concat\n                ( hom A y x)\n                ( g)\n                ( comp-is-segal A is-segal-A y y x (id-hom A y) g)\n                ( rev\n                  ( hom A y x)\n                  ( comp-is-segal A is-segal-A y y x (id-hom A y) g)\n                  ( g)\n                  ( id-comp-is-segal A is-segal-A y x g))\n                ( comp-is-segal A is-segal-A y y x\n                  ( comp-is-segal A is-segal-A y x y h f) ( g))\n                ( postwhisker-homotopy-is-segal A is-segal-A y y x\n                  ( id-hom A y)\n                  ( comp-is-segal A is-segal-A y x y h f)\n                  ( g)\n                  ( rev\n                    ( hom A y y)\n                    ( comp-is-segal A is-segal-A y x y h f)\n                    ( id-hom A y)\n                    ( q)))\n                ( comp-is-segal A is-segal-A y x x\n                  ( h)\n                  ( comp-is-segal A is-segal-A x y x f g))\n                ( associative-is-segal extext A is-segal-A y x y x h f g)\n                ( comp-is-segal A is-segal-A y x x h (id-hom A x))\n                ( prewhisker-homotopy-is-segal A is-segal-A y x x h\n                  ( comp-is-segal A is-segal-A x y x f g)\n                  ( id-hom A x) p)\n                ( h)\n                ( comp-id-is-segal A is-segal-A y x h)))\n            ( q)))))\n</code></pre> RS17, Proposition 10.1<pre><code>#def inverse-iff-iso-arrow uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : iff (has-inverse-arrow A is-segal-A x y f) (is-iso-arrow A is-segal-A x y f)\n  :=\n    ( is-iso-arrow-has-inverse-arrow A is-segal-A x y f ,\n      has-inverse-arrow-is-iso-arrow A is-segal-A x y f)\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#being-an-isomorphism-is-a-proposition","title":"Being an isomorphism is a proposition","text":"<p>The predicate <code>is-iso-arrow</code> is a proposition.</p> <pre><code>#def has-retraction-postcomp-has-retraction uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n  : ( z : A) \u2192\n    has-retraction (hom A z x) (hom A z y)\n      ( postcomp-is-segal A is-segal-A x y f z)\n  :=\n\\ z \u2192\n    ( ( postcomp-is-segal A is-segal-A y x g z) ,\n\\ k \u2192\n      ( triple-concat\n        ( hom A z x)\n        ( comp-is-segal A is-segal-A z y x\n          ( comp-is-segal A is-segal-A z x y k f) g)\n        ( comp-is-segal A is-segal-A z x x\n          k ( comp-is-segal A is-segal-A x y x f g))\n        ( comp-is-segal A is-segal-A z x x k (id-hom A x))\n        ( k)\n        ( associative-is-segal extext A is-segal-A z x y x k f g)\n        ( prewhisker-homotopy-is-segal A is-segal-A z x x k\n          ( comp-is-segal A is-segal-A x y x f g) (id-hom A x) gg)\n        ( comp-id-is-segal A is-segal-A z x k)))\n#def has-section-postcomp-has-section uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : ( z : A) \u2192\n    has-section (hom A z x) (hom A z y) (postcomp-is-segal A is-segal-A x y f z)\n  :=\n\\ z \u2192\n    ( ( postcomp-is-segal A is-segal-A y x h z) ,\n\\ k \u2192\n        ( triple-concat\n          ( hom A z y)\n          ( comp-is-segal A is-segal-A z x y\n            ( comp-is-segal A is-segal-A z y x k h) f)\n          ( comp-is-segal A is-segal-A z y y\n            k (comp-is-segal A is-segal-A y x y h f))\n          ( comp-is-segal A is-segal-A z y y k (id-hom A y))\n          ( k)\n          ( associative-is-segal extext A is-segal-A z y x y k h f)\n          ( prewhisker-homotopy-is-segal A is-segal-A z y y k\n            ( comp-is-segal A is-segal-A y x y h f) (id-hom A y) hh)\n          ( comp-id-is-segal A is-segal-A z y k)))\n#def is-equiv-postcomp-is-iso uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : (z : A) \u2192\n    is-equiv (hom A z x) (hom A z y) (postcomp-is-segal A is-segal-A x y f z)\n  :=\n\\ z \u2192\n    ( ( has-retraction-postcomp-has-retraction A is-segal-A x y f g gg z) ,\n      ( has-section-postcomp-has-section A is-segal-A x y f h hh z))\n#def has-retraction-precomp-has-section uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : (z : A) \u2192\n    has-retraction (hom A y z) (hom A x z)\n      ( precomp-is-segal A is-segal-A x y f z)\n  :=\n\\ z \u2192\n    ( ( precomp-is-segal A is-segal-A y x h z) ,\n\\ k \u2192\n        ( triple-concat\n          ( hom A y z)\n          ( comp-is-segal A is-segal-A y x z\n            h (comp-is-segal A is-segal-A x y z f k))\n          ( comp-is-segal A is-segal-A y y z\n            ( comp-is-segal A is-segal-A y x y h f) k)\n          ( comp-is-segal A is-segal-A y y z (id-hom A y) k)\n          ( k)\n          ( rev\n            ( hom A y z)\n            ( comp-is-segal A is-segal-A y y z\n              ( comp-is-segal A is-segal-A y x y h f) k)\n            ( comp-is-segal A is-segal-A y x z\n              h (comp-is-segal A is-segal-A x y z f k))\n            ( associative-is-segal extext A is-segal-A y x y z h f k))\n          ( postwhisker-homotopy-is-segal A is-segal-A y y z\n            ( comp-is-segal A is-segal-A y x y h f)\n            ( id-hom A y) k hh)\n          ( id-comp-is-segal A is-segal-A y z k)\n        )\n    )\n#def has-section-precomp-has-retraction uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n  : (z : A) \u2192\n    has-section (hom A y z) (hom A x z) (precomp-is-segal A is-segal-A x y f z)\n  :=\n\\ z \u2192\n    ( ( precomp-is-segal A is-segal-A y x g z) ,\n\\ k \u2192\n        ( triple-concat\n          ( hom A x z)\n          ( comp-is-segal A is-segal-A x y z\n            f (comp-is-segal A is-segal-A y x z g k))\n          ( comp-is-segal A is-segal-A x x z\n            ( comp-is-segal A is-segal-A x y x f g) k)\n          ( comp-is-segal A is-segal-A x x z\n            ( id-hom A x) k)\n          ( k)\n          ( rev\n            ( hom A x z)\n            ( comp-is-segal A is-segal-A x x z\n              ( comp-is-segal A is-segal-A x y x f g) k)\n            ( comp-is-segal A is-segal-A x y z\n              f (comp-is-segal A is-segal-A y x z g k))\n            ( associative-is-segal extext A is-segal-A x y x z f g k))\n          ( postwhisker-homotopy-is-segal A is-segal-A x x z\n            ( comp-is-segal A is-segal-A x y x f g)\n            ( id-hom A x)\n            ( k)\n            ( gg))\n          ( id-comp-is-segal A is-segal-A x z k)))\n#def is-equiv-precomp-is-iso uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : (z : A) \u2192\n    is-equiv (hom A y z) (hom A x z) (precomp-is-segal A is-segal-A x y f z)\n  :=\n\\ z \u2192\n      ( ( has-retraction-precomp-has-section A is-segal-A x y f h hh z) ,\n        ( has-section-precomp-has-retraction A is-segal-A x y f g gg z))\n#def is-contr-Retraction-arrow-is-iso uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : is-contr (Retraction-arrow A is-segal-A x y f)\n  :=\n    ( is-contr-map-is-equiv\n      ( hom A y x)\n      ( hom A x x)\n      ( precomp-is-segal A is-segal-A x y f x)\n      ( is-equiv-precomp-is-iso A is-segal-A x y f g gg h hh x))\n    ( id-hom A x)\n#def is-contr-Section-arrow-is-iso uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : is-contr (Section-arrow A is-segal-A x y f)\n  :=\n    ( is-contr-map-is-equiv\n      ( hom A y x)\n      ( hom A y y)\n      ( postcomp-is-segal A is-segal-A x y f y)\n      ( is-equiv-postcomp-is-iso A is-segal-A x y f g gg h hh y))\n    ( id-hom A y)\n#def is-contr-is-iso-arrow-is-iso uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n( g : hom A y x)\n( gg : has-retraction-arrow A is-segal-A x y f g)\n( h : hom A y x)\n( hh : has-section-arrow A is-segal-A x y f h)\n  : is-contr (is-iso-arrow A is-segal-A x y f)\n  :=\n    ( is-contr-product\n      ( Retraction-arrow A is-segal-A x y f)\n      ( Section-arrow A is-segal-A x y f)\n      ( is-contr-Retraction-arrow-is-iso A is-segal-A x y f g gg h hh)\n      ( is-contr-Section-arrow-is-iso A is-segal-A x y f g gg h hh))\n</code></pre> RS17, Proposition 10.2<pre><code>#def is-prop-is-iso-arrow uses (extext)\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n( f : hom A x y)\n  : (is-prop (is-iso-arrow A is-segal-A x y f))\n  :=\n    ( is-prop-is-contr-is-inhabited\n      ( is-iso-arrow A is-segal-A x y f)\n      ( \\ is-isof \u2192\n        ( is-contr-is-iso-arrow-is-iso A is-segal-A x y f\n          ( first (first is-isof))\n          ( second (first is-isof))\n          ( first (second is-isof))\n          ( second (second is-isof)))))\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#isomorphism-extensionality","title":"Isomorphism extensionality","text":"RS17, Proposition 10.3<pre><code>#def ev-components-nat-trans-preserves-iso uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-segal-A : (x : X) \u2192 is-segal (A x))\n( f g : (x : X) \u2192 A x)\n( \u03b1 : nat-trans X A f g)\n  : ( is-iso-arrow\n      ( (x : X) \u2192 A x)\n      ( is-segal-function-type funext X A is-segal-A) f g \u03b1) \u2192\n( x : X) \u2192\n    ( is-iso-arrow (A x) (is-segal-A x) (f x) (g x)\n      ( ev-components-nat-trans X A f g \u03b1 x))\n  :=\n    \\ ((\u03b2 , p) , (\u03b3 , q)) \u2192\n\\ x \u2192\n    ( ( ( ev-components-nat-trans X A g f \u03b2 x) ,\n        ( triple-concat\n          ( hom (A x) (f x) (f x))\n          ( comp-is-segal (A x) (is-segal-A x) (f x) (g x) (f x)\n            ( ev-components-nat-trans X A f g \u03b1 x)\n            ( ev-components-nat-trans X A g f \u03b2 x))\n( ev-components-nat-trans X A f f\n            ( comp-is-segal\n              ( (x' : X) \u2192 (A x'))\n              ( is-segal-function-type funext X A is-segal-A) f g f \u03b1 \u03b2)\n            ( x))\n( ev-components-nat-trans X A f f (id-hom ((x' : X) \u2192 (A x')) f) x)\n          ( id-hom (A x) (f x))\n          ( comp-components-comp-nat-trans-is-segal\n            funext X A is-segal-A f g f \u03b1 \u03b2 x)\n          ( ap\n            ( nat-trans X A f f)\n            ( hom (A x) (f x) (f x))\n( comp-is-segal\n              ( (x' : X) \u2192 (A x'))\n              ( is-segal-function-type funext X A is-segal-A) f g f \u03b1 \u03b2)\n( id-hom ((x' : X) \u2192 (A x')) f)\n            (\\ \u03b1' \u2192 ev-components-nat-trans X A f f \u03b1' x)\n            ( p))\n          ( id-arr-components-id-nat-trans X A f x))) ,\n      ( ( ev-components-nat-trans X A g f \u03b3 x) ,\n        ( triple-concat\n          (hom (A x) (g x) (g x))\n          ( comp-is-segal (A x) (is-segal-A x) (g x) (f x) (g x)\n            ( ev-components-nat-trans X A g f \u03b3 x)\n            ( ev-components-nat-trans X A f g \u03b1 x))\n( ev-components-nat-trans X A g g\n            ( comp-is-segal\n              ( (x' : X) \u2192 (A x'))\n              ( is-segal-function-type funext X A is-segal-A) g f g \u03b3 \u03b1)\n            ( x))\n( ev-components-nat-trans X A g g (id-hom ((x' : X) \u2192 (A x')) g) x)\n          ( id-hom (A x) (g x))\n          ( comp-components-comp-nat-trans-is-segal\n            funext X A is-segal-A g f g \u03b3 \u03b1 x)\n          ( ap\n            ( nat-trans X A g g)\n            ( hom (A x) (g x) (g x))\n( comp-is-segal\n              ( (x' : X) \u2192 (A x'))\n              ( is-segal-function-type funext X A is-segal-A) g f g \u03b3 \u03b1)\n( id-hom ((x' : X) \u2192 (A x')) g)\n            ( \\ \u03b1' \u2192 ev-components-nat-trans X A g g \u03b1' x)\n            ( q))\n          ( id-arr-components-id-nat-trans X A g x))))\n#def nat-trans-nat-trans-components-preserves-iso-helper uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-segal-A : (x : X) \u2192 is-segal (A x))\n( f g : (x : X) \u2192 A x)\n( \u03b1 : nat-trans X A f g)\n( \u03b2 : nat-trans X A g f)\n  : ( ( x : X) \u2192\n      ( comp-is-segal (A x) (is-segal-A x) (f x) (g x) (f x)\n        ( ev-components-nat-trans X A f g \u03b1 x)\n        ( ev-components-nat-trans X A g f \u03b2 x)) =\n      (id-hom (A x) (f x))) \u2192\n( comp-is-segal\n      ( (x' : X) \u2192 A x')\n      ( is-segal-function-type funext X A is-segal-A)\n      f g f \u03b1 \u03b2) =\n(id-hom ((x' : X) \u2192 A x') f)\n  :=\n\\ H \u2192\n    ap\n      ( nat-trans-components X A f f)\n      ( nat-trans X A f f)\n( \\ x \u2192\n        ev-components-nat-trans X A f f\n          ( comp-is-segal\n            ( (x' : X) \u2192 A x')\n            ( is-segal-function-type funext X A is-segal-A)\n            f g f \u03b1 \u03b2)\n          ( x))\n( \\ x \u2192 ev-components-nat-trans X A f f (id-hom ((x' : X) \u2192 A x') f) x)\n( first\n        ( has-inverse-is-equiv\n          ( hom ((x' : X) \u2192 A x') f f)\n( (x : X) \u2192 hom (A x) (f x) (f x))\n          ( ev-components-nat-trans X A f f)\n          ( is-equiv-ev-components-nat-trans X A f f)))\n      ( eq-htpy funext X\n        ( \\ x \u2192 (hom (A x) (f x) (f x)))\n( \\ x \u2192\n          ( ev-components-nat-trans X A f f\n            ( comp-is-segal\n              ( (x' : X) \u2192 A x')\n              ( is-segal-function-type funext X A is-segal-A)\n              f g f \u03b1 \u03b2)\n            ( x)))\n        ( \\ x \u2192 (id-hom (A x) (f x)))\n        ( \\ x \u2192\n          ( triple-concat\n            ( hom (A x) (f x) (f x))\n( ev-components-nat-trans X A f f\n              ( comp-is-segal\n                ( (x' : X) \u2192 A x')\n                ( is-segal-function-type funext X A is-segal-A)\n                f g f \u03b1 \u03b2)\n              ( x))\n            ( comp-is-segal (A x) (is-segal-A x) (f x) (g x) (f x)\n              ( ev-components-nat-trans X A f g \u03b1 x)\n              ( ev-components-nat-trans X A g f \u03b2 x))\n            ( id-hom (A x) (f x))\n( ev-components-nat-trans X A f f (id-hom ((x' : X) \u2192 A x') f) x)\n            ( rev\n              (hom (A x) (f x) (f x))\n              ( comp-is-segal (A x) (is-segal-A x) (f x) (g x) (f x)\n                ( ev-components-nat-trans X A f g \u03b1 x)\n                ( ev-components-nat-trans X A g f \u03b2 x))\n( ev-components-nat-trans X A f f\n                ( comp-is-segal\n                  ( (x' : X) \u2192 A x')\n                  ( is-segal-function-type funext X A is-segal-A)\n                  f g f \u03b1 \u03b2)\n                ( x))\n              ( comp-components-comp-nat-trans-is-segal\n                funext X A is-segal-A f g f \u03b1 \u03b2 x))\n            ( H x)\n            ( rev\n              ( hom (A x) (f x) (f x))\n( ev-components-nat-trans X A f f (id-hom ((x' : X) \u2192 A x') f) x)\n              ( id-hom (A x) (f x))\n              ( id-arr-components-id-nat-trans X A f x)))))\n#def nat-trans-nat-trans-components-preserves-iso uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-segal-A : (x : X) \u2192 is-segal (A x))\n( f g : (x : X) \u2192 A x)\n( \u03b1 : nat-trans X A f g)\n  : ( ( x : X) \u2192\n      ( is-iso-arrow (A x) (is-segal-A x) (f x) (g x)\n        ( ev-components-nat-trans X A f g \u03b1 x))) \u2192\n( is-iso-arrow\n      ( (x' : X) \u2192 A x')\n      ( is-segal-function-type funext X A is-segal-A) f g \u03b1)\n  :=\n\\ H \u2192\n    ( ( \\ t x \u2192 (first (first (H x))) t ,\n        nat-trans-nat-trans-components-preserves-iso-helper X A is-segal-A f g\n          ( \u03b1)\n          ( \\ t x \u2192 (first (first (H x))) t)\n          ( \\ x \u2192 (second (first (H x))))) ,\n      ( \\ t x \u2192 (first (second (H x))) t ,\n        nat-trans-nat-trans-components-preserves-iso-helper X A is-segal-A g f\n          ( \\ t x \u2192 (first (second (H x))) t)\n          ( \u03b1)\n          ( \\ x \u2192 (second (second (H x))))))\n#def iff-is-iso-pointwise-is-iso uses (funext)\n( X : U)\n( A : X \u2192 U)\n( is-segal-A : (x : X) \u2192 is-segal (A x))\n( f g : (x : X) \u2192 A x)\n( \u03b1 : nat-trans X A f g)\n  : iff\n( is-iso-arrow\n      ( (x : X) \u2192 A x)\n      ( is-segal-function-type funext X A is-segal-A) f g \u03b1)\n( ( x : X) \u2192\n        ( is-iso-arrow\n          ( A x)\n          ( is-segal-A x)\n          ( f x)\n          ( g x)\n          ( ev-components-nat-trans X A f g \u03b1 x)))\n  :=\n    ( ev-components-nat-trans-preserves-iso X A is-segal-A f g \u03b1,\n      nat-trans-nat-trans-components-preserves-iso X A is-segal-A f g \u03b1)\n#def equiv-is-iso-pointwise-is-iso uses (extext funext weakfunext)\n( X : U)\n( A : X \u2192 U)\n( is-segal-A : (x : X) \u2192 is-segal (A x))\n( f g : (x : X) \u2192 A x)\n( \u03b1 : nat-trans X A f g)\n  : Equiv\n( is-iso-arrow\n      ( (x : X) \u2192 A x)\n      ( is-segal-function-type funext X A is-segal-A) f g \u03b1)\n( ( x : X) \u2192\n        ( is-iso-arrow\n          ( A x)\n          ( is-segal-A x)\n          ( f x)\n          ( g x)\n          ( ev-components-nat-trans X A f g \u03b1 x)))\n  :=\n    equiv-iff-is-prop-is-prop\n( is-iso-arrow\n        ( (x : X) \u2192 A x)\n        ( is-segal-function-type funext X A is-segal-A) f g \u03b1)\n( ( x : X) \u2192\n        ( is-iso-arrow\n          ( A x)\n          ( is-segal-A x)\n          ( f x)\n          ( g x)\n          ( ev-components-nat-trans X A f g \u03b1 x)))\n( is-prop-is-iso-arrow\n        ( (x : X) \u2192 A x)\n        ( is-segal-function-type funext X A is-segal-A)\n        ( f)\n        ( g)\n        ( \u03b1))\n      ( is-prop-fiberwise-prop funext weakfunext\n        ( X)\n        ( \\ x \u2192\n          ( is-iso-arrow\n            ( A x)\n            ( is-segal-A x)\n            ( f x)\n            ( g x)\n            ( ev-components-nat-trans X A f g \u03b1 x)))\n        ( \\ x \u2192\n          is-prop-is-iso-arrow\n            ( A x)\n            ( is-segal-A x)\n            ( f x)\n            ( g x)\n            ( ev-components-nat-trans X A f g \u03b1 x)))\n      ( iff-is-iso-pointwise-is-iso X A is-segal-A f g \u03b1)\n</code></pre> RS17, Corollary 10.4<pre><code>#def iso-extensionality uses (extext funext weakfunext)\n( X : U)\n( A : X \u2192 U)\n( is-segal-A : (x : X) \u2192 is-segal (A x))\n( f g : (x : X) \u2192 A x)\n  : Equiv\n( Iso ((x : X) \u2192 A x) (is-segal-function-type funext X A is-segal-A) f g)\n( ( x : X) \u2192 Iso (A x) (is-segal-A x) (f x) (g x))\n  :=\n    equiv-triple-comp\n( Iso ((x : X) \u2192 A x) (is-segal-function-type funext X A is-segal-A) f g)\n( \u03a3 ( \u03b1 : nat-trans X A f g) ,\n( x : X) \u2192\n        ( is-iso-arrow (A x) (is-segal-A x) (f x) (g x)\n          ( ev-components-nat-trans X A f g \u03b1 x)))\n( \u03a3 ( \u03b1' : nat-trans-components X A f g) ,\n( x : X) \u2192 is-iso-arrow (A x) (is-segal-A x) (f x) (g x) (\u03b1' x))\n( (x : X) \u2192 Iso (A x) (is-segal-A x) (f x) (g x))\n      ( total-equiv-family-of-equiv\n        ( nat-trans X A f g)\n( \\ \u03b1 \u2192\n          ( is-iso-arrow\n            ( (x : X) \u2192 A x)\n            ( is-segal-function-type funext X A is-segal-A)\n            f g \u03b1))\n( \\ \u03b1 \u2192\n          ( x : X) \u2192\n          ( is-iso-arrow (A x) (is-segal-A x) (f x) (g x)\n            ( ev-components-nat-trans X A f g \u03b1 x)))\n        ( \\ \u03b1 \u2192 equiv-is-iso-pointwise-is-iso X A is-segal-A f g \u03b1))\n      ( equiv-total-pullback-is-equiv\n        ( nat-trans X A f g)\n        ( nat-trans-components X A f g)\n        ( ev-components-nat-trans X A f g)\n        ( is-equiv-ev-components-nat-trans X A f g)\n( \\ \u03b1' \u2192\n          ( x : X) \u2192 is-iso-arrow (A x) (is-segal-A x) (f x) (g x) (\u03b1' x)))\n( inv-equiv\n        ( (x : X) \u2192 Iso (A x) (is-segal-A x) (f x) (g x))\n( \u03a3 ( \u03b1' : nat-trans-components X A f g) ,\n( x : X) \u2192 is-iso-arrow (A x) (is-segal-A x) (f x) (g x) (\u03b1' x))\n        ( equiv-choice X\n          ( \\ x \u2192 hom (A x) (f x) (g x))\n          ( \\ x \u03b1\u2093 \u2192 is-iso-arrow (A x) (is-segal-A x) (f x) (g x) \u03b1\u2093)))\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#rezk-types_1","title":"Rezk types","text":"<p>For every <code>x : A</code>, the identity arrow <code>id-hom A x : hom A x x</code> is an isomorphism.</p> <pre><code>#def is-iso-arrow-id-hom\n( A : U)\n( is-segal-A : is-segal A)\n( x : A)\n  : is-iso-arrow A is-segal-A x x (id-hom A x)\n  :=\n    ( ( id-hom A x , comp-id-is-segal A is-segal-A x x (id-hom A x))\n    , ( id-hom A x , comp-id-is-segal A is-segal-A x x (id-hom A x)))\n#def iso-id-arrow\n( A : U)\n( is-segal-A : is-segal A)\n  : (x : A) \u2192 Iso A is-segal-A x x\n  := \\ x \u2192 ( id-hom A x , is-iso-arrow-id-hom A is-segal-A x)\n</code></pre> <p>More generally, every path induces an isomorphism.</p> <pre><code>#def is-iso-arrow-hom-eq\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n  : ( p : x = y)\n  \u2192 is-iso-arrow A is-segal-A x y (hom-eq A x y p)\n  :=\n    ind-path A x\n    ( \\ y' p' \u2192 is-iso-arrow A is-segal-A x y' (hom-eq A x y' p'))\n    ( is-iso-arrow-id-hom A is-segal-A x)\n    ( y)\n#def iso-eq\n( A : U)\n( is-segal-A : is-segal A)\n( x y : A)\n  : (x = y) \u2192 Iso A is-segal-A x y\n  := \\ p \u2192 (hom-eq A x y p , is-iso-arrow-hom-eq A is-segal-A x y p)\n</code></pre> <p>A Segal type <code>A</code> is a Rezk type just when, for all <code>x y : A</code>, this natural map from <code>x = y</code> to <code>Iso A is-segal-A x y</code> is an equivalence.</p> RS17, Definition 10.6<pre><code>#def is-rezk\n( A : U)\n  : U\n  :=\n\u03a3 ( is-segal-A : is-segal A)\n    , ( (x : A)\n      \u2192 (y : A)\n      \u2192 is-equiv (x = y) (Iso A is-segal-A x y) (iso-eq A is-segal-A x y))\n</code></pre> <p>The inverse to <code>iso-eq</code> for a Rezk type.</p> <pre><code>#def eq-iso-is-rezk\n( A : U)\n( is-rezk-A : is-rezk A)\n( x y : A)\n  : Iso A (first is-rezk-A) x y \u2192 x = y\n  :=\n    section-is-equiv (x = y) (Iso A (first is-rezk-A) x y)\n    ( iso-eq A (first is-rezk-A) x y)\n    ( ( second is-rezk-A) x y)\n#def iso-eq-iso-is-rezk\n( A : U)\n( is-rezk-A : is-rezk A)\n( x y : A)\n  ( (e, is-iso-e) : Iso A (first is-rezk-A) x y)\n  : first (iso-eq A (first is-rezk-A) x y (eq-iso-is-rezk A is-rezk-A x y (e, is-iso-e))) = e\n  :=\n    first-path-\u03a3\n    ( hom A x y)\n    ( is-iso-arrow A (first is-rezk-A) x y)\n    ( iso-eq A (first is-rezk-A) x y\n      ( eq-iso-is-rezk A is-rezk-A x y (e, is-iso-e)))\n    ( (e, is-iso-e))\n    ( ( second\n      ( has-section-is-equiv (x = y) (Iso A (first is-rezk-A) x y)\n        ( iso-eq A (first is-rezk-A) x y)\n        ( ( second is-rezk-A) x y))) (e, is-iso-e))\n</code></pre> <p>The following results show how <code>iso-eq</code> mediates between the type-theoretic operations on paths and the category-theoretic operations on arrows.</p> RS17, Lemma 10.7<pre><code>#def compute-covariant-transport-of-hom-family-iso-eq-is-segal\n( A : U)\n( is-segal-A : is-segal A)\n( C : A \u2192 U)\n( is-covariant-C : is-covariant A C)\n( x y : A)\n( e : x = y)\n( u : C x)\n  : covariant-transport\n      ( A)\n      ( x)\n      ( y)\n      ( first (iso-eq A is-segal-A x y e))\n      ( C)\n      ( is-covariant-C)\n      ( u)\n    = transport A C x y e u\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' e' \u2192\n        covariant-transport\n          ( A)\n          ( x)\n          ( y')\n          ( first (iso-eq A is-segal-A x y' e'))\n          ( C)\n          ( is-covariant-C)\n          ( u)\n        = transport A C x y' e' u)\n      ( id-arr-covariant-transport A x C is-covariant-C u)\n      ( y)\n      ( e)\n</code></pre> RS17, Lemma 10.8<pre><code>#def compute-ap-hom-of-iso-eq\n( A B : U)\n( is-segal-A : is-segal A)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n( x y : A)\n( e : x = y)\n  : ( ap-hom A B f x y (first (iso-eq A is-segal-A x y e))) =\n    ( first ( iso-eq B is-segal-B (f x) (f y) (ap A B x y f e)))\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' e' \u2192\n        ( ap-hom A B f x y' (first (iso-eq A is-segal-A x y' e'))) =\n        ( first (iso-eq B is-segal-B (f x) (f y') (ap A B x y' f e'))))\n      ( refl)\n      ( y)\n      ( e)\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#isomorphisms-in-discrete-types","title":"Isomorphisms in discrete types","text":"<p>In a discrete type every arrow is an isomorphisms. This is a straightforward path induction since every identity arrow is an isomorphism. Note that with extension extensionality, <code>is-discrete A</code> implies <code>is-segal A</code> but we state the first statement in a way that works without it.</p> <pre><code>#def has-iso-arrows-is-segal-is-discrete\n( A : U)\n( is-discrete-A : is-discrete A)\n( is-segal-A : is-segal A)\n( x y : A)\n  : ( f : hom A x y)\n  \u2192 ( is-iso-arrow A is-segal-A x y f)\n  :=\n    ind-has-section-equiv (x =_{A} y) (hom A x y)\n    ( hom-eq A x y , is-discrete-A x y)\n    ( \\ f \u2192 is-iso-arrow A is-segal-A x y f)\n    ( ind-path A x\n      ( \\ y' p \u2192 is-iso-arrow A is-segal-A x y' (hom-eq A x y' p))\n      ( is-iso-arrow-id-hom A is-segal-A x)\n      ( y))\n#def has-iso-arrows-is-discrete uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n( f : hom A x y)\n  : ( is-iso-arrow A (is-segal-is-discrete extext A is-discrete-A)\n      x y f)\n  :=\n    has-iso-arrows-is-segal-is-discrete A\n    is-discrete-A\n    ( is-segal-is-discrete extext A is-discrete-A)\n    ( x) (y) (f)\n#def is-equiv-hom-iso-is-discrete uses (extext)\n( A : U)\n( is-discrete-A : is-discrete A)\n( x y : A)\n  : is-equiv\n    ( Iso A (is-segal-is-discrete extext A is-discrete-A)\n      x y)\n    ( hom A x y)\n    ( \\ (f , _) \u2192 f)\n  :=\n    is-equiv-projection-contractible-fibers\n    ( hom A x y) (is-iso-arrow A (is-segal-is-discrete extext A is-discrete-A) x y)\n    ( \\ f \u2192\n      is-contr-is-inhabited-is-prop\n      ( is-iso-arrow A (is-segal-is-discrete extext A is-discrete-A) x y f)\n      ( is-prop-is-iso-arrow A\n        ( is-segal-is-discrete extext A is-discrete-A)\n        ( x) (y) (f))\n      ( has-iso-arrows-is-discrete A is-discrete-A x y f))\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#discrete-types-are-rezk","title":"Discrete types are Rezk","text":"<p>As a corollary we obtain that every discrete type is Rezk.</p> <pre><code>#def is-rezk-is-discrete uses (extext)\n( A : U)\n  : is-discrete A \u2192 is-rezk A\n  :=\n\\ is-discrete-A \u2192\n  ( is-segal-is-discrete extext A is-discrete-A\n  , ( \\ x y \u2192\n      is-equiv-right-factor\n      ( x = y)\n      ( Iso A (is-segal-is-discrete extext A is-discrete-A)\n        x y)\n      ( hom A x y)\n      ( iso-eq A (is-segal-is-discrete extext A is-discrete-A)\n        x y)\n      ( \\ (f , _) \u2192 f)\n      ( is-equiv-hom-iso-is-discrete A is-discrete-A x y)\n      ( is-discrete-A x y)))\n</code></pre> <p>In particular, every contractible type is Rezk</p> <pre><code>#def is-rezk-is-contr uses (extext)\n( A : U)\n  : is-contr A \u2192 is-rezk A\n  :=\n\\ is-contr-A \u2192\n    ( is-rezk-is-discrete A\n      ( is-discrete-is-contr extext A is-contr-A))\n#def is-rezk-Unit uses (extext)\n  : is-rezk Unit\n  := is-rezk-is-contr Unit (is-contr-Unit)\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/","title":"Adjunctions","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Some of the definitions in this file rely on function extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#transposing-adjunctions","title":"Transposing adjunctions","text":"<p>Transposing adjunctions are defined by opposing functors <code>f : A \u2192 B</code> and <code>u : B \u2192 A</code> together with a family of \"transposing equivalences\" between appropriate hom types.</p> RS17, Definition 11.1<pre><code>#def is-transposing-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n  : U\n  := (a : A) \u2192 (b : B) \u2192 Equiv (hom B (f a) b) (hom A a (u b))\n#def transposing-adj\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B), \u03a3 (u : B \u2192 A), is-transposing-adj A B f u\n</code></pre> <p>A functor <code>f : A \u2192 B</code> is a transposing left adjoint if it has a transposing right adjoint. Later we will show that the type <code>is-transposing-left-adj A B f</code> is a proposition when <code>A</code> is Rezk and <code>B</code> is Segal.</p> <pre><code>#def is-transposing-left-adj\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (u : B \u2192 A), is-transposing-adj A B f u\n#def is-transposing-right-adj\n( A B : U)\n( u : B \u2192 A)\n  : U\n  := \u03a3 (f : A \u2192 B), is-transposing-adj A B f u\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#quasi-diagrammatic-adjunctions","title":"Quasi-diagrammatic adjunctions","text":"<p>Quasi-diagrammatic adjunctions are defined by opposing functors <code>f : A \u2192 B</code> and <code>u : B \u2192 A</code>, unit and counit natural transformations, and a pair of witnesses to the triangle identities.</p> RS17, Definition 11.2<pre><code>#def has-quasi-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n  : U\n  :=\n\u03a3 ( \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  , \u03a3 ( \u03f5 : nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n    , product\n      ( hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n        ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n        ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n        ( id-hom (B \u2192 A) u))\n      ( hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n        ( id-hom (A \u2192 B) f))\n#def quasi-diagrammatic-adj\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B), \u03a3 (u : B \u2192 A), has-quasi-diagrammatic-adj A B f u\n</code></pre> <p>Quasi-diagrammatic adjunctions have left and right adjoints, but being the left or right adjoint part of a quasi-diagrammatic adjunction is not a proposition. Thus, we assign slightly different names to the following types.</p> <pre><code>#def has-quasi-diagrammatic-right-adj\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (u : B \u2192 A), has-quasi-diagrammatic-adj A B f u\n#def has-quasi-diagrammatic-left-adj\n( A B : U)\n( u : B \u2192 A)\n  : U\n  := \u03a3 (f : A \u2192 B), has-quasi-diagrammatic-adj A B f u\n</code></pre> <p>The following projection functions extract the core data of a quasi-diagrammatic adjunction.</p> <pre><code>#def unit-has-quasi-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n( has-quasi-diagrammatic-adj-fu : has-quasi-diagrammatic-adj A B f u)\n  : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f)\n  := first (has-quasi-diagrammatic-adj-fu)\n#def counit-has-quasi-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n( has-quasi-diagrammatic-adj-fu : has-quasi-diagrammatic-adj A B f u)\n  : nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B)\n  := first (second (has-quasi-diagrammatic-adj-fu))\n#def right-adj-triangle-has-quasi-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n( has-quasi-diagrammatic-adj-fu : has-quasi-diagrammatic-adj A B f u)\n  : hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n    ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f)\n      ( unit-has-quasi-diagrammatic-adj A B f u\n        ( has-quasi-diagrammatic-adj-fu)))\n    ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u\n      ( counit-has-quasi-diagrammatic-adj A B f u\n        ( has-quasi-diagrammatic-adj-fu)))\n    ( id-hom (B \u2192 A) u)\n  := first (second (second (has-quasi-diagrammatic-adj-fu)))\n#def left-adj-triangle-has-quasi-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n( has-quasi-diagrammatic-adj-fu : has-quasi-diagrammatic-adj A B f u)\n  : hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f\n      ( unit-has-quasi-diagrammatic-adj A B f u\n        ( has-quasi-diagrammatic-adj-fu)))\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B)\n      ( counit-has-quasi-diagrammatic-adj A B f u\n        ( has-quasi-diagrammatic-adj-fu)))\n    ( id-hom (A \u2192 B) f)\n  := second (second (second (has-quasi-diagrammatic-adj-fu)))\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#half-adjoint-diagrammatic-adjunctions","title":"Half-adjoint diagrammatic adjunctions","text":"<p>A half-adjoint diagrammatic adjunction extends a quasi-diagrammatic adjunction with higher coherence data that makes the specified witnesses to the triangle identities coherent. This extra coherence data involves a pair of 3-simplices belonging to a <code>hom3</code> type we now define.</p> <p>Unlike the convention used by the arguments of <code>hom2</code>, we introduce the boundary data of a 3-simplex in lexicographic order.</p> <pre><code>#def hom3\n( A : U)\n( w x y z : A)\n( f : hom A w x)\n( gf : hom A w y)\n( hgf : hom A w z)\n( g : hom A x y)\n( hg : hom A x z)\n( h : hom A y z)\n( \u03b1\u2083 : hom2 A w x y f g gf)\n( \u03b1\u2082 : hom2 A w x z f hg hgf)\n( \u03b1\u2081 : hom2 A w y z gf h hgf)\n( \u03b1\u2080 : hom2 A x y z g h hg)\n  : U\n  :=\n  ( ((t\u2081 , t\u2082 ) , t\u2083 ) : \u0394\u00b3)\n  \u2192 A [ t\u2083 \u2261 0\u2082 \u21a6 \u03b1\u2083 (t\u2081 , t\u2082 ),\n        t\u2082 \u2261 t\u2083 \u21a6 \u03b1\u2082 (t\u2081 , t\u2083 ),\n        t\u2081 \u2261 t\u2082 \u21a6 \u03b1\u2081 (t\u2081 , t\u2083 ),\n        t\u2081 \u2261 1\u2082 \u21a6 \u03b1\u2080 (t\u2082 , t\u2083 )]\n</code></pre> RS17, Definition 11.3<pre><code>#def is-half-adjoint-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n  : U\n  :=\n\u03a3 ( (\u03b7 , (\u03f5 , (\u03b1 , \u03b2))) : has-quasi-diagrammatic-adj A B f u)\n  , \u03a3 ( \u03bc : hom2 ( B \u2192 B)\n            ( comp B A B f u)\n            ( quadruple-comp B A B A B f u f u)\n            ( identity B)\n            ( whisker-nat-trans B A A B u (identity A) (comp A B A u f) f \u03b7)\n            ( horizontal-comp-nat-trans B B B\n              ( comp B A B f u) (identity B) (comp B A B f u) (identity B)\n              ( \u03f5) ( \u03f5))\n            ( \u03f5))\n    , product\n      ( hom3 (B \u2192 B)\n        ( comp B A B f u)\n        ( quadruple-comp B A B A B f u f u)\n        ( comp B A B f u)\n        ( identity B)\n        ( whisker-nat-trans B A A B u (identity A) (comp A B A u f) f \u03b7)\n        ( id-hom (B \u2192 B) (comp B A B f u))\n        ( \u03f5)\n        ( postwhisker-nat-trans B B B\n          ( comp B A B f u) (identity B) (comp B A B f u) \u03f5)\n        ( horizontal-comp-nat-trans B B B\n          ( comp B A B f u) (identity B) (comp B A B f u) (identity B) (\u03f5) (\u03f5))\n        ( \u03f5)\n        ( \\ t a \u2192 f (\u03b1 t a))\n        ( \u03bc)\n        ( id-comp-witness (B \u2192 B) (comp B A B f u) (identity B) \u03f5)\n        ( left-gray-interchanger-horizontal-comp-nat-trans B B B\n          ( comp B A B f u) (identity B) (comp B A B f u) (identity B) (\u03f5) (\u03f5)))\n      ( hom3 (B \u2192 B)\n        ( comp B A B f u)\n        ( quadruple-comp B A B A B f u f u)\n        ( comp B A B f u)\n        ( identity B)\n        ( whisker-nat-trans B A A B u (identity A) (comp A B A u f) f \u03b7)\n        ( id-hom (B \u2192 B) (comp B A B f u))\n        ( \u03f5)\n        ( prewhisker-nat-trans B B B\n          ( comp B A B f u) (comp B A B f u) (identity B) \u03f5)\n        ( horizontal-comp-nat-trans B B B\n          ( comp B A B f u) (identity B) (comp B A B f u) (identity B) (\u03f5) (\u03f5))\n        ( \u03f5)\n        ( \\ t b \u2192 \u03b2 t (u b))\n        ( \u03bc)\n        ( id-comp-witness (B \u2192 B) (comp B A B f u) (identity B) \u03f5)\n        ( right-gray-interchanger-horizontal-comp-nat-trans B B B\n          ( comp B A B f u) (identity B) (comp B A B f u) (identity B) (\u03f5) (\u03f5)))\n#def half-adjoint-diagrammatic-adj\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B), \u03a3 (u : B \u2192 A), is-half-adjoint-diagrammatic-adj A B f u\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#bi-diagrammatic-adjunction","title":"Bi-diagrammatic adjunction","text":"<p>Bi-diagrammatic adjunctions are defined by opposing functors <code>f : A \u2192 B</code> and <code>u : B \u2192 A</code>, a unit natural transformation <code>\u03b7</code>, two counit natural transformations <code>\u03f5</code> and <code>\u03f5'</code>, and a pair of witnesses to the triangle identities, one involving each counit.</p> RS17, Definition 11.6<pre><code>#def is-bi-diagrammatic-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n  : U\n  :=\n\u03a3 (\u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  , \u03a3 (\u03f5 : nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n    , \u03a3 (\u03f5' : nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n      , product\n        ( hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n          ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n          ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n          ( id-hom (B \u2192 A) u))\n        ( hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n          ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n          ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5' )\n          ( id-hom (A \u2192 B) f))\n#def bi-diagrammatic-adj\n(A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B), \u03a3 (u : B \u2192 A), is-bi-diagrammatic-adj A B f u\n#def is-bi-diagrammatic-left-adj\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (u : B \u2192 A), is-bi-diagrammatic-adj A B f u\n#def is-bi-diagrammatic-right-adj\n( A B : U)\n( u : B \u2192 A)\n  : U\n  := \u03a3 (f : A \u2192 B), is-bi-diagrammatic-adj A B f u\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#quasi-transposing-adjunction","title":"Quasi-transposing adjunction","text":"<p>Quasi-transposing adjunctions are defined by opposing functors <code>f : A \u2192 B</code> and <code>u : B \u2192 A</code> together with a family of \"transposing quasi-equivalences\" where \"quasi-equivalence\" is another name for \"invertible map.\"</p> RS17, Definition 11.7<pre><code>#def has-quasi-transposing-adj\n( A B : U)\n( f : A \u2192 B)\n( u : B \u2192 A)\n  : U\n  :=\n(a : A)\n  \u2192 ( b : B)\n  \u2192 \u03a3 ( \u03d5 : (hom B (f a) b) \u2192 (hom A a (u b)))\n    , has-inverse (hom B (f a) b) (hom A a (u b)) \u03d5\n#def quasi-transposing-adj\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B), \u03a3 (u : B \u2192 A), has-quasi-transposing-adj A B f u\n#def has-quasi-transposing-right-adj\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (u : B \u2192 A), has-quasi-transposing-adj A B f u\n#def has-quasi-transposing-left-adj\n( A B : U)\n( u : B \u2192 A)\n  : U\n  := \u03a3 (f : A \u2192 B), has-quasi-transposing-adj A B f u\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#equivalence-of-quasi-transposing-and-quasi-diagrammatic-adjunctions","title":"Equivalence of quasi-transposing and quasi-diagrammatic adjunctions","text":"<p>When <code>A</code> and <code>B</code> are Segal types, <code>quasi-transposing-adj A B</code> and <code>quasi-diagrammatic-adj A B</code> are equivalent.</p> <p>We first connect the components of the unit and counit to the transposition maps in the usual way, as an application of the Yoneda lemma.</p> <pre><code>#section unit-counit-transposition\n#variables A B : U\n#variable is-segal-A : is-segal A\n#variable is-segal-B : is-segal B\n#variable f : A \u2192 B\n#variable u : B \u2192 A\n#def equiv-transposition-unit-component uses (funext)\n(a : A)\n  : Equiv ((b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b))) (hom A a (u (f a)))\n  :=\n  ( evid B (f a) (\\ b \u2192 hom A a (u b))\n    ,\n    yoneda-lemma funext B is-segal-B\n    ( f a)\n    ( \\ b \u2192 hom A a (u b))\n    ( is-covariant-substitution-is-covariant A B\n      ( hom A a)\n      ( is-covariant-representable-is-segal A is-segal-A a)\n      ( u)))\n#def equiv-unit-components\n  : Equiv\n( (a : A) \u2192 hom A a (u (f a)))\n    ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  :=\n  inv-equiv\n  ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n( (a : A) \u2192 hom A a (u (f a)))\n  ( equiv-components-nat-trans A ( \\ _ \u2192 A)\n    ( identity A)\n    ( comp A B A u f))\n#def equiv-transposition-unit uses (is-segal-A is-segal-B funext)\n  : Equiv\n( (a : A) \u2192 (b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n    ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  :=\n  equiv-comp\n( (a : A) \u2192 (b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n( (a : A) \u2192 hom A a (u (f a)))\n  ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n( equiv-function-equiv-family funext A\n    ( \\ a \u2192 (b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n    ( \\ a \u2192 hom A a (u (f a)))\n    ( equiv-transposition-unit-component))\n  ( equiv-unit-components)\n</code></pre> <p>We now reverse direction of the equivalence and extract the explicit map defining the transposition function associated to a unit natural transformation.</p> <pre><code>#def is-equiv-unit-component-transposition uses (funext)\n(a : A)\n  : is-equiv (hom A a (u (f a))) ((b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n    ( \\ \u03b7a b k \u2192\n      comp-is-segal A is-segal-A a (u (f a)) (u b) \u03b7a (ap-hom B A u (f a) b k))\n  :=\n  inv-yoneda-lemma funext B is-segal-B\n  ( f a)\n  ( \\ b \u2192 hom A a (u b))\n  ( is-covariant-substitution-is-covariant A B\n    ( hom A a)\n    ( is-covariant-representable-is-segal A is-segal-A a)\n    ( u))\n#def is-equiv-unit-transposition uses (is-segal-A is-segal-B funext)\n  : is-equiv\n    ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n( (a : A) \u2192 (b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n    ( \\ \u03b7 a b k \u2192\n      comp-is-segal A is-segal-A a (u (f a)) (u b)\n      ( \\ t -&gt; \u03b7 t a)\n      ( ap-hom B A u (f a) b k))\n  :=\n  is-equiv-comp\n  ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n( (a : A) \u2192 hom A a (u (f a)))\n( (a : A) \u2192 (b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n  ( ev-components-nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  ( is-equiv-ev-components-nat-trans A (\\ _ \u2192 A)(identity A)(comp A B A u f))\n  ( \\ \u03b7 a b k \u2192\n    comp-is-segal A is-segal-A a (u (f a)) (u b)\n    ( \u03b7 a)\n    ( ap-hom B A u (f a) b k))\n  ( is-equiv-function-is-equiv-family funext A\n    ( \\ a \u2192 hom A a (u (f a)))\n( \\ a \u2192 (b : B) \u2192 (hom B (f a) b) \u2192 (hom A a (u b)))\n    ( \\ a \u03b7a b k \u2192\n      comp-is-segal A is-segal-A a (u (f a)) (u b)\n      ( \u03b7a)\n      ( ap-hom B A u (f a) b k))\n    ( is-equiv-unit-component-transposition))\n</code></pre> <p>The results for counits are dual.</p> <pre><code>#def equiv-transposition-counit-component uses (funext)\n(b : B)\n  : Equiv ((a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b)) (hom B (f (u b)) b)\n  :=\n  ( contra-evid A (u b) (\\ a \u2192 hom B (f a) b)\n  ,\n    contra-yoneda-lemma funext A is-segal-A\n    ( u b)\n    ( \\ a \u2192 hom B (f a) b)\n    ( is-contravariant-substitution-is-contravariant B A\n      ( \\ x -&gt; hom B x b)\n      ( is-contravariant-representable-is-segal B is-segal-B b)\n      ( f)))\n#def equiv-counit-components\n  : Equiv\n( (b : B) \u2192 hom B (f (u b)) b)\n    ( nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n  :=\n  inv-equiv\n  ( nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n( (b : B) \u2192 hom B (f (u b)) b)\n  ( equiv-components-nat-trans B ( \\ _ \u2192 B)\n    ( comp B A B f u)\n    ( identity B))\n#def equiv-transposition-counit uses (is-segal-A is-segal-B funext)\n  : Equiv\n( (b : B) \u2192 (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n    ( nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n  :=\n  equiv-comp\n( (b : B) \u2192 (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n( (b : B) \u2192 hom B (f (u b)) b)\n  ( nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n( equiv-function-equiv-family funext B\n    ( \\ b \u2192 (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n    ( \\ b \u2192 hom B (f (u b)) b)\n    ( equiv-transposition-counit-component))\n  ( equiv-counit-components)\n</code></pre> <p>We again reverse direction of the equivalence and extract the explicit map defining the transposition function associated to a counit natural transformation.</p> <pre><code>#def is-equiv-counit-component-transposition uses (funext)\n(b : B)\n  : is-equiv (hom B (f (u b)) b)\n( (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n    ( \\ \u03f5b a k \u2192\n      comp-is-segal B is-segal-B (f a) (f (u b)) b (ap-hom A B f a (u b) k) \u03f5b)\n  :=\n  inv-contra-yoneda-lemma funext A is-segal-A\n  ( u b)\n  ( \\ a \u2192 hom B (f a) b)\n  ( is-contravariant-substitution-is-contravariant B A\n    ( \\ z \u2192 hom B z b)\n    ( is-contravariant-representable-is-segal B is-segal-B b)\n    ( f))\n#def is-equiv-counit-transposition uses (is-segal-A is-segal-B funext)\n  : is-equiv\n    ( nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n( (b : B) \u2192 (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n    ( \\ \u03f5 b a k \u2192\n      comp-is-segal B is-segal-B (f a) (f (u b)) b\n      ( ap-hom A B f a (u b) k)\n      ( \\ t -&gt; \u03f5 t b))\n  :=\n  is-equiv-comp\n  ( nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n( (b : B) \u2192 hom B (f (u b)) b)\n( (b : B) \u2192 (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n  ( ev-components-nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B))\n  ( is-equiv-ev-components-nat-trans B (\\ _ \u2192 B)(comp B A B f u) (identity B))\n  ( \\ \u03f5 b a k \u2192\n    comp-is-segal B is-segal-B (f a) (f (u b)) b\n    ( ap-hom A B f a (u b) k)\n    ( \u03f5 b))\n  ( is-equiv-function-is-equiv-family funext B\n    ( \\ b \u2192 hom B (f (u b)) b)\n( \\ b \u2192 (a : A) \u2192 (hom A a (u b)) \u2192 (hom B (f a) b))\n    ( \\ b \u03f5b a k \u2192\n      comp-is-segal B is-segal-B (f a) (f (u b)) b\n      ( ap-hom A B f a (u b) k)\n      ( \u03f5b))\n    ( is-equiv-counit-component-transposition))\n#end unit-counit-transposition\n</code></pre> <p>We next connect the triangle identity witnesses to the usual triangle identities as an application of the dependent Yoneda lemma.</p> <pre><code>#section triangle-identities\n#variables A B : U\n#variable is-segal-A : is-segal A\n#variable is-segal-B : is-segal B\n#variable f : A \u2192 B\n#variable u : B \u2192 A\n#variable \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f)\n#variable \u03f5 : nat-trans B (\\ _ \u2192 B) (comp B A B f u) (identity B)\n#def equiv-radj-triangle uses (funext)\n  : Equiv\n    ( hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n      ( id-hom (B \u2192 A) u))\n    ( ( comp-is-segal\n        ( B \u2192 A)\n        ( is-segal-function-type\n          ( funext)\n          ( B)\n          ( \\ _ \u2192 A)\n          ( \\ _ \u2192 is-segal-A ))\n        ( u)\n        (triple-comp B A B A u f u)\n        ( u)\n        ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n        ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n      =\n      ( id-hom (B \u2192 A) u))\n  :=\n  inv-equiv\n  ( ( comp-is-segal\n      ( B \u2192 A)\n      ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )) =\n    ( id-hom (B \u2192 A) u))\n  ( hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n    ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n    ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n    ( id-hom (B \u2192 A) u))\n  ( equiv-hom2-eq-comp-is-segal\n    ( B \u2192 A)\n    ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n    ( u) (triple-comp B A B A u f u) (u)\n    ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n    ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n    ( id-hom (B \u2192 A) u))\n#def equiv-ev-components-radj-triangle\n  : Equiv\n    ( ( comp-is-segal\n        ( B \u2192 A)\n        ( is-segal-function-type\n          ( funext)\n          ( B)\n          ( \\ _ \u2192 A)\n          ( \\ _ \u2192 is-segal-A ))\n        ( u)\n        (triple-comp B A B A u f u)\n        ( u)\n        ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n        ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n      =\n      ( id-hom (B \u2192 A) u))\n    ( ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n        ( comp-is-segal\n          ( B \u2192 A)\n          ( is-segal-function-type\n            ( funext)\n            ( B)\n            ( \\ _ \u2192 A)\n            ( \\ _ \u2192 is-segal-A ))\n          ( u)\n          (triple-comp B A B A u f u)\n          ( u)\n          ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n          ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )))\n      =\n      ( \\ b \u2192 id-hom A ( u b)))\n  :=\n  equiv-ap-is-equiv\n  ( nat-trans B (\\ _ \u2192 A) u u)\n  ( nat-trans-components B (\\ _ \u2192 A) u u)\n  ( ev-components-nat-trans B (\\ _ \u2192 A) u u)\n  ( is-equiv-ev-components-nat-trans B (\\ _ \u2192 A) u u)\n  ( comp-is-segal (B \u2192 A)\n    ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n    ( u) (triple-comp B A B A u f u) (u)\n    ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n    ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n  ( id-hom (B \u2192 A) u)\n#def equiv-components-radj-triangle-funext uses (funext)\n  : Equiv\n    ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n      ( comp-is-segal (B \u2192 A)\n        ( is-segal-function-type funext B (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A ))\n        ( u) (triple-comp B A B A u f u) (u)\n        ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n        ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n      =\n      ( \\ b \u2192 id-hom A ( u b)))\n( ( b : B) \u2192\n      ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n        ( comp-is-segal (B \u2192 A)\n          ( is-segal-function-type funext B (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A ))\n          ( u) (triple-comp B A B A u f u) (u)\n          ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n          ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n        ( b)\n        =\n        id-hom A ( u b)))\n  :=\n  equiv-FunExt funext B\n  ( \\ b \u2192 (hom A (u b) (u b)))\n  ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n    ( comp-is-segal (B \u2192 A)\n      ( is-segal-function-type funext B (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A ))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )))\n  ( \\ b \u2192 id-hom A (u b))\n#def eq-ladj-triangle-comp-components-comp-nat-trans-is-segal uses (funext)\n(b : B)\n  : comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n    ( \\ t \u2192 \u03b7 t (u b) )\n    ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b))\n    =\n    ev-components-nat-trans B (\\ _ \u2192 A) u u\n    ( comp-is-segal (B \u2192 A)\n      ( is-segal-function-type (funext) (B) (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n    ( b)\n  :=\n  comp-components-comp-nat-trans-is-segal funext B (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A)\n  ( u) (triple-comp B A B A u f u) (u)\n  ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n  ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n  ( b)\n#def equiv-preconcat-radj-triangle uses (funext)\n(b : B)\n  : Equiv\n    ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n      ( comp-is-segal (B \u2192 A)\n        ( is-segal-function-type funext B (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A ))\n        ( u) (triple-comp B A B A u f u) (u)\n        ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n        ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n      ( b)\n      =\n      id-hom A ( u b))\n    ( ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n        ( \\ t \u2192 \u03b7 t (u b) )\n        ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b)))\n      =\n      ( id-hom A ( u b)))\n  :=\n  equiv-preconcat ( hom A (u b) (u b))\n  ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n    ( \\ t \u2192 \u03b7 t (u b) )\n    ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b)))\n  ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n    ( comp-is-segal (B \u2192 A)\n      ( is-segal-function-type (funext) (B) (\\ _ \u2192 A) (\\ _ \u2192 is-segal-A))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n    ( b))\n  ( id-hom A (u b))\n  ( eq-ladj-triangle-comp-components-comp-nat-trans-is-segal b)\n#def equiv-component-comp-segal-comp-radj-triangle uses (funext)\n  : Equiv\n    ( comp-is-segal ( B \u2192 A)\n      ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n      =\n      id-hom (B \u2192 A) u)\n( ( b : B) \u2192\n      ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n        ( \\ t \u2192 \u03b7 t (u b) )\n        ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b)))\n      =\n      ( id-hom A ( u b)))\n  :=\n  equiv-triple-comp\n  ( ( comp-is-segal (B \u2192 A)\n      ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )) =\n    ( id-hom (B \u2192 A) u))\n  ( ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n      ( comp-is-segal (B \u2192 A)\n        ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n        ( u) (triple-comp B A B A u f u) (u)\n        ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n        ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )))\n    =\n    ( \\ b \u2192 id-hom A ( u b)))\n( ( b : B)\n    \u2192 ( ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n          ( comp-is-segal ( B \u2192 A)\n            ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n            ( u) (triple-comp B A B A u f u) (u)\n            ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n            ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n          ( b))\n        =\n        ( id-hom A ( u b))))\n( ( b : B)\n    \u2192 ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n        ( \\ t \u2192 \u03b7 t (u b) )\n        ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b)))\n      =\n      ( id-hom A ( u b)))\n  ( equiv-ev-components-radj-triangle)\n  ( equiv-components-radj-triangle-funext)\n  ( equiv-function-equiv-family funext B\n    ( \\ b \u2192\n      ( ev-components-nat-trans B (\\ _ \u2192 A) u u\n        ( comp-is-segal ( B \u2192 A)\n          ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n          ( u) (triple-comp B A B A u f u) (u)\n          ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n          ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n        ( b))\n      =\n      ( id-hom A ( u b)))\n    ( \\ b \u2192\n      ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n        ( \\ t \u2192 \u03b7 t (u b) )\n        ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b)))\n      =\n      ( id-hom A ( u b)))\n    ( equiv-preconcat-radj-triangle))\n</code></pre> <p>We finally arrive at the desired equivalence.</p> <pre><code>#def equiv-components-radj-triangle uses (funext)\n  : Equiv\n    ( hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n      ( id-hom (B \u2192 A) u))\n( ( b : B)\n      \u2192 ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n          ( \\ t \u2192 \u03b7 t (u b) )\n          ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b))) =\n        ( id-hom A ( u b)))\n  :=\n  equiv-comp\n  ( hom2 (B \u2192 A) u (triple-comp B A B A u f u) u\n    ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n    ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 )\n    ( id-hom (B \u2192 A) u))\n  ( ( comp-is-segal ( B \u2192 A)\n      ( is-segal-function-type funext B ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A ))\n      ( u) (triple-comp B A B A u f u) (u)\n      ( prewhisker-nat-trans B A A u (identity A) (comp A B A u f) \u03b7 )\n      ( postwhisker-nat-trans B B A (comp B A B f u) (identity B) u \u03f5 ))\n    =\n    ( id-hom (B \u2192 A) u))\n( ( b : B)\n    \u2192 ( comp-is-segal A is-segal-A (u b) (u (f (u b))) (u b)\n        ( \\ t \u2192 \u03b7 t (u b) )\n        ( ap-hom B A u (f (u b)) b (\\ t \u2192 \u03f5 t b)))\n      =\n      ( id-hom A ( u b)))\n  ( equiv-radj-triangle)\n  ( equiv-component-comp-segal-comp-radj-triangle)\n</code></pre> <p>The calculation for the other triangle identity is dual.</p> <pre><code>#def equiv-ladj-triangle uses (funext)\n  : Equiv\n    ( hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n      ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n      ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n      ( id-hom (A \u2192 B) f))\n    ( comp-is-segal ( A \u2192 B)\n      ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n      ( f) (triple-comp A B A B f u f) (f)\n      ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n      ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n      =\n      id-hom (A \u2192 B) f)\n  :=\n  inv-equiv\n  ( comp-is-segal ( A \u2192 B)\n    ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n    ( f) (triple-comp A B A B f u f) (f)\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    =\n    id-hom (A \u2192 B) f)\n  ( hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    ( id-hom (A \u2192 B) f))\n  ( equiv-hom2-eq-comp-is-segal ( A \u2192 B)\n    ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n    ( f) (triple-comp A B A B f u f) (f)\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    ( id-hom (A \u2192 B) f))\n#def equiv-ev-components-ladj-triangle\n  : Equiv\n    ( comp-is-segal ( A \u2192 B)\n      ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n      ( f) (triple-comp A B A B f u f) (f)\n      ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n      ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n      =\n      id-hom (A \u2192 B) f)\n    ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n      ( comp-is-segal (A \u2192 B)\n        ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n        ( f) (triple-comp A B A B f u f) (f)\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n      =\n      ( \\ a \u2192 id-hom B ( f a)))\n  :=\n  equiv-ap-is-equiv\n  ( nat-trans A (\\ _ \u2192 B) f f)\n  ( nat-trans-components A (\\ _ \u2192 B) f f)\n  ( ev-components-nat-trans A (\\ _ \u2192 B) f f)\n  ( is-equiv-ev-components-nat-trans A (\\ _ \u2192 B) f f)\n  ( comp-is-segal ( A \u2192 B)\n    ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n    ( f) (triple-comp A B A B f u f) (f)\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n  ( id-hom (A \u2192 B) f)\n#def equiv-components-ladj-triangle-funext uses (funext)\n  : Equiv\n    ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n      ( comp-is-segal (A \u2192 B)\n        ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n        ( f) (triple-comp A B A B f u f) (f)\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n      =\n      ( \\ a \u2192 id-hom B ( f a)))\n( ( a : A)\n      \u2192 ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n          ( comp-is-segal (A \u2192 B)\n            ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n            ( f) (triple-comp A B A B f u f) (f)\n            ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n            ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n          ( a)\n        =\n        id-hom B ( f a)))\n  :=\n  equiv-FunExt funext A\n  ( \\ a \u2192 (hom B (f a) (f a)))\n  ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n    ( comp-is-segal (A \u2192 B)\n      ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n      ( f) (triple-comp A B A B f u f) (f)\n      ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n      ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )))\n  ( \\ a \u2192 id-hom B (f a))\n#def eq-radj-triangle-comp-components-comp-nat-trans-is-segal uses (funext)\n(a : A)\n  : ( comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n      ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n      ( \\ t \u2192 \u03f5 t (f a))) =\n    ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n      ( comp-is-segal\n        ( A \u2192 B)\n        ( is-segal-function-type (funext) (A) (\\ _ \u2192 B) (\\ _ \u2192 is-segal-B))\n        ( f)\n        (triple-comp A B A B f u f)\n        ( f)\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n      ( a))\n  :=\n    comp-components-comp-nat-trans-is-segal\n    ( funext)\n    ( A)\n    ( \\ _ \u2192 B)\n    ( \\ _ \u2192 is-segal-B)\n    ( f)\n    (triple-comp A B A B f u f)\n    ( f)\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    ( a)\n#def equiv-preconcat-ladj-triangle uses (funext)\n(a : A)\n  : Equiv\n    ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n      ( comp-is-segal (A \u2192 B)\n        ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n        ( f) (triple-comp A B A B f u f) (f)\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n      ( a)\n      =\n      id-hom B ( f a))\n    ( comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n      ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n      ( \\ t \u2192 \u03f5 t (f a))\n      =\n      id-hom B ( f a))\n  :=\n  equiv-preconcat (hom B (f a) (f a))\n  ( comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n    ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n    ( \\ t \u2192 \u03f5 t (f a)))\n  ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n    ( comp-is-segal (A \u2192 B)\n      ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n      ( f) (triple-comp A B A B f u f) (f)\n      ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n      ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n    ( a))\n  ( id-hom B (f a))\n  (eq-radj-triangle-comp-components-comp-nat-trans-is-segal a)\n#def equiv-component-comp-segal-comp-ladj-triangle uses (funext)\n  : Equiv\n    ( comp-is-segal (A \u2192 B)\n      ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n      ( f) (triple-comp A B A B f u f) (f)\n      ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n      ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n      =\n      id-hom (A \u2192 B) f)\n( ( a : A)\n      \u2192 comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n        ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n        ( \\ t \u2192 \u03f5 t (f a))\n        =\n        id-hom B ( f a))\n  :=\n  equiv-triple-comp\n  ( comp-is-segal (A \u2192 B)\n    ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n    ( f) (triple-comp A B A B f u f) (f)\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    =\n    id-hom (A \u2192 B) f)\n  ( ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n      ( comp-is-segal (A \u2192 B)\n        ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n        ( f) (triple-comp A B A B f u f) (f)\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )))\n    =\n    ( \\ a \u2192 id-hom B ( f a)))\n( ( a : A)\n    \u2192 ( ev-components-nat-trans A (\\ _ \u2192 B) f f\n        ( comp-is-segal ( A \u2192 B)\n          ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n          ( f) (triple-comp A B A B f u f) (f)\n          ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )            ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n        ( a)\n        =\n        id-hom B ( f a)))\n( ( a : A)\n      \u2192 comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n        ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n        ( \\ t \u2192 \u03f5 t (f a))\n        =\n        id-hom B ( f a))\n    ( equiv-ev-components-ladj-triangle)\n    ( equiv-components-ladj-triangle-funext)\n    ( equiv-function-equiv-family funext A\n      ( \\ a \u2192\n        ev-components-nat-trans A (\\ _ \u2192 B) f f\n        ( comp-is-segal ( A \u2192 B)\n          ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n          ( f) (triple-comp A B A B f u f) (f)\n          ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )            ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 ))\n        ( a)\n        =\n        id-hom B ( f a))\n      ( \\ a \u2192\n        comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n          ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n          ( \\ t \u2192 \u03f5 t (f a))\n        =\n        id-hom B ( f a))\n      ( equiv-preconcat-ladj-triangle))\n#def equiv-components-ladj-triangle uses (funext)\n  : Equiv\n    ( hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n        ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n        ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n        ( id-hom (A \u2192 B) f))\n( ( a : A)\n      \u2192 comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n        ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n        ( \\ t \u2192 \u03f5 t (f a))\n        =\n        id-hom B ( f a))\n  :=\n  equiv-comp\n  ( hom2 (A \u2192 B) f (triple-comp A B A B f u f) f\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    ( id-hom (A \u2192 B) f))\n  ( comp-is-segal (A \u2192 B)\n    ( is-segal-function-type funext A ( \\ _ \u2192 B) ( \\ _ \u2192 is-segal-B ))\n    ( f) (triple-comp A B A B f u f) (f)\n    ( postwhisker-nat-trans A A B (identity A) (comp A B A u f) f \u03b7 )\n    ( prewhisker-nat-trans A B B f (comp B A B f u) (identity B) \u03f5 )\n    =\n    id-hom (A \u2192 B) f)\n( ( a : A)\n    \u2192 comp-is-segal B is-segal-B (f a) (f (u (f a))) (f a)\n      ( ap-hom A B f a (u (f a)) (\\ t \u2192 \u03b7 t a))\n      ( \\ t \u2192 \u03f5 t (f a))\n       =\n      id-hom B ( f a))\n  ( equiv-ladj-triangle)\n  ( equiv-component-comp-segal-comp-ladj-triangle)\n#end triangle-identities\n</code></pre>"},{"location":"simplicial-hott/11-adjunctions.rzk/#adjunctions-between-rezk-types","title":"Adjunctions between Rezk types","text":"<p>Given a functor <code>u : B \u2192 A</code> from a Rezk type to a Segal type, we show that the type given by functors <code>f : A \u2192 B</code> and unit transformations that induce a transposing equivalence is a proposition. This data is nearly the data of <code>is-transposing-right-adj A B u</code></p> <pre><code>#section all-unit-arrows-equal-is-rezk-is-segal\n#variables B A : U\n#variable is-rezk-B : is-rezk B\n#variable is-segal-A : is-segal A\n#variable u : B \u2192 A\n#variable a : A\n#variables fa fa' : B\n#variable \u03b7a : hom A a (u fa)\n#variable \u03b7a' : hom A a (u fa')\n#def \u03b7a-transposition\n( b : B)\n( k : hom B fa b)\n  : (hom A a (u b))\n  := comp-is-segal A is-segal-A a (u fa) (u b) \u03b7a (ap-hom B A u fa b k)\n#def \u03b7a'-transposition\n( b : B)\n( k : hom B fa' b)\n  : (hom A a (u b))\n  := comp-is-segal A is-segal-A a (u fa') (u b) \u03b7a' (ap-hom B A u fa' b k)\n#variable \u03c9\n  : (b : B) \u2192 is-equiv (hom B fa b) (hom A a (u b)) (\u03b7a-transposition b)\n#variable \u03c9'\n  : (b : B) \u2192 is-equiv (hom B fa' b) (hom A a (u b)) (\u03b7a'-transposition b)\n#def to-left-adjoint-components-is-rezk-is-segal uses (A is-segal-A u a \u03b7a)\n  : hom B fa fa'\n  :=\n  section-is-equiv (hom B fa fa') (hom A a (u fa'))\n  ( \u03b7a-transposition fa') (\u03c9 fa')\n  ( \u03b7a')\n#def triangle-to-left-adjoint-components-is-rezk-is-segal\n  : comp-is-segal A is-segal-A a (u fa) (u fa')\n    ( \u03b7a)\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)\n    =\n    \u03b7a'\n  :=\n  ( second\n    ( has-section-is-equiv (hom B fa fa') (hom A a (u fa'))\n      ( \u03b7a-transposition fa') (\u03c9 fa')))\n  ( \u03b7a')\n#def from-left-adjoint-components-is-rezk-is-segal uses (A is-segal-A u a \u03b7a')\n  : hom B fa' fa\n  :=\n  section-is-equiv (hom B fa' fa) (hom A a (u fa))\n  ( \u03b7a'-transposition fa) (\u03c9' fa)\n  ( \u03b7a)\n#def triangle-from-left-adjoint-components-is-rezk-is-segal\n  : comp-is-segal A is-segal-A a (u fa') (u fa)\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal)\n    =\n    \u03b7a\n  :=\n  ( second\n    ( has-section-is-equiv (hom B fa' fa) (hom A a (u fa))\n      ( \u03b7a'-transposition fa) (\u03c9' fa)))\n  ( \u03b7a)\n#def \u03b7a-automorphism uses (extext \u03c9 \u03c9')\n  : comp-is-segal A is-segal-A a (u fa) (u fa)\n    ( \u03b7a)\n    ( ap-hom B A u fa fa\n      ( comp-is-segal B (first is-rezk-B) fa fa' fa\n        ( to-left-adjoint-components-is-rezk-is-segal)\n        ( from-left-adjoint-components-is-rezk-is-segal)))\n    =\n    \u03b7a\n  :=\n  quadruple-concat (hom A a (u fa))\n  ( comp-is-segal A is-segal-A a (u fa) (u fa)\n    ( \u03b7a)\n    ( ap-hom B A u fa fa\n      ( comp-is-segal B (first is-rezk-B) fa fa' fa\n        ( to-left-adjoint-components-is-rezk-is-segal)\n        ( from-left-adjoint-components-is-rezk-is-segal))))\n  ( comp-is-segal A is-segal-A a (u fa) (u fa)\n    ( \u03b7a)\n    ( comp-is-segal A is-segal-A (u fa) (u fa') (u fa)\n      ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)\n      ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal)))\n  ( comp-is-segal A is-segal-A a (u fa') (u fa)\n    ( comp-is-segal A is-segal-A a (u fa) (u fa')\n      ( \u03b7a)\n      ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n    ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal))\n  ( comp-is-segal A is-segal-A a (u fa') (u fa)\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal))\n  ( \u03b7a)\n  ( prewhisker-homotopy-is-segal A is-segal-A a (u fa) (u fa)\n    ( \u03b7a)\n    ( ap-hom B A u fa fa\n      ( comp-is-segal B (first is-rezk-B) fa fa' fa\n        ( to-left-adjoint-components-is-rezk-is-segal)\n        ( from-left-adjoint-components-is-rezk-is-segal)))\n    ( comp-is-segal A is-segal-A (u fa) (u fa') (u fa)\n      ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)\n      ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal))\n    ( rev-functors-pres-comp B A (first is-rezk-B) is-segal-A u fa fa' fa\n      ( to-left-adjoint-components-is-rezk-is-segal)\n      ( from-left-adjoint-components-is-rezk-is-segal)))\n  ( rev-associative-is-segal extext A is-segal-A a (u fa) (u fa') (u fa)\n    ( \u03b7a)\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)\n    ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal))\n   ( postwhisker-homotopy-is-segal (A) (is-segal-A) (a) (u fa') (u fa)\n    ( comp-is-segal A is-segal-A a (u fa) (u fa')\n      ( \u03b7a)\n      ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal)\n    ( triangle-to-left-adjoint-components-is-rezk-is-segal))\n  ( triangle-from-left-adjoint-components-is-rezk-is-segal)\n#def \u03b7a'-automorphism uses (extext \u03c9 \u03c9')\n  : comp-is-segal A is-segal-A a (u fa') (u fa')\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa'\n      ( comp-is-segal B (first is-rezk-B) fa' fa fa'\n        ( from-left-adjoint-components-is-rezk-is-segal)\n        ( to-left-adjoint-components-is-rezk-is-segal)))\n    =\n    \u03b7a'\n  :=\n  quadruple-concat (hom A a (u fa'))\n  ( comp-is-segal A is-segal-A a (u fa') (u fa')\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa'\n      ( comp-is-segal B (first is-rezk-B) fa' fa fa'\n        ( from-left-adjoint-components-is-rezk-is-segal)\n        ( to-left-adjoint-components-is-rezk-is-segal))))\n  ( comp-is-segal A is-segal-A a (u fa') (u fa')\n    ( \u03b7a')\n    ( comp-is-segal A is-segal-A (u fa') (u fa) (u fa')\n      ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal)\n      ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)))\n  ( comp-is-segal A is-segal-A a (u fa) (u fa')\n    ( comp-is-segal A is-segal-A a (u fa') (u fa)\n      ( \u03b7a')\n      ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal))\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n  ( comp-is-segal A is-segal-A a (u fa) (u fa')\n    ( \u03b7a)\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n  ( \u03b7a')\n  ( prewhisker-homotopy-is-segal A is-segal-A a (u fa') (u fa')\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa'\n      ( comp-is-segal B (first is-rezk-B) fa' fa fa'\n        ( from-left-adjoint-components-is-rezk-is-segal)\n        ( to-left-adjoint-components-is-rezk-is-segal)))\n    ( comp-is-segal A is-segal-A (u fa') (u fa) (u fa')\n      ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal)\n      ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n    ( rev-functors-pres-comp B A (first is-rezk-B) is-segal-A u fa' fa fa'\n      ( from-left-adjoint-components-is-rezk-is-segal)\n      ( to-left-adjoint-components-is-rezk-is-segal)))\n  ( rev-associative-is-segal extext A is-segal-A a ( u fa') (u fa) (u fa')\n    ( \u03b7a')\n    ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal)\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n  ( postwhisker-homotopy-is-segal (A) (is-segal-A) (a) (u fa) (u fa')\n    ( comp-is-segal A is-segal-A a (u fa') (u fa)\n      ( \u03b7a')\n      ( ap-hom B A u fa' fa from-left-adjoint-components-is-rezk-is-segal))\n    ( \u03b7a)\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)\n    ( triangle-from-left-adjoint-components-is-rezk-is-segal))\n  ( triangle-to-left-adjoint-components-is-rezk-is-segal)\n#def eq-id-from-to-left-adjoint-components-is-rezk-is-segal uses (extext \u03b7a' \u03c9 \u03c9')\n  : comp-is-segal B (first is-rezk-B) fa fa' fa\n    ( to-left-adjoint-components-is-rezk-is-segal)\n    ( from-left-adjoint-components-is-rezk-is-segal)\n    =\n    id-hom B fa\n  :=\n  inv-ap-is-emb (hom B fa fa) (hom A a (u fa))\n  ( \u03b7a-transposition fa)\n  ( is-emb-is-equiv (hom B fa fa) (hom A a (u fa))\n    ( \u03b7a-transposition fa)\n    ( \u03c9 fa))\n  ( comp-is-segal B (first is-rezk-B) fa fa' fa\n    ( to-left-adjoint-components-is-rezk-is-segal)\n    ( from-left-adjoint-components-is-rezk-is-segal))\n  ( id-hom B fa)\n  ( zig-zag-concat (hom A a (u fa))\n    ( \u03b7a-transposition fa\n      ( comp-is-segal B (first is-rezk-B) fa fa' fa\n        ( to-left-adjoint-components-is-rezk-is-segal)\n        ( from-left-adjoint-components-is-rezk-is-segal)))\n    ( \u03b7a)\n    ( \u03b7a-transposition fa (id-hom B fa))\n    ( \u03b7a-automorphism)\n    ( concat (hom A a (u fa))\n      ( \u03b7a-transposition fa (id-hom B fa))\n      ( comp-is-segal A is-segal-A a (u fa) (u fa) \u03b7a (id-hom A (u fa)))\n      ( \u03b7a)\n      ( prewhisker-homotopy-is-segal A is-segal-A a (u fa) (u fa) \u03b7a\n        ( ap-hom B A u fa fa (id-hom B fa))\n        ( id-hom A (u fa))\n        (functors-pres-id extext B A u fa))\n      ( comp-id-is-segal A is-segal-A a (u fa) \u03b7a)))\n#def eq-id-to-from-left-adjoint-components-is-rezk-is-segal uses (extext \u03b7a \u03c9 \u03c9')\n  : comp-is-segal B (first is-rezk-B) fa' fa fa'\n    ( from-left-adjoint-components-is-rezk-is-segal)\n    ( to-left-adjoint-components-is-rezk-is-segal)\n    =\n    id-hom B fa'\n  :=\n  inv-ap-is-emb (hom B fa' fa') (hom A a (u fa'))\n  ( \u03b7a'-transposition fa')\n  ( is-emb-is-equiv\n    ( hom B fa' fa')\n    ( hom A a (u fa'))\n    ( \u03b7a'-transposition fa')\n    ( \u03c9' fa'))\n  ( comp-is-segal B (first is-rezk-B) fa' fa fa'\n    ( from-left-adjoint-components-is-rezk-is-segal)\n    ( to-left-adjoint-components-is-rezk-is-segal))\n  ( id-hom B fa')\n  ( zig-zag-concat (hom A a (u fa'))\n    ( \u03b7a'-transposition fa'\n      ( comp-is-segal B (first is-rezk-B) fa' fa fa'\n        ( from-left-adjoint-components-is-rezk-is-segal)\n        ( to-left-adjoint-components-is-rezk-is-segal)))\n    ( \u03b7a')\n    ( \u03b7a'-transposition fa' (id-hom B fa'))\n    ( \u03b7a'-automorphism)\n    ( concat (hom A a (u fa'))\n      ( \u03b7a'-transposition fa' (id-hom B fa'))\n      ( comp-is-segal A is-segal-A a (u fa') (u fa') \u03b7a' (id-hom A (u fa')))\n      ( \u03b7a')\n      ( prewhisker-homotopy-is-segal A is-segal-A a (u fa') (u fa') \u03b7a'\n        ( ap-hom B A u fa' fa' (id-hom B fa'))\n        ( id-hom A (u fa'))\n        (functors-pres-id extext B A u fa'))\n      ( comp-id-is-segal A is-segal-A a (u fa') \u03b7a')))\n#def all-left-adjoint-components-equal-is-rezk-is-segal uses (extext A is-segal-A u a \u03b7a \u03b7a' \u03c9 \u03c9')\n  : fa = fa'\n  :=\n  eq-iso-is-rezk B is-rezk-B fa fa'\n  ( to-left-adjoint-components-is-rezk-is-segal\n    ,\n    ( ( from-left-adjoint-components-is-rezk-is-segal\n        ,\n        eq-id-from-to-left-adjoint-components-is-rezk-is-segal)\n      ,\n      ( from-left-adjoint-components-is-rezk-is-segal\n        ,\n        eq-id-to-from-left-adjoint-components-is-rezk-is-segal)))\n#def iso-eq-iso-to-left-adjoint-components-is-rezk uses (extext A is-segal-A u a \u03b7a \u03b7a' \u03c9 \u03c9')\n  : first (iso-eq B (first is-rezk-B) fa fa'\n    ( all-left-adjoint-components-equal-is-rezk-is-segal))\n  = to-left-adjoint-components-is-rezk-is-segal\n  :=\n  iso-eq-iso-is-rezk B is-rezk-B fa fa'\n  ( to-left-adjoint-components-is-rezk-is-segal\n    ,\n    ( ( from-left-adjoint-components-is-rezk-is-segal\n        ,\n        eq-id-from-to-left-adjoint-components-is-rezk-is-segal)\n      ,\n      ( from-left-adjoint-components-is-rezk-is-segal\n        ,\n        eq-id-to-from-left-adjoint-components-is-rezk-is-segal)))\n#def compute-transport-all-left-adjoint-components-equal-is-rezk-is-segal uses (extext \u03b7a' \u03c9 \u03c9')\n  : transport B ( \\ b \u2192 hom A a (u b)) fa fa'\n    ( all-left-adjoint-components-equal-is-rezk-is-segal) \u03b7a\n    =\n    \u03b7a'\n  :=\n  quintuple-concat (hom A a (u fa'))\n  ( transport B ( \\ b \u2192 hom A a (u b)) fa fa'\n    ( all-left-adjoint-components-equal-is-rezk-is-segal) \u03b7a)\n  ( covariant-transport B fa fa'\n    ( first\n      ( iso-eq B (first is-rezk-B) fa fa'\n        ( all-left-adjoint-components-equal-is-rezk-is-segal)))\n    ( \\ b \u2192 hom A a (u b))\n    ( is-covariant-substitution-is-covariant A B (hom A a)\n      ( is-covariant-representable-is-segal A is-segal-A a) u)\n    ( \u03b7a))\n  ( covariant-transport B fa fa'\n    ( to-left-adjoint-components-is-rezk-is-segal)\n    ( \\ b \u2192 hom A a (u b))\n    ( is-covariant-substitution-is-covariant A B (hom A a)\n      ( is-covariant-representable-is-segal A is-segal-A a) u)\n    ( \u03b7a))\n  ( covariant-transport A (u fa) (u fa')\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal)\n    ( hom A a)\n    ( is-covariant-representable-is-segal A is-segal-A a)\n    ( \u03b7a))\n  ( comp-is-segal A is-segal-A a (u fa) (u fa') \u03b7a\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n  ( ( \u03b7a'))\n  ( rev (hom A a (u fa'))\n    ( covariant-transport B fa fa'\n      ( first\n        ( iso-eq B (first is-rezk-B) fa fa'\n          ( all-left-adjoint-components-equal-is-rezk-is-segal)))\n      ( \\ b \u2192 hom A a (u b))\n      ( is-covariant-substitution-is-covariant A B (hom A a)\n        ( is-covariant-representable-is-segal A is-segal-A a) u)\n      ( \u03b7a))\n    ( transport B ( \\ b \u2192 hom A a (u b)) fa fa'\n      ( all-left-adjoint-components-equal-is-rezk-is-segal) \u03b7a)\n    ( compute-covariant-transport-of-hom-family-iso-eq-is-segal B\n      ( first is-rezk-B)\n      ( \\ b \u2192 hom A a (u b))\n      ( is-covariant-substitution-is-covariant A B (hom A a)\n        ( is-covariant-representable-is-segal A is-segal-A a) u)\n      ( fa) (fa')\n      ( all-left-adjoint-components-equal-is-rezk-is-segal)\n      ( \u03b7a)))\n  ( ap (hom B fa fa') (hom A a (u fa'))\n    ( first\n      ( iso-eq B (first is-rezk-B) fa fa'\n        ( all-left-adjoint-components-equal-is-rezk-is-segal)))\n    ( to-left-adjoint-components-is-rezk-is-segal)\n    ( \u03b7a-transposition fa')\n    ( iso-eq-iso-to-left-adjoint-components-is-rezk))\n  ( compute-covariant-transport-of-hom-family-is-segal A is-segal-A\n    ( a) (u fa) (u fa') ( \u03b7a)\n    ( ap-hom B A u fa fa' to-left-adjoint-components-is-rezk-is-segal))\n  ( compute-covariant-transport-of-substitution A B (hom A a)\n    ( is-covariant-representable-is-segal A is-segal-A a) u (fa) (fa')\n    ( to-left-adjoint-components-is-rezk-is-segal)\n    ( \u03b7a))\n  ( triangle-to-left-adjoint-components-is-rezk-is-segal)\n#def all-unit-components-equal-is-rezk-is-segal uses (extext A is-segal-A u a \u03c9 \u03c9')\n  : (fa, \u03b7a) =_{\u03a3 (b : B), hom A a (u b)} (fa', \u03b7a')\n  :=\n  path-of-pairs-pair-of-paths B (\\ b \u2192 hom A a (u b)) (fa) (fa')\n  ( all-left-adjoint-components-equal-is-rezk-is-segal)\n  ( \u03b7a) ( \u03b7a')\n  ( compute-transport-all-left-adjoint-components-equal-is-rezk-is-segal)\n#end all-unit-arrows-equal-is-rezk-is-segal\n#def is-transposing-unit\n( B A : U)\n( is-segal-A : is-segal A)\n( u : B \u2192 A)\n( f : A \u2192 B)\n( \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  : U\n  :=\n( a : A) \u2192 (b : B)\n  \u2192 is-equiv (hom B (f a) b) (hom A a (u b))\n    ( \\ k \u2192\n      comp-is-segal A is-segal-A a (u (f a)) (u b)\n      ( \\ t \u2192 \u03b7 t a)\n      ( ap-hom B A u (f a) b k))\n#def is-transposing-unit-components\n( B A : U)\n( is-segal-A : is-segal A)\n( u : B \u2192 A)\n( f : A \u2192 B)\n( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n  : U\n  :=\n( a : A) \u2192 (b : B)\n  \u2192 is-equiv (hom B (f a) b) (hom A a (u b))\n    ( \\ k \u2192\n      comp-is-segal A is-segal-A a (u (f a)) (u b)\n      ( \u03b7 a)\n      ( ap-hom B A u (f a) b k))\n#def equiv-transposing-unit-transposing-unit-components\n( B A : U)\n( is-segal-A : is-segal A)\n( u : B \u2192 A)\n  : Equiv\n( \u03a3 (f : A \u2192 B)\n      , \u03a3 ( \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n        , is-transposing-unit B A is-segal-A u f \u03b7)\n( \u03a3 (f : A \u2192 B)\n      , \u03a3 ( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n        , is-transposing-unit-components B A is-segal-A u f \u03b7)\n  :=\n  total-equiv-family-of-equiv\n  ( A \u2192 B)\n( \\ f \u2192\n    \u03a3 ( \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n    , is-transposing-unit B A is-segal-A u f \u03b7)\n( \\ f \u2192\n    \u03a3 ( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n        , is-transposing-unit-components B A is-segal-A u f \u03b7)\n  ( \\ f \u2192\n    equiv-total-pullback-is-equiv\n    ( nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n    ( nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n    ( ev-components-nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n    ( is-equiv-ev-components-nat-trans A (\\ _ \u2192 A)\n      ( identity A) (comp A B A u f))\n    ( \\ \u03b7 \u2192 is-transposing-unit-components B A is-segal-A u f \u03b7))\n#def equiv-choice-transposing-unit-components\n( B A : U)\n( is-segal-A : is-segal A)\n( u : B \u2192 A)\n  : Equiv\n( \u03a3 (f : A \u2192 B)\n      , \u03a3 ( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n        , is-transposing-unit-components B A is-segal-A u f \u03b7)\n( (a : A)\n      \u2192 \u03a3 (fa : B)\n        , \u03a3 ( \u03b7a : hom A a (u fa))\n          , ( b : B)\n            \u2192 is-equiv (hom B fa b) (hom A a (u b))\n              ( \\ k \u2192\n                comp-is-segal A is-segal-A a (u fa) (u b)\n                ( \u03b7a) (ap-hom B A u fa b k)))\n  :=\n  equiv-comp\n( \u03a3 (f : A \u2192 B)\n    , \u03a3 ( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n      , is-transposing-unit-components B A is-segal-A u f \u03b7)\n( \u03a3 (f : A \u2192 B)\n    , (a : A) \u2192\n\u03a3 ( \u03b7a : hom A a (u (f a)))\n      , ( b : B)\n        \u2192 is-equiv (hom B (f a) b) (hom A a (u b))\n          ( \\ k \u2192\n            comp-is-segal A is-segal-A a (u (f a)) (u b)\n            ( \u03b7a) (ap-hom B A u (f a) b k)))\n( ( a : A)\n      \u2192 \u03a3 (fa : B)\n        , \u03a3 ( \u03b7a : hom A a (u fa))\n          , ( b : B)\n            \u2192 is-equiv (hom B fa b) (hom A a (u b))\n              ( \\ k \u2192\n                comp-is-segal A is-segal-A a (u fa) (u b)\n                ( \u03b7a) (ap-hom B A u fa b k)))\n  ( total-equiv-family-of-equiv\n    ( A \u2192 B)\n( \\ f \u2192\n      \u03a3 ( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n          , is-transposing-unit-components B A is-segal-A u f \u03b7)\n( \\ f \u2192\n      (a : A)\n        \u2192 \u03a3 ( \u03b7a : hom A a (u (f a)))\n          , ( b : B)\n            \u2192 is-equiv (hom B (f a) b) (hom A a (u b))\n              ( \\ k \u2192\n                comp-is-segal A is-segal-A a (u (f a)) (u b)\n                ( \u03b7a)\n                ( ap-hom B A u (f a) b k)))\n    ( \\ f \u2192\n      inv-equiv-choice A ( \\ a \u2192 hom A a (u (f a)))\n( \\ a \u03b7a \u2192\n        ( b : B)\n          \u2192 is-equiv (hom B (f a) b) (hom A a (u b))\n            ( \\ k \u2192\n              comp-is-segal A is-segal-A a (u (f a)) (u b)\n              ( \u03b7a) (ap-hom B A u (f a) b k)))))\n  ( inv-equiv-choice A ( \\ _ \u2192 B)\n( \\ a fa \u2192\n      \u03a3 ( \u03b7a : hom A a (u fa))\n          , ( b : B)\n            \u2192 is-equiv (hom B fa b) (hom A a (u b))\n              ( \\ k \u2192\n                comp-is-segal A is-segal-A a (u fa) (u b)\n                ( \u03b7a) (ap-hom B A u fa b k))))\n#def equiv-choice-transposing-unit\n( B A : U)\n( is-segal-A : is-segal A)\n( u : B \u2192 A)\n  : Equiv\n( \u03a3 (f : A \u2192 B)\n      , \u03a3 ( \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n        , is-transposing-unit B A is-segal-A u f \u03b7)\n( (a : A)\n      \u2192 \u03a3 (fa : B)\n        , \u03a3 ( \u03b7a : hom A a (u fa))\n          , ( b : B)\n            \u2192 is-equiv (hom B fa b) (hom A a (u b))\n              ( \\ k \u2192\n                comp-is-segal A is-segal-A a (u fa) (u b)\n                ( \u03b7a) (ap-hom B A u fa b k)))\n  :=\n  equiv-comp\n( \u03a3 (f : A \u2192 B)\n    , \u03a3 ( \u03b7 : nat-trans A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n      , is-transposing-unit B A is-segal-A u f \u03b7)\n( \u03a3 (f : A \u2192 B)\n    , \u03a3 ( \u03b7 : nat-trans-components A (\\ _ \u2192 A) (identity A) (comp A B A u f))\n      , is-transposing-unit-components B A is-segal-A u f \u03b7)\n( (a : A)\n    \u2192 \u03a3 (fa : B)\n      , \u03a3 ( \u03b7a : hom A a (u fa))\n        , ( b : B)\n          \u2192 is-equiv (hom B fa b) (hom A a (u b))\n            ( \\ k \u2192\n              comp-is-segal A is-segal-A a (u fa) (u b)\n              ( \u03b7a) (ap-hom B A u fa b k)))\n  ( equiv-transposing-unit-transposing-unit-components B A is-segal-A u)\n  ( equiv-choice-transposing-unit-components B A is-segal-A u)\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/","title":"Cocartesian families","text":"<p>These formalizations capture cocartesian families as treated in BW23.</p> <p>The goal, for now, is not to give a general structural account as in the paper but rather to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/*</code> - We require various prerequisites from homotopy type theory, for   instance the axiom of function extensionality.</li> <li><code>03-simplicial-type-theory.rzk.md</code> \u2014 We rely on definitions of simplicies and   their subshapes.</li> <li><code>04-extension-types.rzk.md</code> \u2014 We use the fubini theorem and extension   extensionality.</li> <li><code>05-segal-types.rzk.md</code> - We make heavy use of the notion of Segal types</li> <li><code>10-rezk-types.rzk.md</code>- We use Rezk types.</li> </ul>"},{"location":"simplicial-hott/12-cocartesian.rzk/#iso-inner-families","title":"(Iso-)Inner families","text":"<p>This is a (tentative and redundant) definition of (iso-)inner families. In the future, hopefully, these can be replaced by instances of orthogonal and LARI families.</p> <pre><code>#def is-inner-family\n( B : U)\n( P : B \u2192 U)\n  : U\n  :=\n    product\n    ( product (is-segal B) (is-segal (\u03a3 (b : B) , P b)))\n( (b : B) \u2192 (is-segal (P b)))\n#def is-isoinner-family\n( B : U)\n( P : B \u2192 U)\n  : U\n  :=\n    product\n    ( product (is-rezk B) (is-rezk (\u03a3 (b : B) , P b)))\n( (b : B) \u2192 (is-rezk (P b)))\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-arrows","title":"Cocartesian arrows","text":"<p>Here we define the proposition that a dependent arrow in a family is cocartesian. This is an alternative version using unpacked extension types, as this is preferred for usage.</p> BW23, Definition 5.1.1<pre><code>#def is-cocartesian-arrow\n( B : U)\n( b b' : B)\n( u : hom B b b')\n( P : B \u2192 U)\n( e : P b)\n( e' : P b')\n( f : dhom B b b' u P e e')\n  : U\n  :=\n(b'' : B) \u2192 (v : hom B b' b'') \u2192 (w : hom B b b'') \u2192\n(sigma : hom2 B b b' b'' u v w) \u2192 (e'' : P b'') \u2192\n(h : dhom B b b'' w P e e'') \u2192\n      is-contr\n( \u03a3 ( g : dhom B b' b'' v P e' e'') ,\n          ( dhom2 B b b' b'' u v w sigma P e e' e'' f g h))\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-lifts","title":"Cocartesian lifts","text":"<p>The following is the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber.</p> BW23, Definition 5.1.2<pre><code>#def cocartesian-lift\n( B : U)\n( b b' : B)\n( u : hom B b b')\n( P : B \u2192 U)\n( e : P b)\n  : U\n  :=\n\u03a3 (e' : P b') ,\n\u03a3 (f : dhom B b b' u P e e') , is-cocartesian-arrow B b b' u P e e' f\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-family","title":"Cocartesian family","text":"<p>A family over cocartesian if it is isoinner and any arrow in the has a cocartesian lift, given a point in the fiber over the domain.</p> BW23, Definition 5.2.1<pre><code>#def has-cocartesian-lifts\n( B : U)\n( P : B \u2192 U)\n  : U\n  :=\n( b : B) \u2192 ( b' : B) \u2192 ( u : hom B b b') \u2192\n( e : P b) \u2192 ( \u03a3 (e' : P b'),\n( \u03a3 (f : dhom B b b' u P e e'), is-cocartesian-arrow B b b' u P e e' f))\n</code></pre> BW23, Definition 5.2.2<pre><code>#def is-cocartesian-family\n( B : U)\n( P : B \u2192 U)\n  : U\n  := product (is-isoinner-family B P) (has-cocartesian-lifts B P)\n</code></pre>"},{"location":"simplicial-hott/13-limits.rzk/","title":"13. Limits and colimits","text":"<p>These formalisations correspond in part to Section 3 of the BM22 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Some definitions make use of function extentionality and extension extensionality.</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/13-limits.rzk/#definition-limits-and-colimits","title":"Definition limits and colimits","text":"<p>Given a function <code>f : A \u2192 B</code> and <code>b:B</code> we define the type of cones over <code>f</code>.</p> <pre><code>#def cone\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (b : B), hom (A \u2192 B) (constant A B b) f\n</code></pre> <p>Given a function <code>f : A \u2192 B</code> and <code>b:B</code> we define the type of cocones under <code>f</code>.</p> <pre><code>#def cocone\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (b : B), hom ( A \u2192 B) f (constant A B b)\n</code></pre> <p>We define a colimit for <code>f : A \u2192 B</code> as an initial cocone under <code>f</code>.</p> <pre><code>#def colimit\n( A B : U )\n( f : A \u2192 B )\n  : U\n  := \u03a3 ( x : cocone A B f) , is-initial ( cocone A B f) x\n</code></pre> <p>We define a limit of <code>f : A \u2192 B</code> as a final cone over <code>f</code>.</p> <pre><code>#def limit\n( A B : U )\n( f : A \u2192 B )\n  : U\n  :=  \u03a3 ( x : cone A B f) , is-final ( cone A B f) x\n</code></pre> <p>We give a second definition of limits, we eventually want to prove both definitions coincide. Define cone as a family.</p> <pre><code>#def family-cone\n(A B : U)\n  : (A \u2192 B) \u2192 (B) \u2192 U\n  := \\ f \u2192 \\ b \u2192 (hom (A \u2192 B) (constant A B b) f)\n#def constant-nat-trans\n(A B : U)\n( x y : B )\n( k : hom B x y)\n  : hom (A \u2192 B) (constant A B x) (constant A B y)\n  := \\ t a \u2192 ( constant A ( hom B x y ) k ) a t\n#def cone-precomposition\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B )\n( b x : B )\n( k : hom B b x)\n  : ( family-cone A B f x) \u2192  ( family-cone A B f b)\n  :=\n\\ \u03b1\n  \u2192 vertical-comp-nat-trans\n    ( A)\n    ( \\ _ \u2192 B)\n    ( \\ _ \u2192 is-segal-B)\n    ( constant A B b)\n    ( constant A B x)\n    ( f)\n    ( constant-nat-trans A B b x k)\n    ( \u03b1)\n</code></pre> <p>Another definition of limit.</p> <pre><code>#def limit2\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (b : B),\n\u03a3 ( c : family-cone A B f b)\n    , ( x : B) \u2192 ( k : hom B b x)\n      \u2192 is-equiv\n        ( family-cone A B f x)\n        ( family-cone A B f b)\n        ( cone-precomposition A B is-segal-B f b x k)\n</code></pre> <p>We give a second definition of colimits, we eventually want to prove both definitions coincide. Define cocone as a family.</p> <pre><code>#def family-cocone\n(A B : U)\n  : ( A \u2192 B) \u2192 ( B) \u2192 U\n  := \\ f \u2192 \\ b \u2192 (hom (A \u2192 B) f (constant A B b))\n#def cocone-postcomposition\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n( x b : B)\n( k : hom B x b)\n  : ( family-cocone A B f x) \u2192 ( family-cocone A B f b)\n  :=\n\\ \u03b1\n  \u2192 vertical-comp-nat-trans\n    ( A)\n    ( \\ _ \u2192 B)\n    ( \\ _ \u2192 is-segal-B)\n    ( f)\n    ( constant A B x)\n    ( constant A B b)\n    ( \u03b1)\n    ( constant-nat-trans A B x b k )\n</code></pre> <p>Another definition of colimit.</p> <pre><code>#def colimit2\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n  : U\n  := \u03a3 (b : B),\n\u03a3 ( c : family-cocone A B f b)\n    , ( x : B) \u2192 ( k : hom B x b)\n    \u2192 is-equiv\n      ( family-cocone A B f x)\n      ( family-cocone A B f b)\n      ( cocone-postcomposition A B is-segal-B f x b k)\n</code></pre> <p>The following alternative definition does not require a Segalness condition. When <code>is-segal B</code> then definitions 1 and 3 coincide.</p> <pre><code>#def limit3\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 ( b : B),( x : B) \u2192 Equiv ( hom B b x) ( family-cone A B f x)\n#def colimit3\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := \u03a3 ( b : B), ( x : B) \u2192 Equiv ( hom B x b) ( family-cocone A B f x)\n</code></pre>"},{"location":"simplicial-hott/13-limits.rzk/#uniqueness-of-initial-and-final-objects","title":"Uniqueness of initial and final objects.","text":"<p>In a Segal type, initial objects are isomorphic.</p> <pre><code>#def iso-initial\n( A : U)\n( is-segal-A : is-segal A)\n( a b : A)\n( is-initial-a : is-initial A a)\n( is-initial-b : is-initial A b)\n  : Iso A is-segal-A a b\n  :=\n    ( first (is-initial-a b) ,\n      ( ( first (is-initial-b a) ,\n          all-elements-equal-is-contr\n            ( hom A a a)\n            ( is-initial-a a)\n            ( comp-is-segal A is-segal-A a b a\n              ( first (is-initial-a b))\n              ( first (is-initial-b a)))\n            ( id-hom A a)) ,\n        ( first (is-initial-b a) ,\n          all-elements-equal-is-contr\n            ( hom A b b)\n            ( is-initial-b b)\n            ( comp-is-segal A is-segal-A b a b\n              ( first (is-initial-b a))\n              ( first (is-initial-a b)))\n            ( id-hom A b))))\n</code></pre> <p>In a Segal type, final objects are isomorphic.</p> <pre><code>#def iso-final\n( A : U)\n( is-segal-A : is-segal A)\n( a b : A)\n( is-final-a : is-final A a)\n( is-final-b : is-final A b)\n  : Iso A is-segal-A a b\n  :=\n    ( first (is-final-b a) ,\n      ( ( first (is-final-a b) ,\n          all-elements-equal-is-contr\n            ( hom A a a)\n            ( is-final-a a)\n            ( comp-is-segal A is-segal-A a b a\n              ( first (is-final-b a))\n              ( first (is-final-a b)))\n            ( id-hom A a)) ,\n        ( first (is-final-a b) ,\n          all-elements-equal-is-contr\n            ( hom A b b)\n            ( is-final-b b)\n            ( comp-is-segal A is-segal-A b a b\n              ( first (is-final-a b))\n              ( first (is-final-b a)))\n            ( id-hom A b))))\n</code></pre>"},{"location":"simplicial-hott/13-limits.rzk/#uniqueness-up-to-isomophism-of-colimits","title":"Uniqueness up to isomophism of (co)limits.","text":"<p>The type of cocones of a function with codomain a Segal type is a Segal type.</p> BM22, Remark 4 (i)<pre><code>#def is-covariant-family-cone-is-segal\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n  : is-covariant B ( \\ b \u2192 family-cocone A B f b)\n  :=\n    is-covariant-substitution-is-covariant\n    ( A \u2192 B)\n    ( B)\n    ( hom ( A \u2192 B) f)\n    ( is-covariant-representable-is-segal\n        ( A \u2192 B)\n        ( is-segal-function-type\n          ( funext)\n          ( A)\n          ( \\ _ \u2192 B)\n          ( \\ _ \u2192 is-segal-B))\n        ( f))\n    ( \\ b \u2192 constant A B b)\n#def is-segal-cocone-is-segal uses (funext extext)\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n  : is-segal ( cocone A B f)\n  :=\n    is-segal-total-type-covariant-family-is-segal-base\n    ( extext)\n    ( B)\n    ( family-cocone A B f)\n    ( is-covariant-family-cone-is-segal\n      ( A)\n      ( B)\n      ( is-segal-B)\n      ( f))\n    ( is-segal-B)\n</code></pre> <p>Colimits are unique up to isomorphism.</p> BM, Corollary 1 (i)<pre><code>#def iso-colimit-is-segal uses ( extext funext)\n( A B : U)\n( is-segal-B : is-segal B)\n( f : A \u2192 B)\n( x y : colimit A B f)\n  : Iso\n    ( cocone A B f)\n    ( is-segal-cocone-is-segal A B is-segal-B f)\n    ( first x)\n    ( first y)\n  :=\n    iso-initial\n    ( cocone A B f)\n    ( is-segal-cocone-is-segal A B is-segal-B f)\n    ( first x)\n    ( first y)\n    ( second x)\n    ( second y)\n</code></pre>"}]}